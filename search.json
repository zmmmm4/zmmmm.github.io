[{"title":"20190313","url":"/2019/03/13/20190313/"},{"title":"Hard 164 Maximum Gap//Bucket Sort","url":"/2019/03/12/20190312/","content":"\n找到相邻顺序列的最大差\n\n<!-- more -->\n\n相关JAVA基础知识：\n\n**Java—ceil() 方法**http://www.runoob.com/java/number-ceil.html\n\n**Java—Sort排序**https://blog.csdn.net/whp1473/article/details/79678974\n\n\n\n# 问题\n\nGiven an unsorted array, find the maximum difference between the successive elements in its sorted form.\n\nReturn 0 if the array contains less than 2 elements.\n\n**Example 1:**\n\n```\nInput: [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either\n             (3,6) or (6,9) has the maximum difference 3.\n```\n\n**Example 2:**\n\n```\nInput: [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0.\n```\n\n**Note:**\n\n- You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.\n- Try to solve it in linear time/space.\n\n# 解\n\n### 个人的笨方法：\n\n```\n public int maximumGap(int[] nums) {\n        if(nums.length<2){\n            return 0;\n        }\n        Arrays.sort(nums);\n        int res=0;\n        for(int i=0;i<nums.length-1;i++){\n            res=(res<(nums[i+1]-nums[i]))?nums[i+1]-nums[i]:res;\n        }\n        return res;\n    }\n```\n\n### Bucket Sort：\n\n1、数组长度为N，已知数组里的min和max，那么最大连续差最小是gap=ceiling[(***max*** - ***min*** ) / (N - 1)]【ceil() 方法可对一个数进行上舍入】。\n\n2、bucket方法是把数组里的除了min和max的所有n-2个数字放入n-1个篮子里，篮子包含的数字范围差是gap，假如min=1且gap=2，那么[1,3)是一个篮子、[3,5)是一个篮子，以此类推。那么设篮子序号为k，则第k个篮子要放入[ min+(k-1)gap,min+k*gap )范围内的数字。\n\n3、这个方法并不需要真的定义k个数组，只要保存每个篮子的最大值和最小值，（因为gap为最小的连续差，说明最后得到的结果一定大于等于这个篮子的范围，大于这个范围的话一定要篮子之间的数字相减），只需要把上一个有数字放入的篮子的最小值和下一个有数字放入的篮子的最大值相减作差，得到的新的gap，和原来的gap比较并保存最大值。\n\n4、因此这个方法需要定义两个数组，分别存放每个篮子的最小值和最大值。\n\n```\nint[] bucketsMIN = new int[num.length - 1]; \nint[] bucketsMAX = new int[num.length - 1]; \n```\n\n第几个篮子，即在这两个数组里的正确位置：\n\n```\nint idx = (i - min) / gap;\n```\n\n则存放每个篮子最大值和最小值的过程：\n\n```\nfor (int i:num) {\n        if (i == min || i == max)\n            continue;\n        int idx = (i - min) / gap; \n        bucketsMIN[idx] = Math.min(i, bucketsMIN[idx]);\n        bucketsMAX[idx] = Math.max(i, bucketsMAX[idx]);\n    }\n```\n\n5、定义被除数初始值为min：\n\n```\nint previous = min;\n```\n\n每次计算完新的差后更新：\n\n```\nprevious = bucketsMAX[i];\n```\n\n遍历两个数组中存放的篮子们的最大值最小值，若篮子为空则跳过，看下一个。用当前篮子的最小值减去上一个保存的篮子的最大值得到新的差，再和原来的差比较：\n\n```\nmaxGap = Math.max(maxGap, bucketsMIN[i] - previous);\n```\n\n最后还要让max和上一个保存的篮子最大值相减，因为在把数放入篮子们也就是计入两个数组的过程中，没有考虑min和max。\n\n```\nmaxGap = Math.max(maxGap, max - previous);\n```\n\n\n\n#### 完整代码:\n\n```\npublic class Solution {\npublic int maximumGap(int[] num) {\n    if (num == null || num.length < 2)\n        return 0;\n    // get the max and min value of the array\n    int min = num[0];\n    int max = num[0];\n    for (int i:num) {\n        min = Math.min(min, i);\n        max = Math.max(max, i);\n    }\n    // the minimum possibale gap, ceiling of the integer division\n    int gap = (int)Math.ceil((double)(max - min)/(num.length - 1));\n    int[] bucketsMIN = new int[num.length - 1]; // store the min value in that bucket\n    int[] bucketsMAX = new int[num.length - 1]; // store the max value in that bucket\n    Arrays.fill(bucketsMIN, Integer.MAX_VALUE);\n    Arrays.fill(bucketsMAX, Integer.MIN_VALUE);\n    // put numbers into buckets\n    for (int i:num) {\n        if (i == min || i == max)\n            continue;\n        int idx = (i - min) / gap; // index of the right position in the buckets\n        bucketsMIN[idx] = Math.min(i, bucketsMIN[idx]);\n        bucketsMAX[idx] = Math.max(i, bucketsMAX[idx]);\n    }\n    // scan the buckets for the max gap\n    int maxGap = Integer.MIN_VALUE;\n    int previous = min;\n    for (int i = 0; i < num.length - 1; i++) {\n        if (bucketsMIN[i] == Integer.MAX_VALUE && bucketsMAX[i] == Integer.MIN_VALUE)\n            // empty bucket\n            continue;\n        // min value minus the previous value is the current gap\n        maxGap = Math.max(maxGap, bucketsMIN[i] - previous);\n        // update previous bucket value\n        previous = bucketsMAX[i];\n    }\n    maxGap = Math.max(maxGap, max - previous); // updata the final max value gap\n    return maxGap;\n}\n```","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"unity二进制存档和读档","url":"/2019/03/11/20190311/","content":"\n源自siki学院里的一个读存档例子\n\n<!-- more -->\n\n这个游戏是一个九宫格打怪物的游戏，其中，九个格子分别存以0~8的Target Positions，每个格子有当前激活的0~3的怪物类型Monster Types 。\n\n#### 1、新建一个save类来保存序列\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n[System.Serializable]\npublic class Save{\n\n    public List<int> livingTargetPositions = new List<int>();\n    public List<int> livingMonsterTypes = new List<int>();\n\n    public int shootNum = 0;\n    public int score = 0;\n}\n```\n\n#### 2、在GameManager.cs里实例化Save对象，并存储当前游戏状态信息。\n\n```\n private Save CreateSaveGO()\n    {\n        //新建Save对象\n        Save save = new Save();\n        //遍历所有的target\n        //如果其中有处于激活状态的怪物，就把该target的位置信息和激活状态的怪物的类型添加到List中\n        foreach (GameObject targetGO in targetGOs)\n        {\n            TargetManager targetManager = targetGO.GetComponent<TargetManager>();\n            if (targetManager.activeMonster != null)\n            {\n                save.livingTargetPositions.Add(targetManager.targetPosition);\n                int type = targetManager.activeMonster.GetComponent<MonsterManager>().monsterType;\n                save.livingMonsterTypes.Add(type);\n            }\n        }\n        //把shootNum和score保存在Save对象中\n        save.shootNum = UIManager._instance.shootNum;\n        save.score = UIManager._instance.score;\n        //返回该Save对象\n        return save;\n    }\n```\n\n#### 3、二进制存档\n\n需要的命名空间\n\n```\nusing UnityEngine;\nusing System.IO;\nusing System.Runtime.Serialization.Formatters.Binary;\n```\n\n\n\n```\n private void SaveByBin()\n    {\n        //序列化过程（将Save对象转换为字节流）\n        //创建Save对象并保存当前游戏状态\n        Save save = CreateSaveGO();\n        //创建一个二进制格式化程序\n        BinaryFormatter bf = new BinaryFormatter();\n        //创建一个文件流\n        FileStream fileStream = File.Create(Application.dataPath + \"/StreamingFile\" + \"/byBin.txt\");\n        //用二进制格式化程序的序列化方法来序列化Save对象,参数：创建的文件流和需要序列化的对象\n        bf.Serialize(fileStream, save);\n        //关闭流\n        fileStream.Close();\n\n        //如果文件存在，则显示保存成功\n        if (File.Exists(Application.dataPath + \"/StreamingFile\" + \"/byBin.txt\"))\n        {\n            UIManager._instance.ShowMessage(\"保存成功\");\n        }\n    }\n```\n\n1. 创建一个二进制格式化程序\n           BinaryFormatter bf = new BinaryFormatter();\n2. 创建一个文件流\n           FileStream fileStream = File.Create(Application.dataPath + \"/StreamingFile\" + \"/byBin.txt\");\n3. 用二进制格式化程序的序列化方法来序列化Save对象,参数：创建的文件流和需要序列化的对象\n           bf.Serialize(fileStream, save);\n4. 关闭流\n           fileStream.Close();\n\n#### 4、二进制读档\n\n```\nprivate void LoadByBin()\n    {\n        if(File.Exists(Application.dataPath + \"/StreamingFile\" + \"/byBin.txt\"))\n        {\n            //反序列化过程\n            //创建一个二进制格式化程序\n            BinaryFormatter bf = new BinaryFormatter();\n            //打开一个文件流\n            FileStream fileStream = File.Open(Application.dataPath + \"/StreamingFile\" + \"/byBin.txt\", FileMode.Open);\n            //调用格式化程序的反序列化方法，将文件流转换为一个Save对象\n            Save save = (Save)bf.Deserialize(fileStream);\n            //关闭文件流\n            fileStream.Close();\n\n            SetGame(save);\n            UIManager._instance.ShowMessage(\"\");\n\n        }\n        else\n        {\n            UIManager._instance.ShowMessage(\"存档文件不存在\");\n        }\n    }\n```\n\n1. 创建一个二进制格式化程序\n               BinaryFormatter bf = new BinaryFormatter();\n2. 打开一个文件流\n               FileStream fileStream = File.Open(Application.dataPath + \"/StreamingFile\" + \"/byBin.txt\", FileMode.Open);\n3. 调用格式化程序的反序列化方法，将文件流转换为一个Save对象\n               Save save = (Save)bf.Deserialize(fileStream);\n4. 关闭文件流\n               fileStream.Close();\n\n#### 5、通过读档信息重置我们的游戏状态（分数、激活状态的怪物）\n\n```\nprivate void SetGame(Save save)\n    {\n        //先将所有的targrt里面的怪物清空，并重置所有的计时\n        foreach(GameObject targetGO in targetGOs)\n        {\n            targetGO.GetComponent<TargetManager>().UpdateMonsters();\n        }\n        //通过反序列化得到的Save对象中存储的信息，激活指定的怪物\n        for(int i = 0; i < save.livingTargetPositions.Count; i++)\n        {\n            int position = save.livingTargetPositions[i];\n            int type = save.livingMonsterTypes[i];\n            targetGOs[position].GetComponent<TargetManager>().ActivateMonsterByType(type);\n        }\n\n        //更新UI显示\n        UIManager._instance.shootNum = save.shootNum;\n        UIManager._instance.score = save.score;\n        //调整为未暂停状态\n        UnPause();\n    }\n```\n\n","tags":["Unity"],"categories":["Unity"]},{"title":"unity JSON存档和读档","url":"/2019/03/10/20190310/","content":"\n源自siki学院里的一个读存档例子\n\n<!-- more -->\n\n这个游戏是一个九宫格打怪物的游戏，其中，九个格子分别存以0~8的Target Positions，每个格子有当前激活的0~3的怪物类型Monster Types 。\n\n#### 1、新建一个save类来保存序列\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n[System.Serializable]\npublic class Save{\n\n    public List<int> livingTargetPositions = new List<int>();\n    public List<int> livingMonsterTypes = new List<int>();\n\n    public int shootNum = 0;\n    public int score = 0;\n}\n```\n\n#### 2、在GameManager.cs里实例化Save对象，并存储当前游戏状态信息。\n\n```\n private Save CreateSaveGO()\n    {\n        //新建Save对象\n        Save save = new Save();\n        //遍历所有的target\n        //如果其中有处于激活状态的怪物，就把该target的位置信息和激活状态的怪物的类型添加到List中\n        foreach (GameObject targetGO in targetGOs)\n        {\n            TargetManager targetManager = targetGO.GetComponent<TargetManager>();\n            if (targetManager.activeMonster != null)\n            {\n                save.livingTargetPositions.Add(targetManager.targetPosition);\n                int type = targetManager.activeMonster.GetComponent<MonsterManager>().monsterType;\n                save.livingMonsterTypes.Add(type);\n            }\n        }\n        //把shootNum和score保存在Save对象中\n        save.shootNum = UIManager._instance.shootNum;\n        save.score = UIManager._instance.score;\n        //返回该Save对象\n        return save;\n    }\n```\n\n#### 3、JSON存档\n\n需要的命名空间\n\n```\nusing UnityEngine;\nusing System.IO;\nusing LitJson;\n```\n\n\n\n```\nprivate void SaveByJson()\n    {\n        Save save = CreateSaveGO();\n        string filePath = Application.dataPath + \"/StreamingFile\" + \"/byJson.json\";\n        //利用JsonMapper将save对象转换为Json格式的字符串\n        string saveJsonStr = JsonMapper.ToJson(save);\n        //将这个字符串写入到文件中\n        //创建一个StreamWriter，并将字符串写入文件中\n        StreamWriter sw = new StreamWriter(filePath);\n        sw.Write(saveJsonStr);\n        //关闭StreamWriter\n        sw.Close();\n\n        UIManager._instance.ShowMessage(\"保存成功\");\n    }\n```\n\n1. 写好存储地址：（斜杠不能丢下\n   string filePath = Application.dataPath + \"/StreamingFile\" + \"/byJson.json\";\n2. 将其他类型的对象转换为Json格式的字符串：\n   string saveJsonStr = JsonMapper.ToJson(save);\n3. 创建一个StreamWriter，并将字符串写入文件中\n   StreamWriter sw = new StreamWriter(filePath);\n   sw.Write(saveJsonStr);\n4. 关闭StreamWriter\n   sw.Close();\n\n#### 4、二进制读档\n\n```\nprivate void LoadByJson()\n    { \n        string filePath = Application.dataPath + \"/StreamingFile\" + \"/byJson.json\";\n        if(File.Exists(filePath))\n        {\n            //创建一个StreamReader，用来读取流\n            StreamReader sr = new StreamReader(filePath);\n            //将读取到的流赋值给jsonStr\n            string jsonStr = sr.ReadToEnd();\n            //关闭\n            sr.Close();\n\n            //将字符串jsonStr转换为Save对象\n            Save save = JsonMapper.ToObject<Save>(jsonStr);\n            SetGame(save);\n            UIManager._instance.ShowMessage(\"\");\n        }\n        else\n        {\n            UIManager._instance.ShowMessage(\"存档文件不存在\");\n        }\n    }\n```\n\n1. 创建一个StreamReader，用来读取流\n   StreamReader sr = new StreamReader(filePath);\n2. 将读取到的流赋值给jsonStr\n   string jsonStr = sr.ReadToEnd();\n3. 关闭 sr.Close();\n4. 将字符串jsonStr转换为其它对象\n    Save save = JsonMapper.ToObject<Save>(jsonStr);\n\n#### 5、通过读档信息重置我们的游戏状态（分数、激活状态的怪物）\n\n```\nprivate void SetGame(Save save)\n    {\n        //先将所有的targrt里面的怪物清空，并重置所有的计时\n        foreach(GameObject targetGO in targetGOs)\n        {\n            targetGO.GetComponent<TargetManager>().UpdateMonsters();\n        }\n        //通过反序列化得到的Save对象中存储的信息，激活指定的怪物\n        for(int i = 0; i < save.livingTargetPositions.Count; i++)\n        {\n            int position = save.livingTargetPositions[i];\n            int type = save.livingMonsterTypes[i];\n            targetGOs[position].GetComponent<TargetManager>().ActivateMonsterByType(type);\n        }\n\n        //更新UI显示\n        UIManager._instance.shootNum = save.shootNum;\n        UIManager._instance.score = save.score;\n        //调整为未暂停状态\n        UnPause();\n    }\n```\n\n","tags":["Unity"],"categories":["Unity"]},{"title":"unity XML存档和读档","url":"/2019/03/09/20190309/","content":"\n源自siki学院里的一个读存档例子\n\n<!-- more -->\n\n这个游戏是一个九宫格打怪物的游戏，其中，九个格子分别存以0~8的Target Positions，每个格子有当前激活的0~3的怪物类型Monster Types 。\n\n#### 1、新建一个save类来保存序列\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n[System.Serializable]\npublic class Save{\n\n    public List<int> livingTargetPositions = new List<int>();\n    public List<int> livingMonsterTypes = new List<int>();\n\n    public int shootNum = 0;\n    public int score = 0;\n}\n```\n\n#### 2、在GameManager.cs里实例化Save对象，并存储当前游戏状态信息。\n\n```\n private Save CreateSaveGO()\n    {\n        //新建Save对象\n        Save save = new Save();\n        //遍历所有的target\n        //如果其中有处于激活状态的怪物，就把该target的位置信息和激活状态的怪物的类型添加到List中\n        foreach (GameObject targetGO in targetGOs)\n        {\n            TargetManager targetManager = targetGO.GetComponent<TargetManager>();\n            if (targetManager.activeMonster != null)\n            {\n                save.livingTargetPositions.Add(targetManager.targetPosition);\n                int type = targetManager.activeMonster.GetComponent<MonsterManager>().monsterType;\n                save.livingMonsterTypes.Add(type);\n            }\n        }\n        //把shootNum和score保存在Save对象中\n        save.shootNum = UIManager._instance.shootNum;\n        save.score = UIManager._instance.score;\n        //返回该Save对象\n        return save;\n    }\n```\n\n#### 3、XML存档\n\n需要的命名空间\n\n```\nusing UnityEngine;\nusing System.IO;\nusing System.Xml;\n```\n\n```\n private void SaveByXml()\n    {\n        Save save = CreateSaveGO();\n        //创建XML文件的存储路径\n        string filePath = Application.dataPath + \"/StreamingFile\" + \"/byXML.txt\";\n        //创建XML文档\n        XmlDocument xmlDoc = new XmlDocument();\n        //创建根节点，即最上层节点\n        XmlElement root = xmlDoc.CreateElement(\"save\");\n        //设置根节点中的值\n        root.SetAttribute(\"name\", \"saveFile1\");\n\n        //创建XmlElement\n        XmlElement target;\n        XmlElement targetPosition;\n        XmlElement monsterType;\n\n        //遍历save中存储的数据，将数据转换成XML格式\n        for(int i = 0; i < save.livingTargetPositions.Count; i++)\n        {\n            target = xmlDoc.CreateElement(\"target\");\n            targetPosition = xmlDoc.CreateElement(\"targetPosition\");\n            //设置InnerText值\n            targetPosition.InnerText = save.livingTargetPositions[i].ToString();\n            monsterType = xmlDoc.CreateElement(\"monsterType\");\n            monsterType.InnerText = save.livingMonsterTypes[i].ToString();\n\n            //设置节点间的层级关系 root -- target -- (targetPosition, monsterType)\n            target.AppendChild(targetPosition);\n            target.AppendChild(monsterType);\n            root.AppendChild(target);\n        }\n\n        //设置射击数和分数节点并设置层级关系  xmlDoc -- root --(target-- (targetPosition, monsterType), shootNum, score)\n        XmlElement shootNum = xmlDoc.CreateElement(\"shootNum\");\n        shootNum.InnerText = save.shootNum.ToString();\n        root.AppendChild(shootNum);\n\n        XmlElement score = xmlDoc.CreateElement(\"score\");\n        score.InnerText = save.score.ToString();\n        root.AppendChild(score);\n\n        xmlDoc.AppendChild(root);\n        xmlDoc.Save(filePath);\n\n        if(File.Exists(Application.dataPath + \"/StreamingFile\" + \"/byXML.txt\"))\n        {\n            UIManager._instance.ShowMessage(\"保存成功\");\n        }\n    }\n```\n\n1. 创建XML文档 XmlDocument xmlDoc = new XmlDocument();\n\n2. 创建名为save的根节点，即最上层节点\n           XmlElement root = xmlDoc.CreateElement(\"save\");\n\n3.  设置根节点中的值name=saveFile1\n           root.SetAttribute(\"name\", \"saveFile1\");\n\n4.  创建XmlElement子结点\n           XmlElement target; [ target = xmlDoc.CreateElement(\"target\"); ]\n           XmlElement targetPosition;\n           XmlElement monsterType;\n\n5. 为子结点们加入内容，例如:  \n               targetPosition = xmlDoc.CreateElement(\"targetPosition\");\n               targetPosition.InnerText = save.livingTargetPositions[i].ToString();\n\n6. 设置结点间层级关系： target.AppendChild(targetPosition);\n\n7. 设置根节点层级关系并保存\n\n   ​        root.AppendChild(target);\n\n   ​        xmlDoc.AppendChild(root);\n   ​        xmlDoc.Save(filePath);\n\n   \n\n#### 4、二进制读档\n\n```\nprivate void LoadByXml()\n    {\n        string filePath = Application.dataPath + \"/StreamingFile\" + \"/byXML.txt\";\n        if(File.Exists(filePath))\n        {\n            Save save = new Save();\n            //加载XML文档\n            XmlDocument xmlDoc = new XmlDocument();\n            xmlDoc.Load(filePath);\n\n            //通过节点名称来获取元素，结果为XmlNodeList类型\n            XmlNodeList targets = xmlDoc.GetElementsByTagName(\"target\");\n            //遍历所有的target节点，并获得子节点和子节点的InnerText\n            if(targets.Count != 0)\n            {\n                foreach(XmlNode target in targets)\n                {\n                    XmlNode targetPosition = target.ChildNodes[0];\n                    int targetPositionIndex = int.Parse(targetPosition.InnerText);\n                    //把得到的值存储到save中\n                    save.livingTargetPositions.Add(targetPositionIndex);\n\n                    XmlNode monsterType = target.ChildNodes[1];\n                    int monsterTypeIndex = int.Parse(monsterType.InnerText);\n                    save.livingMonsterTypes.Add(monsterTypeIndex);\n                }\n            }\n            \n            //得到存储的射击数和分数\n            XmlNodeList shootNum = xmlDoc.GetElementsByTagName(\"shootNum\");\n            int shootNumCount = int.Parse(shootNum[0].InnerText);\n            save.shootNum = shootNumCount;\n\n            XmlNodeList score = xmlDoc.GetElementsByTagName(\"score\");\n            int scoreCount = int.Parse(score[0].InnerText);\n            save.score = scoreCount;\n\n            SetGame(save);\n            UIManager._instance.ShowMessage(\"\");\n\n        }\n        else\n        {\n            UIManager._instance.ShowMessage(\"存档文件不存在\");\n        }\n    }\n```\n\n1. 加载XML文档\n               XmlDocument xmlDoc = new XmlDocument();\n               xmlDoc.Load(filePath);\n\n2. 获取名为target的所有节点元素们，结果为XmlNodeList类型\n               XmlNodeList targets = xmlDoc.GetElementsByTagName(\"target\");\n\n3. 遍历所有的target节点们，并获得子节点和子节点的InnerText\n               foreach(XmlNode target in targets)\n\n4. 获取一个target节点中的第一/二个子结点的内容\n   XmlNode targetPosition = target.ChildNodes[0];\n\n   int targetPositionIndex = int.Parse(targetPosition.InnerText);\n\n   XmlNode monsterType = target.ChildNodes[1];\n\n   int monsterTypeIndex = int.Parse(monsterType.InnerText);\n\n#### 5、通过读档信息重置我们的游戏状态（分数、激活状态的怪物）\n\n```\nprivate void SetGame(Save save)\n    {\n        //先将所有的targrt里面的怪物清空，并重置所有的计时\n        foreach(GameObject targetGO in targetGOs)\n        {\n            targetGO.GetComponent<TargetManager>().UpdateMonsters();\n        }\n        //通过反序列化得到的Save对象中存储的信息，激活指定的怪物\n        for(int i = 0; i < save.livingTargetPositions.Count; i++)\n        {\n            int position = save.livingTargetPositions[i];\n            int type = save.livingMonsterTypes[i];\n            targetGOs[position].GetComponent<TargetManager>().ActivateMonsterByType(type);\n        }\n\n        //更新UI显示\n        UIManager._instance.shootNum = save.shootNum;\n        UIManager._instance.score = save.score;\n        //调整为未暂停状态\n        UnPause();\n    }\n```\n\n","tags":["Unity"],"categories":["Unity"]},{"title":"Hard 128 Longest Consecutive Sequence//HashMap","url":"/2019/03/08/20190308/","content":"\n跳一跳\n\n最长连续序列\n\n<!-- more -->\n\n###### HashMap相关知识\n\nhttps://www.cnblogs.com/skywang12345/p/3310835.html#b1\n\n# 问题\n\nGiven an unsorted array of integers, find the length of the longest consecutive elements sequence.\n\nYour algorithm should run in O(*n*) complexity.\n\n**Example:**\n\n```\nInput: [100, 4, 200, 1, 3, 2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n```\n\n# 解\n\n使用到了JAVA中的HashMap【HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。】，我们把数组中的数字设为key，包含key的最长连续子数列的长度设为value。\n\n1. 遍历nums数组中的数n，对于每一个n，查看map中是否存在n-1和n+1（比如有数字3，找2和4是否存在于map中），若存在则获取其value（也就是包括该数字的当前最长的子数列长度），存为left和right。\n2. sum=left+right+1为数字n目前的最长子数列长度。\n3. 把（n，sum）存入map。\n4. 把（n-left，sum）和（n+right，sum）存入map。利用已知的left和right两个长度得到n当前所在连续子数列的左右两端的数字n-left和n+right，用这次得到的新的长度sum代替以前存的旧长度，也便于第1步中获取当前最长的left和right。\n\n总时间复杂度为O(n)。\n\n```\npublic int longestConsecutive(int[] num) {\n    int res = 0;\n    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n    for (int n : num) {\n        if (!map.containsKey(n)) {\n            int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0;\n            int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0;\n            // sum: length of the sequence n is in\n            int sum = left + right + 1;\n            map.put(n, sum);\n            \n            // keep track of the max length \n            res = Math.max(res, sum);\n            \n            // extend the length to the boundary(s)\n            // of the sequence\n            // will do nothing if n has no neighbors\n            map.put(n - left, sum);\n            map.put(n + right, sum);\n        }\n        else {\n            // duplicates\n            continue;\n        }\n    }\n    return res;\n}\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"unity序列化 XML\\JSON","url":"/2019/03/06/20190306/","content":"\nhttps://blog.csdn.net/y1196645376/article/details/52541882\n\n<!-- more -->\n\n## 1.先介绍一下 XML 和 JSON 是什么东西吧？\n\n###       (1)XML\n\n扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进 行定义的源语言。 XML使用DTD(document type definition)文档类型定义来组织数据;格式统一，跨平台和语言，早已成为业界公认的标准。\nXML是标准通用标记语言 (SGML) 的子集，非常适合 Web 传输。XML 提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。\n\n###       (2)Json\n\nJSON(JavaScript Object Notation)一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。可在不同平台之间进行数据交换。JSON采用兼容性很高的、完全独立于语言文本格式，同时也具备类似于C语言的习惯(包括C, C++, C#, Java, JavaScript, Perl,\n Python等)体系的行为。这些特性使JSON成为理想的数据交换语言。\n        说了那么多，其实就是数据的两种保存格式。主要用于配置文件，描述数据，存储数据，数据传输等等。\n\n## 2.因为Xml和Json都可以办到这些事情，那么它们之间有什么区别么？各自的优缺点？\n\n###       (1)XML\n\n优点：格式统一，符合标准；.容易与其他系统进行远程交互，数据共享比较方便。\n        缺点：XML文件庞大，文件格式复杂，传输占带宽；服务器端和客户端解析XML花费较多的资源和时间；需要花费大量代码来解析XML；\n\n###       (2)Json\n\n优点：数据格式比较简单，易于读写，格式都是压缩的，占用带宽小；.支持多种语言；\n        缺点：可读性较xml略差；\n         ***总而言之，两者可以相互转换，功能都是相差无几的。但是json比xml较好，但xml更加通用。***\n\n## 3.XML使用的简单介绍.\n\n**a.先来看一段简单的xml代码。**\n\n```\n<team name=\"Dreamer\">\t\n    <student>\t\t\n        <name>Tom</name>\t\t\n        <age>20</age>\t\t\n        <id>20111234</id>\t\n    </student>\t\n        <student>\t\t\n        <name>Shierly</name>\t\t         <age>19</age>\t\t\n        <id>20113210</id>\t\n    </student>\t\n    <student>\t\t\n        <name>Lili</name>\t\t\n        <age>21</age>\t\t\n    <id>20111110</id>\t\n    </student>\n</team>\n\n```\n\n#### Unity3D中使用（可以使用C#自带的库,不需要引入其他库。using System.Xml\n\n```\n\npublic void CreateXML()\n\n{\n\n \n\n    //xml保存的路径，注意路径。\n\n    string filepath = \"E:/my.xml\";\n\n    //继续判断当前路径下是否有该文件\n\n    if(!File.Exists (filepath))\n\n    {\n\n        //创建XML文档实例\n\n        XmlDocument xmlDoc = new XmlDocument();\n\n        //创建root节点，也就是最上一层节点\n\n        XmlElement root = xmlDoc.CreateElement(\"team\");\n\n        root.SetAttribute(\"name\", \"Dreamer\");\n\n        //继续创建下一层节点\n\n        XmlElement student = xmlDoc.CreateElement(\"student\");\n\n \n\n        //继续创建下一层节点\n\n        XmlElement name = xmlDoc.CreateElement(\"name\");\n\n        //设置节点中的数值\n\n        name.InnerText = \"Tom\";\n\n        XmlElement age = xmlDoc.CreateElement(\"age\");\n\n        age.InnerText = \"20\";\n\n        XmlElement id = xmlDoc.CreateElement(\"id\");\n\n        id.InnerText = \"20111234\";\n\n \n\n        //把节点一层一层的添加至XMLDoc中 ，请仔细看它们之间的先后顺序，这将是生成XML文件的顺序\n\n        student.AppendChild(name);\n\n        student.AppendChild(age);\n\n        student.AppendChild(id);\n\n        root.AppendChild(student);\n\n \n\n        student = xmlDoc.CreateElement(\"student\");\n\n        name = xmlDoc.CreateElement(\"name\");\n\n        name.InnerText = \"Shierly\";\n\n        age = xmlDoc.CreateElement(\"age\");\n\n        age.InnerText = \"19\";\n\n        id = xmlDoc.CreateElement(\"id\");\n\n        id.InnerText = \"20113210\";\n\n        student.AppendChild(name);\n\n        student.AppendChild(age);\n\n        student.AppendChild(id);\n\n        root.AppendChild(student);\n\n \n\n        student = xmlDoc.CreateElement(\"student\");\n\n        name = xmlDoc.CreateElement(\"name\");\n\n        name.InnerText = \"Lili\";\n\n        age = xmlDoc.CreateElement(\"age\");\n\n        age.InnerText = \"21\";\n\n        id = xmlDoc.CreateElement(\"id\");\n\n        id.InnerText = \"20111110\";\n\n        student.AppendChild(name);\n\n        student.AppendChild(age);\n\n        student.AppendChild(id);\n\n        root.AppendChild(student);\n\n \n\n        xmlDoc.AppendChild(root);\n\n        //把XML文件保存至本地\n\n        xmlDoc.Save(filepath);\n\n    }\n\n \n\n}\n\n```\n\n这个代码运行后就会在目标文件夹中生成一个xml文件而文件内容就是1中的那段xml代码。\n可以看出来 XmlElement 是基本结构单元。也就是xml中的一对<Name></Name>。\n1.我们可以对这个结构单元添加属性：xmlelement.SetAttribute(name,value)。\n2.也可以对这个结构单元添加子结构单元：xmlelement.AppendChild(childelement)。\n\n3.如果该结构单元没有子结构了还可以设置它的内容值：xmlelement.InnerText = value.\n\n。。。","tags":["Unity"],"categories":["Unity"]},{"title":"Hard 42 Trapping Rain Water","url":"/2019/03/05/20190305/","content":"\n捕获雨水\n\n<!-- more -->\n\n# 问题\n\nGiven *n* non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n\n  \n\n![img](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)\n The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. **Thanks Marcos** for contributing this image!\n\n  \n\n**Example:**\n\n  \n\n```\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\n```\n\n# 解\n\n每块储水区域的横坐标单位都为1，主要计算每一个储水条条高度相加就可以了。\n\n设定左右两个游标，哪边矮就把哪边的游标往中间移动一个单位，并计算那一边的水量。\n\n```\n public int trap(int[] height) {\n        int left=0,right=height.length-1,maxleft=0,maxright=0,res=0;\n        while(left<=right){\n            if(height[left]<height[right]){\n                if(height[left]>maxleft){\n                    maxleft=height[left];\n                }\n                else{\n                    res+=maxleft-height[left];\n                }\n                left++;\n            }\n            else{\n                if(height[right]>maxright){\n                    maxright=height[right];\n                }\n                else{\n                    res+=maxright-height[right];\n                }\n                right--;\n            }\n        }\n        return res;\n    }\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"121+122+123 Best Time to Buy and Sell Stock","url":"/2019/03/03/20190303/","content":"\n炒股票：这一系列问题是典型的dp问题，dp的关键是找到表示状态的变量，并推导出过渡函数。\n\n<!-- more -->\n\n[TOC]\n\n\n\n# 问题1\n\nSay you have an array for which the *i*th element is the price of a given stock on day *i*.\n\nIf you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.\n\nNote that you cannot sell a stock before you buy one.\n\n假设有一个数组，其中的第i*个元素是给定股票在第i*天的价格。\n\n如果只允许您完成最多一项交易(即(即买一股，卖一股)，设计一种算法来寻找最大利润。\n\n注意，你不能在买股票之前就把它卖掉。\n\n**Example 1:**\n\n```\nInput: [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\n             Not 7-1 = 6, as selling price needs to be larger than buying price.\n```\n\n**Example 2:**\n\n```\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\n```\n\n# 解\n\n#### 很笨的方法：\n\n```\n public int maxProfit(int[] prices) {\n        int profit=0;\n        for(int i=0;i<prices.length-1;i++){\n            for(int j=i;j<prices.length;j++){\n                if(prices[j] < prices[i]){\n                    continue;\n                }\n                profit=Math.max(profit,prices[j]-prices[i]);\n            }\n        }\n        return profit;\n    }\n```\n\nRuntime: 252 ms, faster than 13.07% of Java online submissions for Best Time to Buy and Sell Stock.\n\nMemory Usage: 37.3 MB, less than 71.25% of Java online submissions forBest Time to Buy and Sell Stock.\n\n#### 一种聪明的方法：\n\n```\npublic int maxProfit(int[] prices) {\n        int maxCur = 0, maxSoFar = 0;\n        for(int i = 1; i < prices.length; i++) {\n            maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]);\n            maxSoFar = Math.max(maxCur, maxSoFar);\n        }\n        return maxSoFar;\n    }\n```\n\nRuntime: 1 ms, faster than 99.69% of Java online submissions for Best Time to Buy and Sell Stock.\n\nMemory Usage: 35.5 MB, less than 98.16% of Java online submissions forBest Time to Buy and Sell Stock.\n\n#### 还有一种方法：找到最小值\n\n```\nint maxProfit(vector<int> &prices) {\n    int maxPro = 0;\n    int minPrice = INT_MAX;\n    for(int i = 0; i < prices.size(); i++){\n        minPrice = min(minPrice, prices[i]);\n        maxPro = max(maxPro, prices[i] - minPrice);\n    }\n    return maxPro;\n}\n```\n\n# 问题2\n\n可交易多次。\n\n**Example** 1:\n\n```\nInput: [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n```\n\n**Example 2:**\n\n```\nInput: [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\n             engaging multiple transactions at the same time. You must sell before buying again.\n```\n\n**Example 3:**\n\n```\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\n```\n\n# 解\n\n很简单的方法：\n\n```\npublic int maxProfit(int[] prices) {\n        int maxCur = 0;\n        for(int i = 1; i < prices.length; i++) {\n            if(prices[i]>prices[i-1]){\n                 maxCur += prices[i] - prices[i-1];\n            }\n        }\n        return maxCur;\n    }\n```\n\n#### 找局部最大值和最小值的方法：\n\n```\npublic int maxProfit(int[] prices) {\n    int profit = 0, i = 0;\n    while (i < prices.length) {\n        // find next local minimum\n        while (i < prices.length-1 && prices[i+1] <= prices[i]) i++;\n        int min = prices[i++]; // need increment to avoid infinite loop for \"[1]\"\n        // find next local maximum\n        while (i < prices.length-1 && prices[i+1] >= prices[i]) i++;\n        profit += i < prices.length ? prices[i++] - min : 0;\n    }\n    return profit;\n}\n```\n\n# 问题3\n\n最多交易两次\n\nSay you have an array for which the *i* th element is the price of a given stock on day *i*.\n\nDesign an algorithm to find the maximum profit. You may complete at most *two* transactions.\n\n**Note:** You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n\n假设有一个数组，其中的第i*个元素是给定股票在第i*天的价格。\n\n设计一种寻找最大利润的算法。您最多可以完成两次交易。\n\n**注:**阁下不得同时进行多项交易(即你必须先把股票卖了，然后再买。\n\n# 解\n\n### \n\n#### 方法一\n\n假设我们一开始只有0元，4个变量来保存一些到目前为止有趣的“上限”——\n\n如果我们只买第一支股票，\n\n如果我们只卖第一支股票，\n\n如果我们只买第二支股票，\n\n如果我们只卖第二支股票。\n\n```\npublic int maxProfit(int[] prices) {\n        int hold1 = Integer.MIN_VALUE, hold2 = Integer.MIN_VALUE;\n        int release1 = 0, release2 = 0;\n        for(int i:prices){                              public int maxProfit(int[] prices) {\n        int hold1 = Integer.MIN_VALUE, hold2 = Integer.MIN_VALUE;\n        int release1 = 0, release2 = 0;\n        for(int i:prices){                              \n            hold1    = Math.max(hold1,    -i);          \n            release1 = Math.max(release1, hold1+i);    \n            hold2    = Math.max(hold2,    release1-i);  \n            release2 = Math.max(release2, hold2+i);    \n        }\n        return release2;\n\n    }\n```\n\n每天，我们以尽可能低的价格买进股票，以尽可能高的价格卖出股票。对于第二笔交易，我们将第一笔交易的利润整合到第二笔购买的成本中，那么第二笔出售的利润就是两笔交易的总利润。\n\n#### 方法二：\n\n对于第 k 轮交易、一共第 i 天，设定获利为 dp[k, i]。\n\n如果第 i 天没有进行交易，那么获利和前一天一样，即dp[k, i]= dp[k, i-1] 。\n\n如果我们在第 j 天买股票 j=[0..i-1]，然后在第 i 天卖出股票，那么利润就是 prices[i] - prices[j] + dp[k-1, j-1] 。实际上 j 也可以是 i ，当 j = i 时，prices[i] - prices[j] + dp[k-1, j] = dp[k-1, i] ，看来我们只是失去了一次交易的机会。\n\n我们希望prices[i] - prices[j] + dp[k-1, j-1] 最大，那么 prices[i]要最大，prices[j] - dp[k-1, j-1]就要最小。因此有了min = Math.Min(min, prices[i] - dp[k-1, i-1])，和dp[k, i] = Math.Max(dp[k, i-1], prices[i] - min)。\n\n```\npublic int MaxProfitDpCompact1(int[] prices) {\n           if (prices.length == 0) return 0;\n        int[][] dp = new int[3][prices.length];\n        for (int k = 1; k <= 2; k++) {\n            int min = prices[0];\n            for (int i = 1; i < prices.length; i++) {\n                min = Math.min(min, prices[i] - dp[k-1][i-1]);\n                dp[k][i] = Math.max(dp[k][i-1], prices[i] - min);\n            }\n        }\n\n        return dp[2][prices.length - 1];\n        }\n```\n\nTime complexity is O(kn), space complexity is O(kn).\n\n# 问题309\n\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75927/Share-my-thinking-process\n\n```\npublic int maxProfit(int[] prices) {\n    int sell = 0, prev_sell = 0, buy = Integer.MIN_VALUE, prev_buy;\n    for (int price : prices) {\n        prev_buy = buy;\n        buy = Math.max(prev_sell - price, prev_buy);\n        prev_sell = sell;\n        sell = Math.max(prev_buy + price, prev_sell);\n    }\n    return sell;\n}\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Medium 55+Hard 45 Jump Game","url":"/2019/03/02/20190302/","content":"\n跳一跳\n\n<!-- more -->\n\n# 问题1\n\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\n\nEach element in the array represents your maximum jump length at that position.\n\nDetermine if you are able to reach the last index.\n\n**Example 1:**\n\n```\nInput: [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n```\n\n**Example 2:**\n\n```\nInput: [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum\n             jump length is 0, which makes it impossible to reach the last index.\n```\n\n# 解\n\n每个数组元素存的是从当前位置最多可以跳多少个，而像例二就是不论从前三个哪一个位置都跳不到第四个位置，是false的。\n\n使用一个jumpmax记录当前最大距离。\n\n在每个新位置起跳的最远距离是(i+nums[i])，也就是跳到这个位置使用的步数+从这个位置开始跳的最大步数。\n\n如果jumpmax<i，就说明走不到i这个位置。\n\n```\n   public boolean canJump(int[] nums) {\n        int jumpmax=0;\n        for(int i=0;i<nums.length;i++){\n            if(jumpmax<i){\n                return false;\n            }\n            jumpmax=Math.max(jumpmax,(i+nums[i]));\n        }\n        return true;\n    }\n```\n\n# 问题2\n\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\n\nEach element in the array represents your maximum jump length at that position.\n\nYour goal is to reach the last index in the minimum number of jumps.\n\n**Example:**\n\n```\nInput: [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2.\n    Jump 1 step from index 0 to 1, then 3 steps to the last index.\n```\n\n和问题1 的区别：输出结果是，用最小的跳数跳到最后一个位置。\n\n# 解\n\n```\npublic int jump(int[] nums) {\n        int jumps=0,steps=nums[0],end=0;\n        for(int i=0;i<nums.length-1;i++){\n            steps=Math.max(steps,(i+nums[i]));\n            if(i==end){\n                jumps++;\n                end=steps;\n            }\n        }\n        return jumps;\n}\n```\n\n\n\n### 评论区的一个c++解:\n\n使用了start和end两个数来记录当前这一跳的起点和最远能跳到的终点，用maxend来找到在这段距离中开始下一跳能达到的最远的步数。\n\n```\nint jump(vector<int>& nums) {\n        int n = nums.size(), step = 0, start = 0, end = 0;\n        while (end < n - 1) {\n            step++; \n\t\t\tint maxend = end + 1;\n\t\t\tfor (int i = start; i <= end; i++) {\n                if (i + nums[i] >= n - 1) return step;\n\t\t\t\tmaxend = max(maxend, i + nums[i]);\n\t\t\t}\n            start = end + 1;\n            end = maxend;\n        }\n\t\treturn step;\n    }\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Easy 217 Contains Duplicate","url":"/2019/02/28/20190228/","content":"\n检查数组是否内容重复\n\n<!-- more -->\n\n# 问题\n\nGiven an array of integers, find if the array contains any duplicates.\n\nYour function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n\n**Example 1:**\n\n```\nInput: [1,2,3,1]\nOutput: true\n```\n\n**Example 2:**\n\n```\nInput: [1,2,3,4]\nOutput: false\n```\n\n**Example 3:**\n\n```\nInput: [1,1,1,3,3,4,3,2,4,2]\nOutput: true\n```\n\n# 解\n\n#### HUSH\n\nTime complexity: O(N), memory: O(N)\n\n我们可以使用一个众所周知的数据结构哈希表，它将帮助我们识别一个元素是否以前在数组中遇到过。\n\n------\n\n```\npublic boolean containsDuplicate(int[] nums) {\n    final Set<Integer> distinct = new HashSet<Integer>();\n    for(int num : nums) {\n        if(distinct.contains(num)) {\n            return true;\n        }\n        distinct.add(num);\n    }\n    return false;\n}\n```\n\n这是时空权衡的一个很好的例子。\n\n另外两种native方法：\n\n#### 1\n\nTime complexity: O(N^2), memory: O(1)\n\n最天真烂漫的方法就是迭代每一个数字，检查是否有与它重复的，导致时间复杂度高达O(N^2)。\n\n------\n\n```\npublic boolean containsDuplicate(int[] nums) {\n\n        for(int i = 0; i < nums.length; i++) {\n            for(int j = i + 1; j < nums.length; j++) {\n                if(nums[i] == nums[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n```\n\n#### 2\n\nTime complexity: O(N lg N), memory: O(1) - not counting the memory used by sort\n\n先排序，重复的数字会排在一起，这样查重起来非常方便。\n\n------\n\n```\n    public boolean containsDuplicate(int[] nums) {\n\n        Arrays.sort(nums);\n        for(int ind = 1; ind < nums.length; ind++) {\n            if(nums[ind] == nums[ind - 1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n```","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Medium 274 H-Index","url":"/2019/02/27/20190227/","content":"\n科学家的引用文献数问题\n\n<!-- more -->\n\n# 问题\n\nGiven an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): \"A scientist has index *h* if *h* of his/her *N *papers have **at least** *h* citations each, and the other *N − h* papers have **no more than** *h* citations each.\"\n\n**Example:**\n\n```\nInput: citations = [3,0,6,1,5]\nOutput: 3 \nExplanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had \n             received 3, 0, 6, 1, 5 citations respectively. \n             Since the researcher has 3 papers with at least 3 citations each and the remaining \n             two with no more than 3 citations each, her h-index is 3.\n```\n\n**Note:** If there are several possible values for *h*, the maximum one is taken as the h-index.\n\n# 思路\n\n在一共N篇文章里，有h篇文章的索引大于等于h个，其它N-h篇文章的文献小于h个，要找到这个h值。\n\n统计有0、1、2、3、....、>=h个索引的文章数分别是多少，然后把文章数从后往前累加，直到文章数>=索引数。\n\n```\n  public int hIndex(int[] citations) {\n        int n=citations.length;\n        int[] buckets=new int[n+1];\n        for(int i:citations){\n            if(i>=n){\n                buckets[n]++;\n            }\n            else{\n                buckets[i]++;\n            }\n        }\n        int count=0;\n        for(int j=n;j>=0;j--){\n            count+=buckets[j];\n            if(count>=j)\n            {\n                return j;\n            }\n        }\n        return 0;\n   }\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Medium 134 Gas Station","url":"/2019/02/26/20190226/","content":"\n加油站问题=￣ω￣=\n\n<!-- more -->\n\n# 问题\n\nThere are *N* gas stations along a circular route, where the amount of gas at station *i* is `gas[i]`.\n\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from station *i* to its next station (*i*+1). You begin the journey with an empty tank at one of the gas stations.\n\nReturn the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.\n\n**Note:**\n\n- If there exists a solution, it is guaranteed to be unique.\n- Both input arrays are non-empty and have the same length.\n- Each element in the input arrays is a non-negative integer.\n\n**Example 1:**\n\n```\nInput: \ngas  = [1,2,3,4,5]\ncost = [3,4,5,1,2]\n\nOutput: 3\n\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n```\n\n**Example 2:**\n\n```\nInput: \ngas  = [2,3,4]\ncost = [3,4,3]\n\nOutput: -1\n\nExplanation:\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.\n```\n\n# 解\n\n思路：\n\n假设以 i 站为起点，到 i+j 站没油了只能停止，那么从 i+1 站到 i+j-1 站中任何一站都不能到达 i+j 站。也就是说，如果A地能到B地，B地能到C地，那么A地能到C地。\n\n因此可以先写一个for循环，令起点 i 的范围是0~n-1，每次i=i+j；j是内部for循环的一个值，内部for循环代表的是以 i 为起点往后移动，计算每一步移动后的总油量，若油量为负则结束内循环，让外部 i 跳过这一段，也就是i=i+j，再在新 i 的基础上往后移动并计算。\n\n代码：\n\n```\n int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int i,j,n=gas.size();\n        for(i=0;i<n;i+=j){\n            int sum=0;\n            for(j=1;j<n+1;j++){\n                sum+=gas[(i+j-1)%n]-cost[(i+j-1)%n];\n                if(sum<0){\n                    break;\n                }\n            }\n            if(sum>=0){\n                return i;\n            }\n        }\n        return -1;\n    }\n```\n\n评论区另外一个写法，思路是差不多的：\n\n```\nint canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\n        int start(0),total(0),tank(0);\n        //if car fails at 'start', record the next station\n        for(int i=0;i<gas.size();i++){\n            if((tank=tank+gas[i]-cost[i])<0) \n            {\n                start=i+1;\n                total+=tank;\n                tank=0;\n            }\n        }\n        return (total+tank<0)? -1:start;\n}\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Medium 299 Bulls and Cows","url":"/2019/02/24/2019022402/","content":"\n一个猜谜小游戏\n\n<!-- more -->\n\n# 问题\n\nYou are playing the following [Bulls and Cows](https://en.wikipedia.org/wiki/Bulls_and_Cows) game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called \"bulls\") and how many digits match the secret number but locate in the wrong position (called \"cows\"). Your friend will use successive guesses and hints to eventually derive the secret number.\n\n  \n\nWrite a function to return a hint according to the secret number and friend's guess, use `A` to indicate the bulls and `B` to indicate the cows. \n\n  \n\nPlease note that both secret number and friend's guess may contain duplicate digits.\n\n  \n\n**Example 1:**\n\n  \n\n```\nInput: secret = \"1807\", guess = \"7810\"\n\nOutput: \"1A3B\"\n\nExplanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.\n```\n\n  \n\n**Example 2:**\n\n  \n\n```\nInput: secret = \"1123\", guess = \"0111\"\n\nOutput: \"1A1B\"\n\nExplanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.\n```\n\n  \n\n**Note:** You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.\n\n\n\n就是说，如果位置和数字都对，就bull+1，如果数字有但是位置不对，就guess+1.\n\n# 解\n\n```\nclass Solution {\npublic:\n    string getHint(string secret, string guess) {\n        int bull=0,cows=0;\n        vector<int> sec(10,0);\n        vector<int> gus(10,0);//0~9的容器\n        if(secret.size()!=guess.size() || guess.empty()){\n            return \"0A0B\";\n        }\n        for(int i=0;i<guess.size();i++){\n            char se=secret[i];\n            char gu=guess[i];\n            if(se==gu){\n                bull++;\n            }else{\n                sec[se-'0']++;\n                gus[gu-'0']++;\n            }\n        }\n        for(int j=0;j<sec.size();j++){\n            cows+=min(sec[j],gus[j]);\n        }\n        return to_string(bull)+'A'+to_string(cows)+'B';\n        \n    }\n};\n```\n\nbull很容易得到，cows得到的方法：\n\n新建两个长为10的int型容器，每个容器的10个位置分别存储数字0到9的个数。如secret=‘’1807“，则容器里面{1，1，0，0，0，0，0，1，1，0}.。最后把两个容器里对应位置的最小值相加，就是数字对了但是位置不对的个数，则是cows。","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"hard 41 First Missing Positive","url":"/2019/02/24/20190224/","content":"\n第一个丢失的正整数\n\n<!-- more -->\n\n# 问题\n\nGiven an unsorted integer array, find the smallest missing positive integer.\n\n**Example 1:**\n\n```\nInput: [1,2,0]\nOutput: 3\n```\n\n**Example 2:**\n\n```\nInput: [3,4,-1,1]\nOutput: 2\n```\n\n**Example 3:**\n\n```\nInput: [7,8,9,11,12]\nOutput: 1\n```\n\n**Note:\n\nYour algorithm should run in *O*(*n*) time and uses constant extra space.\n\n# 解\n\n这个题的意思大概就是，例如input=【1，2，0】，和【1，2，3】对比少了【1】；input=【3，4，-1，1】，和【1，2，3，4】对比少了【2】。\n\n评论区一个解是：\n\n```\nclass Solution\n{\npublic:\n    int firstMissingPositive(int A[], int n)\n    {\n        int n=nums.size();\n        //遍历每个数字\n        for(int i = 0; i < n; ++ i){  \n            while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]){\n            //若A[i]-1!=i则交换到正确的位置\n            //while条件可以在交换之后再检查一次新的A[i]值，保证不遗漏\n                swap(nums[i], nums[nums[i] - 1]);//交换位置\n            }\n        }\n        for(int i = 0; i < n; ++ i){\n            if(nums[i] != i + 1){\n                return i + 1;\n            }   \n        }\n        return n + 1;\n    }\n};\n```\n\n用一个等大的数组来顺序保存这些数字，把正确存在的数放在应该放的位置，丢失了也就是没存在的位置记为-1，比如数组【3，4，-1，1，8】，把其保存为【1，-1，3，4，-1】，数组的每个位置都保存着比下标+1的数。然后只需要遍历数组，第一个a[i]!=i+1，就说明缺失了i+1。\n\n于是按照以上思路，不需要用一个额外的数组，可以直接把原数组当成新数组来使用，会出现的问题就是可能覆盖掉之前的有用的数。可以采用交换的方法，把被覆盖的数移动到要去覆盖的数的位置，也就是交换一下位置，例如【3，4，-1，1，8】，要把nums[0]的数字【3】移动到【-1】，不直接覆盖，而是交换位置，变成【-1，4，3，1，8】。然后判断当前nums[0]的数字【-1】，不是正数，忽略。\n\n最后只需要遍历nums数组，第一个。nums[i]!=i+1，就说明缺失了i+1。","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"easy 189 Rotate Array","url":"/2019/02/22/20190222/","content":"\n旋转数组(●'◡'●)\n\n<!-- more -->\n\n# 问题\n\nGiven an array, rotate the array to the right by *k* steps, where *k* is non-negative.\n\n**Example 1:**\n\n```\nInput: [1,2,3,4,5,6,7] and k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n```\n\n**Example 2:**\n\n```\nInput: [-1,-100,3,99] and k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n```\n\n**Note:**\n\n- Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\n- Could you do it in-place with O(1) extra space?\n\n# 解\n\n自己写的方法复杂度太高，去评论区学习了几种其它思路：\n\n#### 1、对数组拷贝一份，然后再旋转。\n\ntc：O(n)   sc：O(n)\n\n```\nvoid rotate(int nums[], int n, int k) \n        {\n            if ((n == 0) || (k <= 0))\n            {\n                return;\n            }\n            \n            // Make a copy of nums\n            vector<int> numsCopy(n);\n            for (int i = 0; i < n; i++)\n            {\n                numsCopy[i] = nums[i];\n            }\n            \n            // Rotate the elements.\n            for (int i = 0; i < n; i++)\n            {\n                nums[(i + k)%n] = numsCopy[i];\n            }\n        }\n```\n\n#### 2、从一个元素开始旋转，直到旋转n个元素\n\ntc：O(n)   sc：O(1)\n\n以数组1、2、3、4、5、6（k=2）为例，\n\n结果是5，6，1，2，3，4\n\n1. 内部do-while做的事情是：把1放在3的位置，把3放在5的位置，把5放在1的位置，回到了起点1，则结束此循环。\n2. 内部循环次数小于数组长度n，则不离开大循环while。起点+1，再次进入内部do-while。\n3. 内部do-while做的事情是：把2放在4的位置，把4放在6的位置，把6放在2的位置，回到了起点2，则结束此循环。\n\n\n\n```\nvoid rotate(int nums[], int n, int k) \n        {\n            if ((n == 0) || (k <= 0))\n            {\n                return;\n            }\n            \n            int cntRotated = 0;\n            int start = 0;\n            int curr = 0;\n            int numToBeRotated = nums[0];\n            int tmp = 0;\n            // 循环直到旋转n个不同的元素\n            while (cntRotated < n)\n            {\n                do\n                {\n                    tmp = nums[(curr + k)%n];\n                    nums[(curr+k)%n] = numToBeRotated;\n                    numToBeRotated = tmp;\n                    curr = (curr + k)%n;\n                    cntRotated++;\n                } while (curr != start);\n                // 回到起点就结束一个循环\n                // 对下一个元素开始循环\n                start++;\n                curr = start;\n                numToBeRotated = nums[curr];\n            }\n        }\n```\n\n#### 3、先置换前n-k个元素，再置换后k个元素，最后整体n个元素置换。\n\ntc：O(n)   sc：O(1)\n\n```\n void rotate(int nums[], int n, int k) \n        {\n            k = k%n;\n    \n            // Reverse the first n - k numbers.\n            // Index i (0 <= i < n - k) becomes n - k - i.\n            reverse(nums, nums + n - k);\n            \n            // Reverse tha last k numbers.\n            // Index n - k + i (0 <= i < k) becomes n - i.\n            reverse(nums + n - k, nums + n);\n            \n            // Reverse all the numbers.\n            // Index i (0 <= i < n - k) becomes n - (n - k - i) = i + k.\n            // Index n - k + i (0 <= i < k) becomes n - (n - i) = i.\n            reverse(nums, nums + n);\n        }\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"26+80 Remove Duplicates from Sorted Array","url":"/2019/02/20/20190220/","content":"\n# 问题26\n\nGiven a sorted array *nums*, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each element appear only *once* and return the new length.\n\n  \n\nDo not allocate extra space for another array, you must do this by **modifying the input array in-place** with O(1) extra memory.\n\n  \n\n**Example 1:**\n\n  \n\n```\nGiven nums = [1,1,2],\n\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\n\nIt doesn't matter what you leave beyond the returned length.\n```\n\n  \n\n**Example 2:**\n\n  \n\n```\nGiven nums = [0,0,1,1,1,2,2,3,3,4],\n\nYour function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.\n\nIt doesn't matter what values are set beyond the returned length.\n```\n\n  \n\n**Clarification:**\n\n  \n\nConfused why the returned value is an integer but your answer is an array?\n\n  \n\nNote that the input array is passed in by **reference**, which means modification to the input array will be known to the caller as well.\n\n  \n\nInternally you can think of this:\n\n  \n\n```\n// nums is passed in by reference. (i.e., without making a copy)\nint len = removeDuplicates(nums);\n\n// any modification to nums in your function would be known by the caller.\n// using the length returned by your function, it prints the first len elements.\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n# c++解\n\n```\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if(nums.size()==0){\n            return 0;\n        }\n        int length=0;\n        for(int i=1 ; i<nums.size() ; i++){\n            if(nums[i]!=nums[i-1]){\n                length++;\n                nums[length]=nums[i];\n                \n            }\n        }\n        return length+1;\n    }\n};\n```\n\n\n\n# 问题80\n\nGiven a sorted array *nums*, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that duplicates appeared at most *twice* and return the new length.\n\n  \n\nDo not allocate extra space for another array, you must do this by **modifying the input array in-place** with O(1) extra memory.\n\n  \n\n**Example 1:**\n\n  \n\n```\nGiven nums = [1,1,1,2,2,3],\n\nYour function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\n\nIt doesn't matter what you leave beyond the returned length.\n```\n\n  \n\n**Example 2:**\n\n  \n\n```\nGiven nums = [0,0,1,1,1,1,2,3,3],\n\nYour function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.\n\nIt doesn't matter what values are set beyond the returned length.\n```\n\n  \n\n**Clarification:**\n\nConfused why the returned value is an integer but your answer is an array?\n\nNote that the input array is passed in by **reference**, which means modification to the input array will be known to the caller as well.  \n\nInternally you can think of this:  \n\n```\n// nums is passed in by reference. (i.e., without making a copy)\nint len = removeDuplicates(nums);\n\n// any modification to nums in your function would be known by the caller.\n// using the length returned by your function, it prints the first len elements.\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n# c++解\n\n```\nint removeDuplicates(vector<int>& nums) {\n        int count=0;\n        for(int i=2 ; i<nums.size() ; i++){\n            if((nums[i]==nums[i-2-count])){\n                count++;\n            }\n            else\n            {\n                nums[i-count]=nums[i];\n            }\n        }\n        return nums.size()-count;\n    }\n```\n\n\n\n# 一个好聪明的解\n\n**C++**\n\n```\nint removeDuplicates(vector<int>& nums) {\n    int i = 0;\n    for (int n : nums)\n        if (i < 2 || n > nums[i-2])\n            nums[i++] = n;\n    return i;\n}\n```\n\n \n\n\n\n**Java**\n\n```\npublic int removeDuplicates(int[] nums) {\n    int i = 0;\n    for (int n : nums)\n        if (i < 2 || n > nums[i-2])\n            nums[i++] = n;\n    return i;\n}\n```\n\n \n\n\n\n**Python**\n\n```\ndef removeDuplicates(self, nums):\n    i = 0\n    for n in nums:\n        if i < 2 or n > nums[i-2]:\n            nums[i] = n\n            i += 1\n    return i\n```\n\n \n\n\n\n**Ruby**\n\n```\ndef remove_duplicates(nums)\n    i = 0\n    nums.each { |n| nums[(i+=1)-1] = n if i < 2 || n > nums[i-2] }\n    i\nend\n```","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Unity Lod 和 Occlusion Culling","url":"/2019/02/18/20190218/","content":"\n# **Lod和Occlusion Culling**\n\n### Lod和遮挡剔除\n\n##### **遮挡剔除**\n\n在我们的场景中，如果物体1在Camera渲染中遮挡了另一个物体2，那物体2就不会再Camera中进行渲染，虽然物体2没有在Camera中进行渲染但是在整个游戏场景中这个物体同样存在。为了优化效率，这里就需要使用遮挡剔除。\n\n**Lod**\n\n如果一个物体离我们的Camera很远，我们自然就看不见这个物体（或者只能看见一个“小点”）。但是这个物体在场景中仍然会根据它的顶点结构进行渲染并消耗性能。这时候为了优化，如果它离我们的Camera距离很远，我们就不需要对它进行渲染，也就是Lod。\n\n### **Occlusion Culling（遮挡剔除）**\n\n![img](https://upload-images.jianshu.io/upload_images/3600976-226b76471d7ae219.gif?imageMogr2/auto-orient/)\n\n遮挡剔除功能在Unity中使用Occlusion Culling（遮挡剔除）组件来进行实现\n\n- 首先我们需要对需要进行遮挡以及被遮挡的物体进行烘焙。\n- 在烘焙的时候，我们需要对遮挡的物体和被遮挡的物体进行选择不同的情况不同的解决方案。（比如一个玻璃物体遮挡住了另一个物体这时我们也应该对玻璃后的物体进行渲染）\n- 这里不考虑这种情况，直接进行烘焙。\n\n### **Lod**\n\n- Lod功能，unity内置的组件也会为我们提供了一套解决方案。（LOD Group组件）\n\n- 首先我们先创建一个小球，可以看见camera已经距离很远，此时只能看见一个小点。但它仍然是场景中进行了渲染。\n\n- 实现LOD优化，为它添加LOD Group组件。\n\n![img](https://upload-images.jianshu.io/upload_images/3600976-372ceaa3e2fd32f9.png?imageMogr2/auto-orient/)\n\n- 其中LOD 0，LOD 1分别为Camera距离这个球的距离区域划分。\n- 我们可以在这些相对距离区域中选择是否要在这个距离对小球渲染。\n\n### 以上方案的缺陷。\n\n- 以上完成的操作都是静态的物体，但是在我们的实际项目开发中，NPC,Monster，建筑物等都是动态生成的。这种情况肯定就无法烘焙成静态的。\n\n### 动态解决方案。（LOD）\n\n- 这时我们使用脚本来控制。而LOD的核心也就是在距离远的时候将小球的MeshRender组件失活我们根据这个核心点去编写代码。\n  - 为我们的Camera添加一个LODAndOcclusionController的脚本。\n  - 完成简单的动态LOD功能。\n\n![img](https://upload-images.jianshu.io/upload_images/3600976-8f16279f0728bbd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/660)\n\n场景测试。 \n\n- 这时我们可以发现当Camera和小球的距离超过5米的时候，小球则不会进行渲染。小球是动态运动的也同样没有关系。\n\n### **动态解决方案。（遮挡剔除）**\n\n- 使用Ray射线来进行判断。\n\n- 我们将所有需要进行遮罩剔除的物体添加Tag为Occlusion。\n- 并为我们的Camera添加脚本。\n\n![img](https://upload-images.jianshu.io/upload_images/3600976-03a28dc50bb5523a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/898)\n\n### **总结：**\n\n我们的LOD以及Occlusion，都是基于GameObject的MeshRender组件来实现的。只有掌握好核心点，不让它们进行渲染，这样减少了Draw Call自然就优化了性能。（主要为什么是让MeshRender组件失活，因为我们直接把整个游戏对象都失活了，那所有的碰撞信息也全部都会失效。）\n\n作者：Levi_Wan\n\n链接：https://www.jianshu.com/p/be81fd0a9380\n\n來源：简书\n\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","tags":["unity"],"categories":["unity"]},{"title":"easy27-Remove Element","url":"/2019/02/17/20190217/","content":"\nleetcode第27题\n<!-- more -->\n\n# 问题\n\nGiven an array *nums* and a value *val*, remove all instances of that value [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) and return the new length.\n\nDo not allocate extra space for another array, you must do this by **modifying the input array in-place** with O(1) extra memory.\n\nThe order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\n**Example 1:**\n\n```\nGiven nums = [3,2,2,3], val = 3,\n\nYour function should return length = 2, with the first two elements of nums being 2.\n\nIt doesn't matter what you leave beyond the returned length.\n```\n\n**Example 2:**\n\n```\nGiven nums = [0,1,2,2,3,0,4,2], val = 2,\n\nYour function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.\n\nNote that the order of those five elements can be arbitrary.\n\nIt doesn't matter what values are set beyond the returned length.\n```\n\n**Clarification:**\n\nConfused why the returned value is an integer but your answer is an array?\n\nNote that the input array is passed in by **reference**, which means modification to the input array will be known to the caller as well.\n\nInternally you can think of this:\n\n```\n// nums is passed in by reference. (i.e., without making a copy)\nint len = removeElement(nums, val);\n\n// any modification to nums in your function would be known by the caller.\n// using the length returned by your function, it prints the first len elements.\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n# c++解\n\n```\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int length=0;\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]!=val){\n                nums[length]=nums[i];\n                length++;\n            }\n        }\n        return length;\n    }\n};\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"多个链表合并","url":"/2019/02/01/20190201/","content":"\n要用到 简单合并两个有序链表\n\n<!-- more -->\n\n# 问题\n\nMerge *k* sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n\n**Example:**\n\n```\nInput:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nOutput: 1->1->2->3->4->4->5->6\n```\n\n# 解\n\n很简单先合并前两个成为一个链表，再合并这个新链表和下一个链表，一直用到的都是合并两个的代码：\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.empty()){\n        return nullptr;\n    }\n    while(lists.size() > 1){\n        lists.push_back(mergeTwoLists(lists[0], lists[1]));\n        lists.erase(lists.begin());\n        lists.erase(lists.begin());\n    }\n    return lists.front();\n    }\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode head(-1);\n        ListNode* l3 = &head;\n        while(l1 && l2){\n            if(l1->val <= l2->val){\n                l3->next = l1;\n                l1 = l1->next;\n            }else{\n                l3->next = l2;\n                l2 = l2->next;\n            }\n            l3 = l3->next;\n        }\n        l3->next = l1? l1:l2;\n        return head.next;\n    }\n    \n```\n\n","tags":["leetcode","list"],"categories":["leetcode"]},{"title":"生成括号对","url":"/2019/01/31/20190131/","content":"\n1月的最后一天啦，放假太颓废了真的，很快又要开学了呜呜呜\n\n<!-- more -->\n\n# 问题\n\nGiven *n* pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\nFor example, given *n* = 3, a solution set is:\n\n```\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n```\n\n给出所有正确的括号组合。\n\n# 解\n\n先不考虑代码，用笔算的话要怎么解决这个问题？\n\nN=3的话就会进行如下思考：\n\n1、（\n\n2、（）or （（\n\n3、【（）（ 】or 【（（） or （（（】\n\n4、【（）（（or （）（）】or【（（））or（（）（】or【（（（）】\n\n可以总结一下规律：\n\n- 第一步先写（，下一步可能是（ 或者 ）\n- 当前左括号数>右括号数时，下一步才可以写 ）\n- 当左括号数==n时，不可再写（；右括号数==n时，结束。\n\n这种每一步都是相同的操作，即+（  或者  +）操作的题目，可以考虑使用递归的方法来解决。\n\n# C++代码\n\n```\nclass Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<string> res;\n        getparen(res,\"\",n,0,0);\n        return res;\n    }\n    void getparen(vector<string> &res,string str,int n,int left,int right){\n        if(left==n && right==n){\n            res.push_back(str);\n            return;\n        }\n        if(left<n){\n            getparen(res,str+\"(\",n,left+1,right);\n        }\n        if(right<left){\n            getparen(res,str+\")\",n,left,right+1);\n        }\n    }\n};\n```\n\n# python3代码\n\n```\nclass Solution:\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        def generate(p, left, right, n, parens=[]):\n            if left < n:         \n                generate(p + '(', left+1, right, n)\n            if right < left: \n                generate(p + ')', left, right+1, n)\n            if left==n and right==n:    \n                parens += p,\n            return parens\n        return generate('', 0 , 0 , n )\n\n```\n\n","tags":["leetcode"],"categories":["leetcode"]},{"title":"HOLOLENS入门之MRinput","url":"/2019/01/29/2019012901/","content":"\n大半年没看了，hololens 加了不少东西呢😄\n\n<!-- more -->\n\n# 环境\n\nhttps://docs.microsoft.com/en-us/windows/mixed-reality/install-the-tools\n\n该网址都讲了↑\n\n1、windows 10\n\n2、visual studio 2017\n\n3、windows 10 sdk\n\n4、Unity long term support（LTS）version：官网建议安装unity的LTS stream版本（17年的时候还没有这样说呢...)，但是我根据推荐安装了新的LTS版unity工具包还不支持，到底版本怎么对应的啊喂！\n\n5、MRTK for unity：工具包的版本和unity的版本一定要对应上，对上了开发就是so easy，对不上就是几百个报错贼闹心。\n\n我这次尝试的：\n\nUnity2017.4.19f1\n\nHoloToolkit-2017.4.3.0\n\nHoloToolkit-Examples-2017.4.3.0\n\n\n\nMRTK里面的封装内容博大精深，要是全都能整明白开发MR应用都不是什么难题了。\n\n# Unity设置\n\n- **Edit > Project Settings > Player > Windows Store > XR Settings  ** 在 Virtual Reality Supported 中添加 Virtual Reality SDKs ；把Other Settings 中的 Scripting Backend 设置为 .NET\n- **Edit > Project Settings > Quality**.选择windows store图标下的default小箭头，选择 Fastest\n- **导出**：在unity的导出界面里---->选择**Universal Windows Platform**；**Target device**设为 **HoloLens**. ； **Build Type **设置为D3D ；**SDK** 设置为 **Latest installed** （至少为 SDK 16299)\n\n# MR Input\n\n在众多官方教程里，最基础的教程为MR input：210、211、212、213\n\n## 210：Gaze\n\n","tags":["hololens"],"categories":["hololens"]},{"title":"简单合并两个有序链表","url":"/2019/01/28/2019012801/","content":"\n# 问题\n\nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n\n**Example:**\n\n```\nInput: 1->2->4, 1->3->4\nOutput: 1->1->2->3->4->4\n```\n\n# 解\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode head(-1);\n        ListNode* l3 = &head;\n        while(l1 && l2){\n            if(l1->val <= l2->val){\n                l3->next = l1;\n                l1 = l1->next;\n            }else{\n                l3->next = l2;\n                l2 = l2->next;\n            }\n            l3 = l3->next;\n        }\n        l3->next = l1? l1:l2;\n        return head.next;\n    }\n};\n```\n\n","tags":["leetcode","list"],"categories":["leetcode"]},{"title":"移除链表中的倒数第n个结点","url":"/2019/01/27/2019012701/","content":"\nleetcode第19题\n<!-- more -->\n\n# 问题\n\nGiven a linked list, remove the *n*-th node from the end of list and return its head.\n\n**Example:**\n\n```\nGiven linked list: 1->2->3->4->5, and n = 2.\n\nAfter removing the second node from the end, the linked list becomes 1->2->3->5.\n```\n\n**Note:**\n\nGiven *n* will always be valid.\n\n**Follow up:**\n\nCould you do this in one pass?\n\n# 解\n\n要求删除倒数第n个链表节点，难点在于获取“倒数第n个”，可以用两个指针，slow和fast相隔n个节点，当fast走到链表的末尾，则距离fast有n个距离的slow正好指向要删除的那“倒数第n个”。\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *removeNthFromEnd(ListNode *head, int n) \n   {\n        if (!head)\n            return nullptr;\n        ListNode new_head(-1);\n        new_head.next = head;\n       \n        ListNode *slow = &new_head, *fast = &new_head;\n        \n        \n        for (int i = 0; i < n; i++)\n            fast = fast->next;\n\n        while (fast->next) \n        {\n            fast = fast->next;\n            slow = slow->next;\n        }\n\n        ListNode *to_be_deleted = slow->next;\n        delete to_be_deleted;\n        slow->next = slow->next->next;\n    \n        \n\n        return new_head.next;\n     }\n};\n\nPYTHON：\nclass Solution:\n    def removeNthFromEnd(self, head, n):\n        fast = slow = head\n        for _ in range(n):\n            fast = fast.next\n        if not fast:\n            return head.next\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        slow.next = slow.next.next\n        return head\n```\n\n\n\n","tags":["list"],"categories":["leetcode"]},{"title":"3Sum","url":"/2019/01/24/20190124/","content":"\nleetcode第15题\n<!-- more -->\n\n# 问题\n\nGiven an array `nums` of *n* integers, are there elements *a*, *b*, *c* in `nums` such that *a*+ *b* + *c* = 0? Find all unique triplets in the array which gives the sum of zero.\n\n**Note:**\n\nThe solution set must not contain duplicate triplets.\n\n例子\n\n```\nGiven array nums = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n```\n\n# 解答\n\n比第18题简单一些，原理差不多\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int>> results;\n        sort(nums.begin(),nums.end());\n        int n=nums.size();\n       // if(n)\n        for(int i=0;i<n-2;i++){\n            while(i>0&&nums[i]==nums[i-1]){\n                i++;\n            }\n            int left=i+1,right=n-1;\n            while(left<right){\n                int sum2 = nums[left]+nums[right];\n                if(sum2<0-nums[i]){\n                    left++;\n                }\n                else if(sum2>0-nums[i]){\n                    right--;\n                }\n                else{\n                    results.push_back( vector<int>{nums[i],nums[left],nums[right]} );\n                    do{ left++; }while( nums[left]==nums[left-1] && left<right );\n                    do{ right--; }while( nums[right]==nums[right+1] && left<right );\n                }\n            }    \n        }\n        return results;\n    }\n};\n```\n\n","tags":["leetcode"],"categories":["leetcode"]},{"title":"有效的括号","url":"/2019/01/23/20190123/","content":"\nleetcode第20题\n<!-- more -->\n\n# 问题\n\nGiven a string containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n\nNote that an empty string is also considered valid.\n\n例子\n\n```\nInput: \"()\"\nOutput: true\nInput: \"()[]{}\"\nOutput: true\nInput: \"(]\"\nOutput: false\n\n```\n\n# 解\n\nc++解法：\n\n```\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> character;\n        for(int i=0;i<s.size();i++){\n            char c=s[i];\n            switch(c){\n                case '(': character.push(c); break;\n                case '{': character.push(c); break;\n                case '[': character.push(c); break;\n                case ')': \n                    if (character.empty() || character.top()!='(')\n                        return false;\n                    else character.pop();\n                    break;\n                case '}': \n                    if (character.empty() || character.top()!='{') \n                        return false; \n                    else character.pop(); \n                    break;\n                case ']': \n                    if (character.empty() || character.top()!='[') \n                        return false;\n                    else character.pop(); \n                    break;\n                default: ; // pass \n            }\n        }\n        return character.empty();\n    }\n};\n\n```\n\npython3\n\n```\nclass Solution:\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        stack = []\n        dicts = {\"]\":\"[\", \"}\":\"{\", \")\":\"(\"}\n        for charr in s:\n            if charr in dicts.values():\n                stack.append(charr);\n            elif charr in dicts.keys():\n                if stack==[] or dicts[charr]!=stack.pop():\n                    return False\n            else:\n                return False\n        return stack==[]\n```\n\n","tags":["leetcode"],"categories":["leetcode"]},{"title":"四个数字相加等于指定数","url":"/2019/01/22/2019012201/","content":"\nleetcode第18题\n<!-- more -->\n\n\n\n# 问题\n\nGiven an array `nums` of *n* integers and an integer `target`, are there elements *a*, *b*, *c*, and *d* in `nums` such that *a* + *b* + *c* + *d*= `target`? Find all unique quadruplets in the array which gives the sum of `target`.\n\n**Note:**\n\nThe solution set must not contain duplicate quadruplets.\n\n#### 例子\n\n```\nGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0.\n#就是看这里面哪四个数相加能等于0\nA solution set is:\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n```\n\n# 解\n\n【python】\n\n采用嵌套的方式比较好解这个题\n\n设要求nums数集里N个数的和，满足target\n\n```\n先把nums的数排序，然后调用函数findsum：\n1、检查是否为空解，以下条件满足则return：\n      nums长度<N||\n      target<nums最小值 * N||\n      target>nums最大值 * N\n   \n2、\nif N>2\n  i 从第一个到倒数第三个：\n    如果第i个和第i-1个相同，则跳过去，避免重复\n    findsum（nums[i+1:],target-nums[i],result+nums[i],results）\n    (result是每一个条目，组成了结果results)\n    \n    \n3、\nif N==2\n   l=0,r=nums[-1]\n   while l<r:\n       如果找到了一对数 nums[l]+nums[r]==target\n           则加入results：results.append(result+[nums[l]+nums[r]])\n           左侧游标移动一位l=l+1\n           把重复的跳过去\n       如果 和小于目标，则左侧游标往右边移动\n       如果 和大于目标，则右侧游标往左侧移动\n           \n```\n\n\n\n```\ndef fourSum(self, nums, target):\n    def findNsum(nums, target, N, result, results):\n        if len(nums) < N or N < 2 or target < nums[0]*N or target > nums[-1]*N:  # early termination\n            return\n        if N == 2: # two pointers solve sorted 2-sum problem\n            l,r = 0,len(nums)-1\n            while l < r:\n                s = nums[l] + nums[r]\n                if s == target:\n                    results.append(result + [nums[l], nums[r]])\n                    l += 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                elif s < target:\n                    l += 1\n                else:\n                    r -= 1\n        else: # recursively reduce N\n            for i in range(len(nums)-N+1):\n                if i == 0 or (i > 0 and nums[i-1] != nums[i]):\n                    findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\n\n    results = []\n    findNsum(sorted(nums), target, 4, [], results)\n    return results\n```\n\n【c++】\n\n不使用嵌套的话，也是一样的意思，给nums排序，先固定第一个数，再固定第二个数，找后两个数的和满足target-nums[i]-nums[j]的组合，再依次换第二个数第一个数。\n\n```\n第一个数i从0到倒数第四个：\n    if（第i个=第i-1个）重复了，本轮跳过去\n    if（前四个数和>目标）结束，没找到符合的数\n    if（第i个+倒数3个数<目标）第i个数太小，本轮跳过去\n    第二个数j从i+1到倒数第三个：\n        if（第j个=第j-1个）重复了跳过去\n        if（第一个数i+j范围内的前三个数>目标）数太大，结束\n        if（第一个数i+j范围内最后三个数<目标）数太小，本轮跳过去\n        设定left=j+1，right=n-1最后两个数从头和尾开始遍历\n        while（left<right）\n            sum=[left]+[right]+[i]+[j]\n            if （sum<目标） 和小了要增大值 left++\n            if （sum>目标） 和大了要减小值 right--\n            else\n                说明sum=目标，\n                把{[i],[j],[left],[right]}加入结果\n                如果左右两个值重复了则跳过去\n return\n                \n            \n```\n\n\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        vector<vector<int>> total;\n        int n = nums.size();\n        if(n<4)  return total;\n        sort(nums.begin(),nums.end());\n        for(int i=0;i<n-3;i++)\n        {\n            if(i>0&&nums[i]==nums[i-1]) continue;\n            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;\n            if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target) continue;\n            for(int j=i+1;j<n-2;j++)\n            {\n                if(j>i+1&&nums[j]==nums[j-1]) continue;\n                if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;\n                if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;\n                int left=j+1,right=n-1;\n                while(left<right){\n                    int sum=nums[left]+nums[right]+nums[i]+nums[j];\n                    if(sum<target) left++;\n                    else if(sum>target) right--;\n                    else{\n                        total.push_back(vector<int>{nums[i],nums[j],nums[left],nums[right]});\n                        do{left++;}while(nums[left]==nums[left-1]&&left<right);\n                        do{right--;}while(nums[right]==nums[right+1]&&left<right);\n                    }\n                }\n            }\n        }\n        return total;\n    }\n};\n```\n\n","categories":["leetcode"]},{"title":"Letter Combinations of a Phone Number","url":"/2019/01/21/2019012101/","content":"\nleetcode第17题\n<!-- more -->\n\n# 问题\n\nGiven a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n给定包含“2-9”数字的字符串，返回该数字可能表示的所有字母组合。\n\n下面给出一个数字到字母的映射(就像电话按钮一样)。注意1不映射到任何字母。\n\n![img](https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png)\n\n例子\n\n```\nInput: \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n```\n\n# 解\n\n```\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        string m[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        vector<string> res;\n        if(digits==\"\"){\n            return res;\n        }\n        res.push_back(\"\");\n        for(int n=0;n<digits.size();n++){\n            int num=digits[n]-'0';\n            if(num<0||num>9){\n                break;\n            }\n            string x=m[num];\n            vector<string> nres;\n            \n            for(int j=0;j<res.size();j++){\n                for(int i=0;i<x.size();i++){\n                    nres.push_back(res[j]+x[i]);\n                }\n            }\n            res.swap(nres);\n        }\n        return res;\n    }\n};\n```\n\n","categories":["leetcode"]},{"title":"C++STL之哈希表||unordered_map","url":"/2019/01/20/20190120/","content":"\nC++ STL中，哈希表对应的容器是 `unordered_map`（since C++ 11）。根据 C++ 11 标准的推荐，用 `unordered_map` 代替 `hash_map`。\n\n<!-- more -->\n\n## 哈希表\n\n先来回顾一下数据结构中哈希表相关的知识。\n\n哈希表是根据关键码值(key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数。\n\n哈希表的一个重要问题就是如何解决映射冲突的问题。常用的有两种：**开放地址法** 和 **链地址法**。\n\nSTL中，`map` 对应的数据结构是 **红黑树**。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 **O(logN)**。而 `unordered_map` 对应 **哈希表**，哈希表的特点就是查找效率高，时间复杂度为常数级别 **O(1)**， 而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 `unordered_map` 容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 `map` 容器。\n\n## 说明\n\n- unordered_map 是一种关联容器，用于存储由关键值 (Key Value，以下称为Key 值) 和映射值 (Mapped Value，以下称为映射值) 组成的元素，并且允许根据其 Key 值快速检索各个元素。 \n\n- 在 unordered_map 容器中，Key 值通常用来唯一标识元素，映射值是与该 Key 值关联内容的对象。Key 值与映射值的类型可能不同。 \n\n- 在 unordered_map 内部，元素没有按照其 Key 值与映射值的任何顺序进行排序 ，而是根据它们的 Hash 值组织成桶，允许它们通过其 Key 值直接快速访问单个元素（通常具有常数等级的平均时间复杂度）。 \n\n- unordered_map 容器与 map 容器相比，通过 Key 值访问各个元素的速度更快，然而通过其元素子集进行范围迭代的效率通常较低。 \n\n- unordered_map 实现了直接访问操作符 (operator[])，它允许使用 Key 值作为输入参数，直接访问映射值。 \n\n- 容器中的迭代器至少是前向迭代器。\n\n  ## 容器属性\n\n  **关联性** \n  关联容器中的元素的参考地址指的是其 Key 值，而不是他们在容器中的绝对地址；\n  **无序性** \n  无序容器使用 Hash 表来组织元素，这些 Hash 表允许无序容器通过 Key 值快速访问元素；\n  **映射** \n  每个元素将一个 Key 值与映射值关联起来，Key 值用于标识其主要内容是映射值的元素；\n  **唯一关键值** \n  容器中不存在同时拥有相同 Key 值的两个元素；\n  **分配器感知** \n\n  map 容器使用分配器对象动态处理其存储需求。\n\n## 常用函数\n\n#### bucket\n\nsize_type bucket ( const key_type& k ) const;\n\n定位元素所在的桶，返回 Key 值为输入参数 k 的元素的所在桶号。 \n桶是容器内部 Hash 表中的一个槽，槽中的元素根据 Key 值分配元素。桶号的编号从 0 到 (bucket_count - 1)。 桶中单个元素可以通过 unordered_map::begin 和 unordered_map::end 返回的范围迭代器进行访问。\n\n#### count\n\nsize_type count ( const key_type& k ) const;\n\n搜索容器中 Key 值为输入参数 k 的元素，并返回找到元素的数量。由于 unordered_map 容器不允许存在重复的 Key 值，这说明如果容器中存在具有该 Key 值的元素，则该函数返回 1，否则返回 0。\n\n#### clear\n\n 清除 map 中所有元素；\n\n#### erase\n\n 删除 map 中指定位置的元素；\n\n#### insert\n\n 在 map 指定位置添加 pair 类型的元素；\n\n#### find\n\n 获取 map 中元素的迭代器；\n\n#### begin, end\n\n map 的正向迭代器的起始位置与终点位置\n\n## 例题\n\n摘选自[ Leetcode 问题 Two Sum](https://leetcode.com/problems/two-sum/description/)：给出一个整数数组，返回两个数的下标值，令其和等于一个指定的目标值。\n\n例子\n\n```\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n```\n\n解\n\n```\n#include <unordered_map>\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int> &numbers, int target)\n    {\n        //Key is the number and value is its index in the vector.\n        unordered_map<int, int> hash;\n        vector<int> result;\n        for (int i = 0; i < numbers.size(); i++) {\n            int numberToFind = target - numbers[i];\n\n            //if numberToFind is found in map, return them\n            if (hash.find(numberToFind) != hash.end()) {\n                result.push_back(hash[numberToFind]);\n                result.push_back(i);            \n                return result;\n            }\n\n            //number was not found. Put it in the map.\n            hash[numbers[i]] = i;\n        }\n        return result;\n    }\n};\n```\n\n","tags":["c++"],"categories":["c++"]},{"title":"Integer to Roman and roman to integer","url":"/2019/01/19/2019011901/","content":"\nleetcode第12题和13题\n<!-- more -->\n\n# 问题1\n\n罗马数字由七种不同的符号表示:I、V、X、L、C、D和M。\n\n```\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\n例如，2在罗马数字中写成II，只是两个1相加。12写成，XII，也就是X + II。数字27写成XXVII，也就是XX + V + II。\n\n罗马数字通常从左到右从大到小。然而，4的数字不是IIII。相反，数字4写成IV，因为1在5之前我们减去它得到4。同样的原理也适用于数字9，即写为IX。使用减法的情况有六种:\n\n- I可以放在V(5)和X(10)之前得到4和9。\n\n- X可以放在L(50)和C(100)之前，得到40和90。\n\n- C可以放在D(500)和M(1000)之前，得到400和900。\n\n  \n\n  给定一个整数，将其转换为罗马数字。输入保证在1到3999之间。\n\n  ```\n  Input: 3\n  Output: \"III\"\n  \n  Input: 4\n  Output: \"IV\"\n  \n  Input: 9\n  Output: \"IX\"\n  \n  Input: 58\n  Output: \"LVIII\"\n  Explanation: L = 50, V = 5, III = 3.\n  ```\n\n  # 极其机智的解答\n\n  依次把个位十位百位千位挑出来\n\n```\npublic static String intToRoman(int num) {\n    String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\n    String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n    String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n    String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];\n}\n```\n\n# 问题2\n\n把上一题反过来\n\n# 解答\n\n通过从后到前处理字符串并使用映射，问题更容易解决。运行速度为88毫秒。\n\n*string*::front –访问第一个字符; \n\n*string*::*back* –访问最后一个字符;\n\n *string*::data –访问基础数组\n\n```\nint romanToInt(string s) \n{\n    unordered_map<char, int> T = { { 'I' , 1 },\n                                   { 'V' , 5 },\n                                   { 'X' , 10 },\n                                   { 'L' , 50 },\n                                   { 'C' , 100 },\n                                   { 'D' , 500 },\n                                   { 'M' , 1000 } };\n                                   \n   int sum = T[s.back()];\n   for (int i = s.length() - 2; i >= 0; --i) \n   {\n       if (T[s[i]] < T[s[i + 1]])\n       {\n           sum -= T[s[i]];\n       }\n       else\n       {\n           sum += T[s[i]];\n       }\n   }\n   \n   return sum;\n}\n```\n\n","categories":["leetcode"]},{"title":"分层强化学习","url":"/2019/01/18/2019011801/","content":"\n[TOC]\n\n\n\n# 1为什么会出现分层强化学习\n\n​        强化学习要研究的问题是智能体（agents）如何在一个环境（environment）中学到一定的策略（policy），使得长期的奖赏（reward）最大。 但是传统的强化学习方法面临着维度灾难，即当环境较为复杂或者任务较为困难时，agent的状态（state）空间过 大，会导致需要学习的参数以及所需的存储空间急速增长，强化学习难以取得理想的效果。 为了解决维度灾难，研究者提出了分层强化学习（hierarchical reinforcement learning，HRL）。HRL 的主要目标是将复杂的问题分解成多个小问题，分别解决小问题从而达到解决原问题的目的。 近些年来，人们认为分层强化学习基本可以解决强化学习的维度灾难问题，转而将研究方向转向如何将复杂的问题抽象成不同的层级，从而更好地解决这些问题。 \n\n# 2背景知识\n\n​        本部分主要介绍强化学习、马尔可夫决策过程mdp和半马尔可夫决策过程semi-mdp的相关内容和背景知识。\n\n## 2.1RL与MDP\n\n​        强化学习主要研究的问题是agent通过和environment直接交互的过程来学习策略，使得达到目标后的总体奖励最大。大多数关于强化学习RL的研究都建立在马尔可夫决策过程MDP上。\n\n#### 2.1.1马尔可夫决策过程的定义\n\n​        MDP可以表示为一个五元组〈Ｓ，Ａ，Ｐ，Ｒ，γ〉。 其中，Ｓ为环境状态state的有限集合，集合中某个状态表示为s∈S；A为动作 action的有限集合，集合中某个动作表示为 a∈A，A 为状态s下可执行的动作集合；P状态转移方程，P(s′|s,a) 表示在状态s执行动作a后将以 P的概率跳转到状态 s′；R为奖赏函数；γ 为折损系数， ０≤γ≤１。 \n\n​        假设一个agent观察到自己的状态s，此时它选择一个动作a，它会得到一个即时的奖赏ｒ=R(s,a)，然后以 P(s′ |s,a) 的概率达到下一个状态s′。 马尔可夫决策过程有马尔可夫性，即系统的下个状态只与当前状态有关，与之前的状态无关。 当马尔可夫决策过程中作出决策时，只需要考虑当前的状态，而不需要历史数据，这样大大降低了问题的复杂度。 \n\n{% asset_img 131433102201.jpg This is an example image %}\n\n![01](2019011801\\131433102201.jpg)\n\n#### 2.1.2值函数\n\n​        强化学习需要agent学习到一个策略 π，通过 π (s,a) 的值来指导agent进行动作的选择。衡量这个策略的标准依赖于回报，增强学习往往具有延迟回报的特点 : 如果在第n步输掉了棋，那么只有状态sn和动作an获得了立即回报r(sn,an)=-1，前面的所有状态立即回报均为0。所以对于之前的任意状态s和动作a，立即回报函数r(s,a)无法说明策略的好坏。因而需要定义值函数 (value function，又叫效用函数) 来表明当前状态下策略π的长期影响。 \n\n​        令Ｖ(ｓ) 表示在状态s的**值函数**，即从状态s开始一直按照某个策略执行最终达到终止状态的期望累计奖赏。我们的目标是希望学到一个最优的策略 π，最大化每一个状态下的Ｖ值。\n\n![02](2019011801\\02.png)\n\n是值函数最常见的形式，式中γ∈[0,1]称为折合因子，表明了未来的回报相对于当前回报的重要程度。特别的，γ=0时，相当于只考虑立即不考虑长期回报，γ=1时，将长期回报和立即回报看得同等重要。接下来把这个值函数展开，其中ri表示未来第i步回报，s'表示下一步状态，则有：\n\n![03](2019011801\\03.png)\n\n给定策略π和初始状态s，则动作a=π(s)，下个时刻将以概率p(s'|s,a)转向下个状态s'，那么上式的期望可以拆开，可以重写为：\n\n![04](2019011801\\04.png)\n\nπ和初始状态s是我们给定的，而初始动作a是由策略π和状态s决定的，即a=π(s)。\n\n#### 2.1.3动作值函数\n\n​        除了值函数，期望累计奖赏也可以用**动作-值函数**来表示，令 Ｑ(s,a)  在状态s执行动作a之后按照某个策略执行直到达到终止状态的期望累计奖赏。我们也希望通过学习到一个最优的Ｑ函数，使agent可以直接通过Ｑ函数来选择当前状态下应该执行的动作。定义动作值函数(action value functionQ函数)如下：\n\n![05](2019011801\\05.png)\n\n给定当前状态s和当前动作a，在未来遵循策略π，那么系统将以概率p(s'|s,a)转向下个状态s'，上式可以重写为：\n\n![06](2019011801\\06.png)\n\n在Qπ(s,a)中，不仅策略π和初始状态s是我们给定的，当前的动作a也是我们给定的，这是Qπ(s,a)和Vπ(a)的主要区别。\n\n​        知道值函数的概念后，一个MDP的最优策略可以由下式表示：\n\n![07](2019011801\\07.png)\n\n即我们寻找的是在任意初始条件s下，能够最大化值函数的策略π*。\n\n​        经过多年的研究，已经出现一些算法，致力于解决传统的强化学习问题，比如Ｑ⁃learning、蒙特卡洛方法（Monte-Carlo learning）、时 序 差 分方法（temporal-difference learning）等。其中 Ｑ⁃learning 方法常常在分层强化学习中被使用。Ｑ⁃learning通 过不断迭代更新Ｑ函数的值来逼近最优的Ｑ∗。\n\n#### 2.1.4Ｑ⁃learning\n\n[ql]: http://zhangmeng.ga/2019/01/17/20190116001/\t\"ql\"\n\n\n\n## 2.2 SMDP\n\n​        青蛙在荷叶上跳动，在每个不同的荷叶上表示不同的状态，从一个荷叶跳到另一个荷叶表示状态的转移，该转移过程只依赖于现在所处荷叶，而与以前呆过的荷叶无关，如果只考虑青蛙跳跃的时刻序列，这个过程就是离散时间的马氏过程，如果考虑青蛙在荷叶上呆了一段时间，且这段时间是服从指数分布的，那这个过程是连续时间马氏过程，如果时间是非指数分布的，那这个过程是半马氏分布。\n\n​        马尔可夫决策过程中，选择一个动作后，agent 会立刻根据状态转移方程P跳转到下一个状态，而在半马尔可夫决策过程SMDP中，当前状态到下 一个状态的步数是个随机变量 τ，即在某个状态s下选择一个动作a，经过 τ 步才会以一个概率转移到下一个状态s′。 此时的状态转移概率是s 和 τ 的联合概率P（s′,τ |s,a）。 根据 τ 的定义域不同，SMDP所定义的系统也有所不同。 当 τ 的取值为实数值，则SMDP构建了一个连续时间-离散事件系统；而当 τ 的取值为正整 数，则是一个离散时间SMDP。 出于简单考虑，绝大部分分层强化学习都是在离散时间SMDP上进行讨论。 \n\n# 3分层强化学习\n\n​        分层强化学习是将复杂的强化学习问题分解成一些容易解决的子问题，通过分别解决这些子问题，最终解决原本的强化学习问题。 常见的分层强化学习方法可以大致分为四种，分别为基于选项的强化学习、基于分层抽象机 的分层强化学习、基于 MaxQ函数分解的分层强化学习，以及端到端的分层强化学习。本节将对它们逐一进行探讨。 \n\n​        对于HRL，抽象是至关重要的。通过抽象可去掉子任务中一些冗余或无关的信息，简化问题的表示，更容易、更方便地解决问题。在HRL中，抽象包括时间抽象 (动作抽象) 和空间抽象 (状态抽象) 。\n\n​        时间抽象是一种将若干动作封装在一起， 被视为单个抽象动作，其主要目的在于充分利用问题的分层结构。每个抽象动作对应一个定义在环境状态子集上、具有终止条件的闭环局部策略，研究者有时称这些策略为抉择(options)、时间扩展的动作(temporally-extended actions)。抽象动作允许 agent 按照其局部策略用多个时间步调用所封装的底层动作，直到终止。【个人理解：其实就是把几个小动作封装成一个整体，在状态s下通过全局策略的决定进入这个大的整体之后，按照这个整体内部自己的局部策略执行小动作，在达到终止条件的时候结束这个整体动作，达到一个宏观上的新状态，再通过全局策略选择下一个整体动作进入。】\n\n​        空间抽象可分为两种情况，一种是将若干状态封装在一起，被视为单个抽象状态；另一种是针对环境状态可用矢量表示，即状态可分解的情形，删掉与子任务无关的状态变量，从而达到简化状态表示的目的。\n\n### 3.1基于选项的分层强化学习\n\n​        基于option的分层强化学习的过程如下：假设 agent 当前在某个状态，选择一个option，通过这个 option的策略，agent 选择了一个动作或者另一个 option。 若选择了一个动作，则直接执行转移到下一 个状态；若选择了另一个 option，则用选择的新 option继续选择，直到最后得出一个动作。\n\n​        最简单的option为直接定义在MDP上的马尔可夫option，是一个三元组 < I , Π , T> 。其中：l∈S是option入口状态集合； Π：s×A[0，1]为option内部策略；T：S [ 0，1 ]为option终止条件，也就是出口。当option被激活后，agent根据 Π 选择执行的动作，最后根据 T 随机终止。对于任意动作a∈A可看成是单步opfion。\n\n​        另一种比较灵活的option是半马尔可夫option，其内部策略和终止条件均依赖于option激活后所经历的状态、动作和回报等历史。令Ω表示历史集，形式上半马尔可夫option也是一 个三元组< I , Π , T>。I 的含义与马尔可夫option的 I 相同，但内部策略和终止条件分别定义为 Π ：ΩXA→[0，1]和T：Ω→ [0，1]。 \n\n​         令O为option集合。如果将策略定义在options之上，即定义为 μ ：s×O→[0，1]，则形成options分层机制。在这种机制下，agent根据 μ 选择一个option执行，直到终止，agent再依照 μ 选择另一个option执行，依此类推。如果将O叠加到 MDP上，将产生一个离散时间SMDP，因而可使用SMDP所有的理论和算法。\n\n​        把MDP单步模型里的action替换成options并去掉折合因子，就可以得到最优值函数和最优option值函数：\n\n![08](2019011801\\08.png)\n\n​        此时的Q-Learning的更新公式为：\n\n![09](2019011801\\09.png)\n\n其中，ak为第k轮迭代时的学习率，τ 表示option  o 在执行 τ 步之后在状态 St+τ 停止，而 ｏ′ 为在 ｏ 执行 结束后的下一个option。 可以注意到，**当所有的option均为one⁃step option时，这个Ｑ⁃learning就退 化为普通的Ｑ⁃learning过程。** \n\n### 3.2基于分层抽象机的分层强化学习\n\n​        分层抽象机（hierarchies of abstract machines,HAMs）是Parr和Russell提出的方法。和option的方法类似，HAMs的方法也是建立在SMDP 的理论基础之上的。 HAMs的主要思想是将当前所在状态以及有限状态机的状态结合考虑，从而选择不同的策略。 \n\n​        令M为一个有限MDP，{Hi}为一个有限状态机集合，每个有限状态机都有一个状态集合Si、一个概率转移方程以及一个随机函数fi。状态集合包括：action、call、choice、stop。\n\n- action类型的状态会根据状态机的具体状态执行一个MDP中的动作。\n\n- call类型的状态时，当前状态机被挂起，根据该状态机的当前状态得到下一个状态机，对其用随机函数初始化（得到状态）。\n\n- choice类型的状态时，不确定地选择当前状态机地下一个状态。\n\n- stop类型的状态时，停止当前状态机的活动，恢复调用它的状态机的活动，同时agent根据之前的动作进行动作转移并得到奖励。（如果某个状态机H刚被调用就被随机函数初始化到了stop状态，返回的时候没有选出来要执行的动作，则M保持当前的状态。）\n\n  ![10](2019011801\\10.png)\n\n  \n\n  ​         总之，options和HAM都是把MDP转换为了单个SMDP问题，而MAXQ和HEXQ方法创建了多个SMDP的分层，使得每个SMDP同时学习。\n\n  ### 3.3基于 MaxQ函数分解的分层强化学习\n\n  ​        MaxQ 值分解是由Dietterich提出的另外一种分层强化学习的方法。首先把一个马尔可夫决策过程M分解成多个子任务{M0，M1,...,Mn}, M0为根子任务，解决了它就意味着解决了原问题M。每一个子任务都有一个终止断言T和一个动作集合A。A中的元素可以是其他的子任务也可以是一个MDP中的action。子任务的目标是转移到一个状态可以满足终止断言使得子任务完成并终止。\n\n  图１为利用MaxQ方法解决出租车问题的任务划分示意图：\n\n  ![11](2019011801\\11.png)\n\n  ​        出租车问题是指一个出租车agent需要到特定位置接一位乘客并且把他送到特定的位置让其下车。 一共有6个动作，分别是上车（pickup）、下车 (dropoff），以及向东南西北四个方向开车的动作。 这里使用MaxQ方法，将原问题分解成了get和put两个子任务，这两个子任务又进行分解，get分解成一个基本动作pickup和一个子任务navigate，而put也分解成了一个基本动作dropoff和一个子任务navigate。 子任务navigate(t)表示t时刻应该开车的方向。 对于这个强化学习问题，agent首先选择get， 然后get子问题navigate，直到到达乘客所在地，然后get选择pickup动作，乘客上车。 之后agent选择put子任务，put子任务选择navigate，直到到达乘客目的地，之后put子任务选择dropoff动作，乘客下车，任务完成。 \n\n  ### 3.4端到端的分层强化学习\n\n  ​         上述3种方法，都需要人工来做很多工作， 比如人工进行option的选取，人工进行HAMs的构 建，人工划分子任务等。 人工设计不仅耗时耗力， 并且会直接影响最终强化学习结果的好坏。 近些年来人们关注如何让agent自己学到合理的分层抽象，而非人为进行划分和指定。\n\n  。。。。。。\n\n  ## 4对比\n\n  ![12](2019011801\\12.png)\n\n分层最优指的是：该策略是与分层结构兼容的所有分层策略中具有最高累计回报的策略。\n\n递归最优指的是：一个分层策略使得对于每个子任务，对应的策略都是最优的。\n\n分层最优策略和递归最优策略的根本区别在于，前者的子任务不仅要考虑所调用的下级子任务，也要考虑如何加入到上级子任务中；而后者的子任务没有考虑其应用环境。\n\n安全状态抽象是指值函数在抽象前后保持一致的状态抽象。","tags":["reinforcement learning"],"categories":["reinforcement learning"]},{"title":"Container With Most Water","url":"/2019/01/17/2019011702/","content":"\n# 问题\n\nGiven *n* non-negative integers *a1*, *a2*, ..., *an* , where each represents a point at coordinate (*i*, *ai*). *n* vertical lines are drawn such that the two endpoints of line *i* is at (*i*, *ai*) and (*i*, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n\n**Note:** You may not slant the container and *n* is at least 2.\n\n给定n个非负整数a1 a2…， an，其中每个点表示坐标(i, ai)上的一个点。画n条垂直线，使直线i的两个端点分别为(i, ai)和(i, 0)，找出两条直线，它们与x轴一起构成一个容器，使容器中含有最多的水。\n\n注意:容器不能倾斜，n至少为2。\n\n\n\n\n\n因为所求水是【两个直线x轴的差 * 短直线的y轴值】，先要使前者尽量大，所以从头和尾开始推进，计算当前面积，然后\n\n1.长的一边先保留，推进短的一边。这种方法慢一些。\n\n2.两边都找下一个比短边长的，比短边还短的直接忽略。这种方法快。\n\n# C++解\n\n```\n30ms：\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int i=0,j=height.size()-1;\n        int water=0;\n        while(i<j){\n            water=max(water,min(height[i],height[j])*(j-i));\n            if(height[i]<height[j]){\n                i++;\n            }\n            else{\n                j--;\n            }\n        }\n        return water;\n    }\n};\n\n16ms:\nclass Solution {\n    public:\n    int maxArea(vector<int>& height) {\n       int water = 0;\n       int i = 0, j = height.size() - 1;\n       while (i < j) {\n           int h = min(height[i], height[j]);\n           water = max(water, (j - i) * h);\n           while (height[i] <= h && i < j) i++;\n           while (height[j] <= h && i < j) j--;\n       }\n    return water;\n   }\n};\n```\n\n# python写法\n\n```\nclass Solution:\n    def maxArea(self, height):\n        i, j = 0, len(height) - 1\n        water = 0\n        while i < j:\n            water = max(water, (j - i) * min(height[i], height[j]))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return water\n```\n\n","tags":["leetcode"],"categories":["leetcode"]},{"title":"Policy Gradients","url":"/2019/01/17/2019011701/","content":"\n策略梯度\n\n<!-- more -->\n\n强化学习是一个通过奖惩来学习正确行为的机制. 家族中有很多种不一样的成员, 有学习奖惩值, 根据自己认为的高价值选行为, 比如 Q learning, Deep Q Network, 也有不通过分析奖励值, 直接输出行为的方法, 这就是今天要说的 Policy Gradients 了. \n\nPolicy gradient 是 RL 中另外一个大家族, 他借用神经网络，在无穷多的动作中计算价值, 从而选择行为。不像 Value-based 方法 (Q learning, Sarsa), 他也要接受环境信息 (observation), 不同的是他**要输出不是 action 的 value, 而是具体的那一个 action**, 这样 policy gradient 就跳过了 value 这个阶段. 而且个人认为 Policy gradient 最大的一个优势是: 输出的这个 action 可以是一个连续的值, 之前我们说到的 value-based 方法输出的都是不连续的值, 然后再选择值最大的 action. 而 policy gradient 可以在一个连续分布上选取 action.\n\n### 算法\n\n![](2019011701\\2159902-13d5d1a3acbf2157.png)\n\n在深度强化学习中，**Policy Π 可以看做是一个参数为 θ 的神经网络**，输入当前的state，输出可能的action的概率分布，选择概率最大的一个action作为要执行的操作。\n\nPolicy Gradient不通过误差反向传播，它通过观测信息选出一个行为直接进行反向传播，当然出人意料的是他并没有误差，而是利用reward奖励直接对选择行为的可能性进行增强和减弱，好的行为会被增加下一次被选中的概率，不好的行为会被减弱下次被选中的概率。\n\n以游戏为例，从游戏开始到结束，叫做一个episode，简单理解为回合。episode结束，游戏过程中所有的reward相加得到该回合的总reward（角色挂与未挂可能是一个负reward或一个大的正reward）。\n\n![](D:\\hexo\\web2\\source\\_posts\\2019011701\\2159902-ddae732feac73216.png)\n\n这里强化学习的目标就是学习一个Policy，即一个网络，使其每看到一个画面，做出一个action, 并做到最终获得最大总reward。\n\n#### 算法细节\n\n游戏的进程相应的可以表示成state,action交替的序列：\n\n![](2019011701\\2159902-2083b56a56aada88.png)\n\n游戏引擎（Environment）产生一个画面（state）,接着神经网络玩家（Actor）产生一个action，接着影响Environment，并产生下一个state，如此反复到游戏结束，一个完整的序列（1-T）为一个Trajectory，一轮游戏一轮回合，或者叫一轮采样。该序列发生的概率，即在策略Π 的参数为θ 情况下Trajectory τ发生的概率：\n\n![](2019011701\\2159902-4ddd6fd020512976.png)\n\n这样在此Trajectory下会得到一个总的回报R(τ)，可以想到，玩游戏有很大的随机性，不同的action就可能会有不同的state，反之亦然。因此R(τ)实际是一个变量（根据游戏场景过程的变化而变化），因此为了衡量一个策略Π的好坏，需要考虑一个期望的回报R_E(τ)。游戏的过程当然也不可能穷举，因此就需要采样来计算期望回报（“平均”回报），可以理解为Policy固定情况下反复的试玩N回合游戏，每回合的reward***以回合发生概率为权重相加取平均***，即为当前策略的期望reward。目标也就是***不断更新Policy的参数θ，使期望reward得到最大***。****\n\n![](2019011701\\2159902-9f56dcfcdca9ffca.png)\n\n#### 策略梯度提升\n\n有了目标，下面就是用合适的方法，使期望reward最大，一种方法便是策略梯度提升的方法（与最小化loss的梯度下降相对）。由上面可知期望reward是参数θ的函数，所以参数更新的方式为：\n\n![](2019011701\\2159902-aea1a369ca61875b.png)\n\n下面的问题就是期望reward对θ的导数的求法，走一波公式推导：\n\n![](2019011701\\2159902-0e5293f2a59fb71f.png)\n\n公式推导并不复杂，主要是蓝框里的一个常用小技巧变换（同时乘和除f(x)）。然后第二行等式到第三行将累加转换为期望表示；接着约等于N次采样的期望值。第三行到第四行将上面的p_{θ}(τ)带入，去掉与θ无关的环境相关概率p(s_{t+1}|s_t, a_t)和p(s_1),得到最终结果：\n\n![](2019011701\\2159902-666c1f7037af194e.png)\n\n下面就是不断采样，更新参数的过程（根据当前策略玩游戏，得回报，修正策略）：\n\n![](2019011701\\2159902-8a275b32e2655751.png)\n\n图示左边表示根据当前policy参数采样得到N个Trajectory，计算一次期望reward，然后梯度上升的方法更新policy参数，用更新后的policy再进行下一轮采样，如此往复直到收敛，得到期望reward最大的policy。最终该policy（神经网络表示）就学会了根据游戏画面做合适的action，最终赢得游戏。\n\n##### 优点：\n\n- 连续的动作空间（或者高维空间）中更加高效；\n- 可以实现随机化的策略；\n- 某种情况下，价值函数可能比较难以计算，而策略函数较容易。\n\n##### 缺点：\n\n- 通常收敛到局部最优而非全局最优\n- 评估一个策略通常低效（这个过程可能慢，但是具有更高的可变性，其中也会出现很多并不有效的尝试，而且方差高\n\n\n\n","tags":["reinforcement learning"],"categories":["reinforcement learning"]},{"title":"Qlearning和sarsa","url":"/2019/01/17/20190116001/","content":"\n强化学习\n\n<!-- more -->\n\n强化学习 (Reinforcement Learning) 是一个机器学习大家族中的分支, 由于近些年来的技术突破, 和深度学习 (Deep Learning) 的整合, 使得强化学习有了进一步的运用. 比如让计算机学着玩游戏, AlphaGo 挑战世界围棋高手, 都是强化学习在行的事. 强化学习也是让你的程序从对当前环境完全陌生, 成长为一个在环境中游刃有余的高手.\n\n[TOC]\n\n\n\n\n#### 1.1 强化学习与监督学习，非监督学习之间的关系![img](https://img-blog.csdn.net/20180202094621583?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3N3dzQwNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n#### 1.2 强化学习的学习过程\n\n强化学习它有自己的一套学习方法，下图是强化学习的示意图：\n\n![img](https://img-blog.csdn.net/20180202094806935?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3N3dzQwNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n从图上我们可以看到强化学习它由两部分组成：智能体和环境。我们可以这样理解，俗话解释一下：\n\n比如，我们从沙发旁走到门口，当我们起身之后，首先大脑获取路的位置信息，然后我们确定从当前位置向前走一步，不幸运的是我们撞墙了，这明显是个负反馈，因此环境会给我们一个负奖励，告诉我们这是一个比较差的走路方式，因此我们尝试换个方向走（走哪个方向比较好呢，后文会会讲到随机策略、确定性策略等策略决策），就这样不断的和环境交互尝试，最终找到一套策略，确保我们能够从沙发旁边走到门口。在这个过程中会得到一个最大的累计期望奖励。基于以上过程，非常值得一提的是奖励函数的设置，因为这个强化学习过程中对智能体动作好坏的评价。\n\n#### 1.3 强化学习的应用\n\n说了这么多，为什么要学习这门技术呢，无非有两种原因，1、找到新方向，继续学术研究；2、将该技术能够实际的用到工业界中，产生效益。还是不谈人生谈技术， 那么强化学习目前有哪些应用呢？目前调查了有以下： \n\n  1、控制类：机械臂控制、视频游戏（CNN获取图像信息，提取特征信息等处理），无人驾驶等       https://www.youtube.com/watch?v=W_gxLKSsSIE&list=PL5nBAYUyJTrM48dViibyi68urttMlUv7e       https://www.youtube.com/watch?v=CIF2SBVY-J0       https://www.youtube.com/watch?v=5WXVJ1A0k6Q       https://www.youtube.com/watch?v=-YMfJLFynmA  \n\n 2、文本序列预测，机器翻译等 https://zhuanlan.zhihu.com/p/22385421， https://zhuanlan.zhihu.com/p/29168803   \n\n3、推荐系统：（https://m.aliyun.com/yunqi/articles/66158，http://geek.csdn.net/news/detail/112318）还有很多的应用场景，陆续补充，但用一句话总结：只要涉及到智能决策问题，在符合强化学习的学习规则的情况下的都可以使用。\n\n#### 2.1  Reward and return 奖励和回报\n\n当前在状态St，根据方针(policy) π(a|s)，选择了一个动作at；根据动态（dynamics） p(st+1|st,at)，到达了状态St+1。奖励（reward）是 rt = r(St,at,St+1)，累计的回报（return）Rt 就是把每一步的奖励加起来。如果简单地忽略衰减函数的话，我们只是想让期望的return最大化。\n\n#### 2.2 Value值\n\n在状态 s 采取动作 a 并且遵从方针 π 的value是：\n\n![d](20190116001\\微信截图_20190116205205.png)\n\n得到的期望是关于遵从方针和动态从(St = s,At = a) 生成的轨迹 (St+k,At+k,k =1 ,2,...) 。期望的最优值就是Q的最大值。\n\n同样，我们可以定义状态的值：\n\n![2](20190116001\\微信截图_20190116205236.png)\n\n#### 2.3 Q-learning\n\n![q1](20190116001\\q1.png)\n\n我们做事情都会有一个自己的行为准则, 比如小时候爸妈常说”不写完作业就不准看电视”. 所以我们在 写作业的这种状态下, 好的行为就是继续写作业, 直到写完它, 我们还可以得到奖励, 不好的行为 就是没写完就跑去看电视了, 被爸妈发现, 后果很严重. 小时候这种事情做多了, 也就变成我们不可磨灭的记忆. 这和我们要提到的 Q learning 有什么关系呢? 原来 Q learning 也是一个决策过程, 和小时候的这种情况差不多. 我们举例说明.\n\n假设现在我们处于写作业的状态而且我们以前并没有尝试过写作业时看电视, 所以现在我们有两种选择 , 1, 继续写作业, 2, 跑去看电视. 因为以前没有被罚过, 所以我选看电视, 然后现在的状态变成了看电视, 我又选了 继续看电视, 接着我还是看电视, 最后爸妈回家, 发现我没写完作业就去看电视了, 狠狠地惩罚了我一次, 我也深刻地记下了这一次经历, 并在我的脑海中将 “没写完作业就看电视” 这种行为更改为负面行为, 我们在看看 Q learning 根据很多这样的经历是如何来决策的吧.\n\n##### Q-Learning 决策 \n\n![q2](20190116001\\q2.png)\n\n假设我们的行为准则已经学习好了, 现在我们处于状态s1, 我在写作业, 我有两个行为 a1, a2, 分别是看电视和写作业, 根据我的经验, 在这种 s1 状态下, a2 写作业 带来的潜在奖励要比 a1 看电视高, 这里的潜在奖励我们可以用一个有关于 s 和 a 的 Q 表格代替, 在我的记忆Q表格中, Q(s1, a1)=-2 要小于 Q(s1, a2)=1, 所以我们判断要选择 a2 作为下一个行为. 现在我们的状态更新成 s2 , 我们还是有两个同样的选择, 重复上面的过程, 在行为准则Q 表中寻找 Q(s2, a1) Q(s2, a2) 的值, 并比较他们的大小, 选取较大的一个. 接着根据 a2 我们到达 s3 并在此重复上面的决策过程. Q learning 的方法也就是这样决策的. 看完决策, 我看在来研究一下这张行为准则 Q 表是通过什么样的方式更改, 提升的.\n\n##### Q-Learning 更新 [¶](https://morvanzhou.github.io/tutorials/machine-learning/ML-intro/4-03-q-learning/#Q-Learning-%E6%9B%B4%E6%96%B0)\n\n![q3](20190116001\\q3.png)\n\n所以我们回到之前的流程, 根据 Q 表的估计, 因为在 s1 中, a2 的值比较大, 通过之前的决策方法, 我们在 s1 采取了 a2, 并到达 s2, 这时我们开始更新用于决策的 Q 表。\n\n接着我们**并没有在实际中采取任何行为**, 而是再想象自己在 s2 上采取了每种行为, 分别看看两种行为哪一个的 Q 值大。比如说 Q(s2, a2) 的值比 Q(s2, a1) 的大, 所以我们把大的 Q(s2, a2) 乘上一个衰减值 gamma (比如是0.9) 并加上到达s2时所获取的奖励 R (这里还没有获取到我们的棒棒糖, 所以奖励为 0), 因为会获取实实在在的奖励 R , 我们将这个作为我现实中 Q(s1, a2) 的值。 但是我们之前是根据 Q 表估计 Q(s1, a2) 的值， 所以有了现实和估计值，我们就能更新Q(s1, a2) ， 根据 估计与现实的差距，将这个差距乘以一个学习效率 alpha 累加上老的 Q(s1, a2) 的值 变成新的值。 \n\n但时刻记住，我们虽然用 maxQ(s2) 估算了一下 s2 状态，但还没有在 s2 做出任何的行为，s2 的行为决策要等到更新完了以后再重新另外做。这就是 **off-policy** 的 Q learning 是如何决策和学习优化决策的过程.\n\n##### Q-Learning 整体算法\n\n![q4](20190116001\\q4.png)\n\n这一张图概括了我们之前所有的内容. 这也是 Q learning 的算法, 每次更新我们都用到了 Q 现实和 Q 估计, 而且 Q learning 的迷人之处就是 在 Q(s1, a2) 现实 中, 也包含了一个 Q(s2) 的最大估计值, 将对下一步的衰减的最大估计和当前所得到的奖励当成这一步的现实, 很奇妙吧.\n\n 最后我们来说说这套算法中一些参数的意义. \n\n- Epsilon greedy 是用在决策上的一种策略, 比如 epsilon = 0.9 时, 就说明有90% 的情况我会按照 Q 表的最优值选择行为, 10% 的时间使用随机选行为. \n\n- alpha是学习率, 来决定这次的误差有多少是要被学习的, alpha是一个小于1 的数. \n\n- gamma 是对未来 reward 的衰减值. 我们可以这样想象.\n\n##### Q-Learning 中的 Gamma \n\n![q5](20190116001\\q5.png)\n\n我们重写一下 Q(s1) 的公式, 将 Q(s2) 拆开, 因为Q(s2)可以像 Q(s1)一样,是关于Q(s3) 的, 所以可以写成这样, 然后以此类推, 不停地这样写下去, 最后就能写成这样, 可以看出Q(s1) 是有关于之后所有的奖励, 但这些奖励正在衰减, 离 s1 越远的状态衰减越严重. \n\n不好理解? 行, 我们想象 Qlearning 的机器人天生近视眼, gamma = 1 时, 机器人有了一副合适的眼镜, 在 s1 看到的 Q 是未来没有任何衰变的奖励, 也就是机器人能清清楚楚地看到之后所有步的全部价值, 但是当 gamma =0, 近视机器人没了眼镜, 只能摸到眼前的 reward, 同样也就只在乎最近的大奖励, 如果 gamma 从 0 变到 1, 眼镜的度数由浅变深, 对远处的价值看得越清楚, 所以机器人渐渐变得有远见, 不仅仅只看眼前的利益, 也为自己的未来着想.\n\n#### 2.4 Sarsa\n\n在强化学习中 Sarsa 和 Q learning及其类似, 这节内容会基于之前的 Q learning. 和上次一样, 我们还是使用写作业和看电视这个例子. 没写完作业去看电视被打, 写完了作业有糖吃.\n\n##### Sarsa决策\n\n![s2](20190116001\\s2.png)\n\nSarsa 的决策部分和 [Q learning]一模一样, 因为我们使用的是 Q 表的形式决策, 所以我们会在 Q 表中挑选值较大的动作值施加在环境中来换取奖惩. 但是不同的地方在于 Sarsa 的更新方式是不一样的.\n\n##### Sarsa 更新行为准则\n\n![s3](20190116001\\s3.png)\n\n同样, 我们会经历正在写作业的状态 s1, 然后再挑选一个带来最大潜在奖励的动作 a2, 这样我们就到达了 继续写作业状态 s2, 而在这一步, 如果你用的是 Q learning, 你会观看一下在 s2 上选取哪一个动作会带来最大的奖励。但是在真正要做决定时, 却不一定会选取到那个带来最大奖励的动作, Q-learning 在这一步只是估计了一下接下来的动作值。\n\n而 Sarsa 是实践派, 他说到做到, 在 s2 这一步估算的动作也是接下来要做的动作。所以 Q(s1, a2) 现实的计算值, 我们也会稍稍改动, 去掉maxQ, 取而代之的是在 s2 上我们实实在在选取的 a2 的 Q 值. 最后像 Q learning 一样, 求出现实和估计的差距 并更新 Q 表里的 Q(s1, a2)。\n\n##### 对比Sarsa和Q-learning\n\n##### ![s4](20190116001\\s4.png)\n\n从算法来看, 这就是他们两最大的不同之处：\n\n因为 Sarsa 是说到做到型，所以我们也叫他 on-policy，在线学习，学着自己在做的事情。\n\n 而 Q learning 是说到但并不一定做到， 所以它也叫作 Off-policy，离线学习，而因为有了 maxQ，Q-learning 也是一个特别勇敢的算法。\n\n![s5](20190116001\\s5.png)\n\n为什么说他勇敢呢， 因为 Q learning 机器人永远都会选择最近的一条通往成功的道路，不管这条路会有多危险；而 Sarsa 则是相当保守，他会选择离危险远远的，拿到宝藏是次要的，保住自己的小命才是王道，这就是使用 Sarsa 方法的不同之处。\n\n这种不同之处使得 Sarsa 相对于 Qlearning更加的胆小。因为 Qlearning 永远都是想着 `maxQ`最大化， 因为这个 `maxQ` 而变得贪婪， 不考虑其他非 `maxQ` 的结果。我们可以理解成 Qlearning 是一种贪婪、大胆、勇敢的算法，对于错误、 死亡并不在乎；而 Sarsa 是一种保守的算法，他在乎每一步决策，对于错误和死亡比较敏感。两种算法都有他们的好处，比如在实际中，你比较在乎机器的损害，用一种保守的算法，在训练时就能减少损坏的次数。\n\n##### 什么是Sarsa（lambda）\n\n现在我们知道了Sarsa是一种在线学习法，但是这个 lambda 到底是什么。\n\n其实吧, Sarsa 是一种单步更新法，在环境中每走一步，更新一次自己的行为准则，我们可以在这样的 Sarsa 后面打一个括号， 说他是 Sarsa(0)， 因为他等走完这一步以后直接更新行为准则。如果延续这种想法，走完这步，再走一步，然后再更新，我们可以叫他 Sarsa(1)。同理， 如果等待回合完毕我们一次性再更新呢，比如这回合我们走了 n 步，那我们就叫 Sarsa(n)。为了统一这样的流程，我们就有了一个 lambda值来代替我们想要选择的步数，这也就是 Sarsa(lambda) 的由来。我们看看最极端的两个例子，对比单步更新和回合更新，看看回合更新的优势在哪里。\n\n![sl3](20190116001\\sl3.png)\n\n虽然我们每一步都在更新，但是在没有获取宝藏的时候，我们现在站着的这一步的没有得到任何更新，也就是直到获取宝藏时，我们才为获取到宝藏的上一步更新为：这一步很好, 和获取宝藏是有关联的，而之前为了获取宝藏所走的所有步都被认为和获取宝藏没关系。回合更新虽然我要等到这回合结束，才开始对本回合所经历的所有步都添加更新，但是这所有的步都是和宝藏有关系的，都是为了得到宝藏需要学习的步，所以每一个脚印在下回合被选则的几率又高了一些。在这种角度来看，回合更新似乎会有效率一些。\n\n我们看看这种情况，还是使用单步更新的方法在每一步都进行更新，但是同时记下之前的寻宝之路。你可以想像，每走一步，插上一个小旗子，这样我们就能清楚的知道除了最近的一步，找到宝物时还需要更新哪些步了。\n\n 不过, 有时候情况可能没有这么乐观。开始的几次，因为完全没有头绪，我可能在原地打转了很久，然后才找到宝藏，那些重复的脚步真的对我拿到宝藏很有必要吗? 答案我们都知道。所以Sarsa(lambda)就来拯救你啦。\n\n##### Lambda含义与取值\n\n![sl4](20190116001\\sl4.png)\n\n其实 lambda 就是一个衰变值, 他可以让你知道离奖励越远的步可能并不是让你最快拿到奖励的步, 所以我们想象我们站在宝藏的位置, 回头看看我们走过的寻宝之路, 离宝藏越近的脚印越看得清, 远处的脚印太渺小, 我们都很难看清, 那我们就索性记下离宝藏越近的脚印越重要, 越需要被好好的更新。和之前我们提到过的 奖励衰减值 gamma 一样, lambda 是脚步衰减值, 都是一个在 0 和 1 之间的数。\n\n![sl5](20190116001\\sl5.png)\n\n当 lambda 取0, 就变成了 Sarsa 的单步更新；当 lambda 取 1, 就变成了回合更新, 对所有步更新的力度都是一样。当 lambda 在 0 和 1 之间, 取值越大, 离宝藏越近的步更新力度越大。这样我们就不用受限于单步更新的每次只能更新最近的一步, 我们可以更有效率的更新所有相关步了。\n\nSarsa-lambda 是基于 Sarsa 方法的升级版, 他能更有效率地学习到怎么样获得好的 reward. 如果说 Sarsa 和 Qlearning 都是每次获取到 reward, 只更新获取到 reward 的前一步. 那 Sarsa-lambda 就是更新获取到 reward 的前 lambda 步. lambda 是在 [0, 1] 之间取值,\n\n如果 lambda = 0, Sarsa-lambda 就是 Sarsa, 只更新获取到 reward 前经历的最后一步.\n\n如果 lambda = 1, Sarsa-lambda 更新的是 获取到 reward 前所有经历的步.\n\n[学习更多-莫烦PYTHON]: https://morvanzhou.github.io/tutorials/machine-learning/reinforcement-learning/3-3-tabular-sarsa-lambda/\t\"莫烦PYTHON\"\n\n","categories":["reinforcement learning"]},{"title":"实现将字符串转换为整数","url":"/2019/01/16/2019011602/","content":"\n实现将字符串转换为整数的atoi。该函数首先丢弃尽可能多的空白字符，直到找到第一个非空白字符。然后，从这个字符开始，取一个可选的初始加号或减号，后面跟着尽可能多的数字，并将它们解释为一个数值。\n\n字符串可以在组成整数的字符之后包含其他字符，这些字符将被忽略，并且对该函数的行为没有影响。\n\n如果str中的第一个非空格字符序列不是有效的整数，或者由于str为空或只包含空格字符而不存在这样的序列，则不执行转换。如果无法执行有效的转换，则返回零值。\n\n<!-- more -->\n\n## Problem\n\n**Note:**\n\n- Only the space character `' '` is considered as whitespace character.\n\n- Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.\n\n- **Example 1:**\n\n  ```\n  Input: \"42\"\n  Output: 42\n  ```\n\n  **Example 2:**\n\n  ```\n  Input: \"   -42\"\n  Output: -42\n  Explanation: The first non-whitespace character is '-', which is the minus sign.\n               Then take as many numerical digits as possible, which gets 42.\n  ```\n\n  **Example 3:**\n\n  ```\n  Input: \"4193 with words\"\n  Output: 4193\n  Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.\n  ```\n\n  **Example 4:**\n\n  ```\n  Input: \"words and 987\"\n  Output: 0\n  Explanation: The first non-whitespace character is 'w', which is not a numerical \n               digit or a +/- sign. Therefore no valid conversion could be performed.\n  ```\n\n  **Example 5:**\n\n  ```\n  Input: \"-91283472332\"\n  Output: -2147483648\n  Explanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer.\n               Thefore INT_MIN (−231) is returned.\n  ```\n\n------\n\n## Solution\n\n【c++】\n\n```\nint myAtoi(string str) {\n    long result = 0;\n    int indicator = 1;\n    for(int i = 0; i<str.size();)\n    {\n        i = str.find_first_not_of(' ');\n        if(str[i] == '-' || str[i] == '+')\n            indicator = (str[i++] == '-')? -1 : 1;\n        while('0'<= str[i] && str[i] <= '9') \n        {\n            result = result*10 + (str[i++]-'0');\n            if(result*indicator >= INT_MAX) return INT_MAX;\n            if(result*indicator <= INT_MIN) return INT_MIN;                \n        }\n        return result*indicator;\n    }\n}\n```","tags":["Arrays","leetcode"],"categories":["leetcode"]},{"title":"tensorflow随笔","url":"/2019/01/15/2019011502/","content":"\n### CNN网络搭建\n\n<!-- more -->\n\n**CNN网络结构**\n\n输入的图像shape为 [batch_size, height, width, depth]\n\n第一层：卷积层 conv1\n\n第二层：池化层 pool1\n\n第三层：标准化层 norm1\n\n第四层：卷积层 conv2\n\n第五层：标准化层 norm2\n\n第六层：池化层 pool2\n\n第七层：全联接层 local1\n\n第八层：全联接层 local2\n\n第九层：输出层 softmax_linear\n\n\n\n**tf.nn.conv1d( value, filters, stride,padding,use_cudnn_on_gpu=None,data_format=None, name=None)**\n\nvalue的格式为：[batch, in_width, in_channels]，batch为样本维，表示多少个样本，in_width为宽度维，表示样本的宽度，in_channels维通道维，表示样本有多少个通道。 事实上，也可以把格式看作如下:[batch, 行数, 列数]，把每一个样本看作一个平铺开的二维数组。这样的话可以方便理解。\n\nfilters：在注释中，filters的格式为：[filter_width, in_channels, out_channels]。按照value的第二种看法，filter_width可以看作每次与value进行卷积的行数，in_channels表示value一共有多少列（与value中的in_channels相对应）。out_channels表示输出通道，可以理解为一共有多少个卷积核，即卷积核的数目。\n\nstride：一个整数，表示步长，每次（向下）移动的距离（TensorFlow中解释是向右移动的距离，这里可以看作向下移动的距离）。\n\npadding：同conv2d，value是否需要在下方填补0。\n\n\n\n**tf.nn.conv2d(input, filter, strides, padding, use_cudnn_on_gpu=None, name=None) **\n\n除去name参数用以指定该操作的name，与方法有关的一共五个参数：\n\n- input： \n  指需要做卷积的输入图像，它要求是一个Tensor，具有[batch, in_height, in_width, in_channels]这样的shape，具体含义是[训练时一个batch的图片数量, 图片高度, 图片宽度, 图像通道数]，注意这是一个4维的Tensor，要求类型为float32和float64其中之一。\n\n\n- filter： \n  相当于CNN中的卷积核，它要求是一个Tensor，具有[filter_height, filter_width, in_channels, out_channels]这样的shape，具体含义是[卷积核的高度，卷积核的宽度，图像通道数，卷积核个数]，要求类型与参数input相同，有一个地方需要注意，第三维in_channels，就是参数input的第四维。\n\n\n- strides：卷积时在图像每一维的步长，这是一个一维的向量，长度4。\n\n\n- padding： \n  string类型的量，只能是”SAME”,”VALID”其中之一，这个值决定了不同的卷积方式（后面会介绍）\n\n\n- use_cudnn_on_gpu： bool类型，是否使用cudnn加速，默认为true。\n\n  \n\n**tf.nn.max_pool(value, ksize, strides, padding, name=None)**\n参数是四个，和卷积很类似：\n\n- 第一个参数value：需要池化的输入，一般池化层接在卷积层后面，所以输入通常是feature map，依然是[batch, height, width, channels]这样的shape\n\n- 第二个参数ksize：池化窗口的大小，取一个四维向量，一般是[1, height, width, 1]，因为我们不想在batch和channels上做池化，所以这两个维度设为了1\n\n- 第三个参数strides：和卷积类似，窗口在每一个维度上滑动的步长，一般也是[1, stride,stride, 1]\n\n- 第四个参数padding：和卷积类似，可以取'VALID' 或者'SAME'\n\n- 返回一个Tensor，类型不变，shape仍然是[batch, height, width, channels]这种形式\n\n  \n\n**tf.get_variable(name,  shape, initializer):** \n\nname就是变量的名称，shape是变量的维度，initializer是变量初始化的方式。\n\n- tf.constant_initializer：常量初始化函数\n\n- tf.random_normal_initializer：正态分布\n\n- tf.truncated_normal_initializer：截取的正态分布\n\n- tf.random_uniform_initializer：均匀分布\n\n- tf.zeros_initializer：全部是0\n\n- tf.ones_initializer：全是1\n\n- tf.uniform_unit_scaling_initializer：满足均匀分布，但不影响输出数量级的随机值\n\n  \n\n1. tf.constant_initializer：常量初始化函数\n\n2. tf.random_normal_initializer：正态分布\n\n3. tf.truncated_normal_initializer：截取的正态分布\n\n4. tf.random_uniform_initializer：均匀分布\n\n5. tf.zeros_initializer：全部是0\n\n6. tf.ones_initializer：全是1\n\n7. tf.uniform_unit_scaling_initializer：满足均匀分布，但不影响输出数量级的随机值\n\n\n**tf.variable_scope**可以让变量有相同的命名，包括tf.get_variable得到的变量，还有tf.Variable的变量。\n\n**tf.name_scope**可以让变量有相同的命名，只是限于tf.Variable的变量。\n\n**tf.truncated_normal_initializer()**，或者简写为tf.TruncatedNormal()生成截断正态分布的随机数，这个初始化方法好像在tf中用得比较多。它有四个参数（mean=0.0, stddev=1.0, seed=None, dtype=dtypes.float32)，分别用于指定均值、标准差、随机数种子和随机数的数据类型，一般只需要设置stddev这一个参数就可以了。\n\n**tf.multiply（）**两个矩阵中对应元素各自相乘\n **tf.matmul（）**将矩阵a乘以矩阵b，生成a * b。\n\n\n\n**np*.*prod()**函数用来计算所有元素的乘积，对于有多个维度的数组可以指定轴，如axis=1指定计算每一行的乘积。\n\n**np.sqrt(x) ** 计算数组各元素的平方根。","tags":["tensorflow"],"categories":["tensorflow"]},{"title":"32位有符号整数的反转数字","url":"/2019/01/15/20190115/","content":"leetcode第7题\n<!-- more -->\n\n# 【leetcode第7题】\n\nGiven a 32-bit signed integer, reverse digits of an integer.\n\n给定一个32位有符号整数，得到该整数的反转数字。\n\n> Example 1:\n> Input: 123\n> Output: 321\n> Example 2:\n> Input: -123\n> Output: -321\n> Example 3:\n> Input: 120\n> Output: 21\n> Note:\n> Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\n>\n> 假设我们正在处理一个环境，只能在32位带符号整数存储整数范围：[−231,  231 − 1]。\n>\n> 对于这个问题，假设函数在反整数溢出时返回0。\n\n# 【c++】\n\n```\nclass Solution {\npublic:\n    int reverse(int x) {\n        long y=0;\n        while(x){ \n            y=y*10+x%10;\n            x/=10;\n        }\n       return (y>INT_MIN && y<INT_MAX)?y:0;\n    }\n};\n```\n# 关于INT_MAX INT_MIN的运算\nValue of INT_MAX is +2147483647.\nValue of INT_MIN is -2147483648.\n因为int占4字节32位，根据二进制编码的规则，INT_MAX = 2^31-1，INT_MIN= -2^31.\n\nC/C++中，所有超过该限值的数，都会出现溢出，出现warning，但是并不会出现error。\n\n如果想表示的整数超过了该限值，可以使用长整型long long 占8字节64位。\n\n由于二进制编码按原码、补码和反码的规则进行运算，所有程序中对INT_MAX和INT_MIN的运算应当格外注意，在出现溢出的时候，不遵循数学规则。\n\nINT_MAX + 1 = INT_MIN\n\nINT_MIN - 1 = INT_MAX\n\nabs(INT_MIN) = INT_MIN\n\n比较有趣的是，INT_MAX + 1 < INT_MAX， INT_MIN - 1 > INT_MIN, abs(INT_MIN) < 0.\n","tags":["leetcode"],"categories":["leetcode"]},{"title":"查找两个数组的中间值","url":"/2019/01/14/2019011401/","content":"leetcode第4题\n<!-- more -->\n\n# # 【leetcode第4题】\n\nThere are two sorted arrays nums1 and nums2 of size m and n respectively.\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\nYou may assume nums1 and nums2 cannot be both empty.\n\n分别有大小为m和n的两个排序数组nums1和nums2。\n\n求两个排序数组的中值。总的运行时复杂性应该是O(log (m+n))。\n\n您可以假设nums1和nums2不能同时为空。\n\nExample 1:\nnums1 = [1, 3]\nnums2 = [2]\nThe median is 2.0\n\nExample 2:\nnums1 = [1, 2]\nnums2 = [3, 4]\nThe median is (2 + 3)/2 = 2.5\n\n# # 【思路】\n\n首先理解什么是中间值，在统计学里面就是用于把一个数集分为两个等长的子集，一个子集总是比另一个大。当我们理解了中间值的使用，我们就和答案非常接近了。\n\n1、首先把A从一个随机的位置i分成两个部分：\n           left_A             |        right_A\n\t A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]\nA有m个元素，因此有m-1种切割的方式， len(left_A) = i, len(right_A) = m - i\n（i=0时，left_A为空；i=m，right_A为空）\n\n2、同样的，把B从一个随机的位置j分成两个部分：\n           left_B             |        right_B\n\t B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]\n\n3、把A和B放在一起，则有：\n           left_part          |        right_part\n     A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]\n\t B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]\n\n4、按照中间值的含义，如果：\n1) len(left_part) == len(right_part)\n2) max(left_part) <= min(right_part)\n那么median = (max(left_part) + min(right_part))/2.\n具体表示就是：\n    (1) i + j == m - i + n - j\n         (or:如果m+n为奇数，i+j比m-i+n-j多1则\n              i + j == m - i + n - j + 1) \n            if n >= m, we just need to set: i = 0 ~ m, j = (m + n + 1)/2 - i\n         (为什么n>=m，因为i有可能取到m，若同时n<m则j将为负数，会得到无效解)\n    (2) B[j-1] <= A[i] and A[i-1] <= B[j]\n\n5、因此我们应该做的是：\n    Searching i in [0, m], to find an object i that:\n        B[j-1] <= A[i] and A[i-1] <= B[j], ( where j = (m + n + 1)/2 - i )\n\n这个搜索i的过程具体描述为：\n\n 1 设置imin = 0, imax = m, 在[imin, imax]里面展开搜索\n\n 2 i = (imin + imax)/2, j = (m + n + 1)/2 - i\n\n 3 现在我们有len(left_part)==len(right_part).有三种情况：\n\n​     a B[j-1] <= A[i] and A[i-1] <= B[j]\n​         找到了i，可以停止搜索了。\n​     b B[j-1] > A[i]\n​         B的左侧最大值比A的右侧最小值大了，说明A[i]太小，需要向右移动i，i增大同时j会减小。\n​         要增大i的话，要调整搜索范围变成[i+1, imax]，因此设置imin = i+1，回到2.\n​     c A[i-1] > B[j]\n​        A的左侧最大值比B的右侧最小值大了，说明A[i-1]太大，需要向左移动i，i减小同时j会增大。\n​        要减小i的话，要调整搜索范围变成[imin, i-1]，因此设置imax = i-1，回到2.\n\n```\n\n```\n\n6、i搜索到之后，中间值为：\n     m+n为奇数时：max(A[i-1], B[j-1])\n     m+n为偶数时：(max(A[i-1], B[j-1]) + min(A[i], B[j]))/2 \n\n7、接下来我们来考虑极限情况， i=0,i=m,j=0,j=n时，A[i-1],B[j-1],A[i],B[j]中的某些可能会不存在，因此我们就不用同时检查B[j-1] <= A[i]和 A[i-1] <= B[j].只检查其中一个就够了。\n\n所以我们应该做的是：\n\n​    Searching i in [0, m], to find an object `i` that:\n​        (j == 0 or i == m or B[j-1] <= A[i]) and\n​        (i == 0 or j == n or A[i-1] <= B[j])\n​        where j = (m + n + 1)/2 - i\n\n在一个搜索循环里，我们只会遇到三种情况：\n\n​     a (j == 0 or i == m or B[j-1] <= A[i]) and\n​         (i == 0 or j = n or A[i-1] <= B[j])\n​          找到了i可以停止了\n\n​    b i < m and B[j - 1] > A[i]\n​         i太小，需要增大\n\n​    c i > 0 and A[i - 1] > B[j]\n​         i太大，需要减小\n\n   （由于i < m ==> j > 0 和 i > 0 ==> j < n，因此b和c不用检查j）\n\n# 【解】\n\n```\ndef median(A, B):\n    m, n = len(A), len(B)\n    if m > n:\n        A, B, m, n = B, A, n, m\n    if n == 0:\n        raise ValueError\n    imin, imax, half_len = 0, m, (m + n + 1) / 2\n    while imin <= imax:\n        i = (imin + imax) / 2\n        j = half_len - i\n        if i < m and B[j-1] > A[i]:\n            # i is too small, must increase it\n            imin = i + 1\n        elif i > 0 and A[i-1] > B[j]:\n            # i is too big, must decrease it\n            imax = i - 1\n        else:\n            # i is perfect\n            if i == 0: max_of_left = B[j-1]\n            elif j == 0: max_of_left = A[i-1]\n            else: max_of_left = max(A[i-1], B[j-1])\n            if (m + n) % 2 == 1:\n                return max_of_left\n            if i == m: min_of_right = B[j]\n            elif j == n: min_of_right = A[i]\n            else: min_of_right = min(A[i], B[j])\n            return (max_of_left + min_of_right) / 2.0\n```\n【c++】\n```\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> A=nums1,B=nums2,p;\n        int m=nums1.size(), n=nums2.size(),pass=0;\n        if(m>n){\n            pass=m;\n            m=n;\n            n=pass;\n            p=A;\n            A=B;\n            B=p;\n        }\n        int imin=0,imax=m;\n        int max_of_left=0,min_of_right=0;\n        int i=0,j=0;\n        while (imin <= imax ){\n            i = (imin + imax) / 2;\n            j = (m + n + 1) / 2 - i;\n            if(i < m && B[j-1] > A[i]){\n                imin=i+1;\n            }\n            else if( i > 0 && A[i-1] > B[j]){\n                imax=i-1;\n            }\n            else{\n                if(i==0){\n                    max_of_left = B[j-1];\n                }\n                else if(j == 0){\n                    max_of_left = A[i-1];\n                }else{\n                    max_of_left = max(A[i-1], B[j-1]);\n                }\n                if ((m + n) % 2 == 1){\n                    return max_of_left;\n                } \n                if(i==m){\n                    min_of_right = B[j];\n                }\n                else if(j == n){\n                    min_of_right = A[i];\n                }else{\n                    min_of_right = min(A[i], B[j]);\n                }\n                return (max_of_left + min_of_right) / 2.0;\n            }\n        }\n        return 0;\n        \n    }\n};\n```","tags":["Arrays","leetcode"],"categories":["leetcode"]},{"title":"about","url":"/about/index.html","content":"\n随便搞搞罢了\n\n"},{"title":"gallery","url":"/gallery/index.html","content":"\n\n\n![点击查看源网页](https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1547986120&di=4983e496983f5e4accd976839327e159&src=http://wx3.sinaimg.cn/wap720/bf0a6d34ly1fhqqqijmp5j210c0kugnq.jpg)\n\n![点击查看源网页](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1547996301709&di=06d2d4b1b401dafcb2d69aac0c66b4ec&imgtype=0&src=http%3A%2F%2Fpic.rmb.bdstatic.com%2F05f9a8bce23cf396e99993f333d0fb9c.jpeg)\n\n![点击查看源网页](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1547996301709&di=b2d9e1f5ce1f30443ac8fe22296b7a3a&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20181209%2Fa35bbc986cd145828d003dcdcc315738.jpeg)\n\n![点击查看源网页](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1547996301709&di=db6e7fda8c4c1901262b114485943950&imgtype=0&src=http%3A%2F%2Fr.sinaimg.cn%2Flarge%2Ftc%2Fmmbiz_qpic_cn%2F94174cf13665e31bf0dcc36105c96755.jpg)\n\n![点击查看源网页](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1547996301708&di=125822c32cda3de7ba43f594b00009fa&imgtype=0&src=http%3A%2F%2Fn.sinaimg.cn%2Fent%2Ftransform%2F711%2Fw630h881%2F20190107%2FnpUV-hrfcctn4275093.jpg)"}]
[{"title":"Easy 88 Merge Sorted Array","url":"/2019/05/11/20190511/","content":"\n<!-- more -->\n\n# 问题\n\nGiven two sorted integer arrays *nums1* and *nums2*, merge *nums2* into *nums1* as one sorted array.\n\n**Note:**\n\n- The number of elements initialized in *nums1* and *nums2* are *m* and *n* respectively.\n- You may assume that *nums1* has enough space (size that is greater or equal to *m* + *n*) to hold additional elements from *nums2*.\n\n**Example:**\n\n```\nInput:\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6],       n = 3\n\nOutput: [1,2,2,3,5,6]\n```\n\n# 解答\n\n题目要求把第二个数组的内容都插入到第一个数组中，两个数组都是顺序的数组。第一个数组后面已经有空位了，按照从后往前的顺序插入比较好，不必再另寻空间。\n\n对比两个数组的最后一个数，把更大一些的插入到第一个数组的尾端，依次从后往前遍历即可。但是如果第二个数组的数字比第一个数组的数字多，就可能循环结束后第二个数组里还有几个没有插入，因此直接把剩下的插入到第一个数组中的剩下位置里即可。\n\njava\n\n```\n public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i=m-1,j=n-1,k=m+n-1;\n        while(i>-1&&j>-1){\n            if(nums1[i]>nums2[j]){\n                nums1[k--]=nums1[i--];\n            }\n            else{\n                nums1[k--]=nums2[j--];\n            }\n        }\n        while(j>-1){\n            nums1[k--]=nums2[j--];\n        }\n    }\n```\n\n","tags":["Arrays","leetcode"],"categories":["leetcode"]},{"title":"Medium 75 Sort Colors","url":"/2019/05/10/20190512/","content":"\n<!-- more -->\n\n# 问题\n\nGiven an array with *n* objects colored red, white or blue, sort them **in-place** so that objects of the same color are adjacent, with the colors in the order red, white and blue.\n\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n\n**Note:** You are not suppose to use the library's sort function for this problem.\n\n**Example:**\n\n```\nInput: [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\n```\n\n# 解答\n\n就是把012三个数排序的问题，只有三个数所以可以想到最简单快速的方法就是比大小。以1为基准，比1小的放在前面，比1大的放在后面，排序就完成了。用one-pass搞定。\n\nJAVA\n\n```\n  public void sortColors(int[] nums) {\n        int red=0,white=0,blue=nums.length-1;\n        int temp=0;\n        while(white<=blue){\n            if(nums[white]==1){\n                white++;\n            }\n            else if(nums[white]==0){\n                temp=nums[red];\n                nums[red++]=nums[white];\n                nums[white++]=temp;\n            }\n            else if(nums[white]==2){\n                temp=nums[blue];\n                nums[blue--]=nums[white];\n                nums[white]=temp;\n            }\n        }\n    }\n```\n\n","tags":["Arrays","leetcode"],"categories":["leetcode"]},{"title":"Medium 228 Summary Ranges","url":"/2019/05/10/20190510/","content":"\nint和string的转换\n\n新知识点：int和string的转换\n\n<!-- more -->\n\n# 题目\n\nGiven a sorted integer array without duplicates, return the summary of its ranges.\n\n**Example 1:**\n\n```\nInput:  [0,1,2,4,5,7]\nOutput: [\"0->2\",\"4->5\",\"7\"]\nExplanation: 0,1,2 form a continuous range; 4,5 form a continuous range.\n```\n\n**Example 2:**\n\n```\nInput:  [0,2,3,4,6,8,9]\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\nExplanation: 2,3,4 form a continuous range; 8,9 form a continuous range.\n```\n\n# 解答\n\n看到题目后，首先想到的就是依次遍历每个数字，对比其与后一个数字是否相差1，若是的话继续遍历，直到与后一个数字不连续或者没有后一个数字（当前已是最后一个数），此时得到了一个连续的范围，将其存入结果中，然后继续遍历。\n\nJAVA\n\n```\npublic List<String> summaryRanges(int[] nums) {\n        List<String> output=new ArrayList();\n        if(nums.length==1){\n            output.add(String.valueOf(nums[0]));\n            return output;\n        }\n        for(int i=0;i<nums.length;i++){\n            int form=nums[i];\n            while(i+1<nums.length&&nums[i+1]-nums[i]==1){\n                i++;\n            }\n            if(form!=nums[i]){\n                output.add(form+\"->\"+nums[i]);\n            }\n            else{\n                output.add(String.valueOf(form));\n            }\n            \n        }\n        return output;\n    }\n```\n\nC++\n\n```\n vector<string> summaryRanges(vector<int>& nums) {\n        vector<string> output;\n        int n = nums.size();\n        for(int i=0 ; i<n ; i++)\n        {\n            int from=nums[i];\n            while(i<n-1 && nums[i+1]==nums[i]+1){\n                i++;\n            }\n            if(from!=nums[i]){\n                output.push_back( to_string(from) + \"->\" + to_string(nums[i]) );\n            }\n            else{\n                output.push_back(to_string(nums[i]));\n            }\n        }\n        return output;\n }\n```\n\n\n\n# JAVA扩展\n\nJava中int转String 和 String转int 各方法效率对比\n\n<https://blog.csdn.net/u012050154/article/details/51320638>\n\n#### 一、int转String有三种方式\n\n(1)num + \"\"  *最慢*\n\n(2)String.valueOf(num)  *num为null也可，但返回“null”而非null*\n\n(3)Integer.toString(num)  *num不能为null，会抛出NullPointerException异常*\n\n#### 二、String转int有两种方式\n\n(1)Integer.parseInt(str)\n\n(2)Integer.valueOf(str).intValue()\n\n运行时间差不多","tags":["Arrays","leetcode"],"categories":["leetcode"]},{"title":"Medium 152 Maximum Product Subarray","url":"/2019/04/15/20190416/","content":"\n<!-- more -->\n\n# 题目\n\nGiven an integer array `nums`, find the contiguous subarray within an array (containing at least one number) which has the largest product.\n\n**Example 1:**\n\n```\nInput: [2,3,-2,4]\nOutput: 6\nExplanation: [2,3] has the largest product 6.\n```\n\n**Example 2:**\n\n```\nInput: [-2,0,-1]\nOutput: 0\nExplanation: The result cannot be 2, because [-2,-1] is not a subarray.\n```\n\n# 解\n\n```\n public int maxProduct(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int max = nums[0], min = nums[0], result = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            int temp = max;\n            max = Math.max(Math.max(max * nums[i], min * nums[i]), nums[i]);\n            min = Math.min(Math.min(temp * nums[i], min * nums[i]), nums[i]);\n            if (max > result) {\n                result = max;\n            }\n        }\n        return result;\n    }\n```\n\n主要就是比较max * A[i]， min * A[i]和A[i]，因为这是乘积，负*负可以是正的。","tags":["Arrays","leetcode"],"categories":["leetcode"]},{"title":"Medium 238 Product of Array Except Self","url":"/2019/04/15/20190415/","content":"\n<!-- more -->\n\n# 题目\n\nGiven an array `nums` of *n* integers where *n* > 1,  return an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\n  \n\n**Example:**\n\n  \n\n```\nInput:  [1,2,3,4]\nOutput: [24,12,8,6]\n```\n\n  \n\n**Note:** Please solve it **without division** and in O(*n*).\n\n  \n\n**Follow up:**\n Could you solve it with constant space complexity? (The output array **does not** count as extra space for the purpose of space complexity analysis.)\n\n# 解\n\n题目的意思可理解为，输出的数组其每个位置的值是输入数组该位置以外所有数相乘的积。\n\n要求复杂度为n，则不可双层遍历，可写两个for。\n\n主要思路为：先从前往后，用left记录当前位置以前所有数相乘的积，因第一个数左边没有数字，则从1遍历到n-1（最后一个数字），res[i]=left。再从后往前，用right记录当前位置以后所有数字相乘的积，即j从n-2（倒数第二个数字）遍历到0（第一个数字），res[j]=res[j]*right。\n\n\n\n```\n public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n        res[0]=1;\n        int left=nums[0],right=nums[n-1];\n        for(int i=1;i<n;i++){\n            res[i]=left;\n            left*=nums[i];\n        }\n        for(int j=n-2;j>=0;j--){\n            res[j]*=right;\n            right*=nums[j];\n        }\n        return res;\n    }\n```\n\n","tags":["Arrays","leetcode"],"categories":["leetcode"]},{"title":"渲染方程Rendering equation","url":"/2019/04/09/20190409/","content":"\n<!-- more -->\n\nhttps://zhuanlan.zhihu.com/p/52497510\n\n# 一 光辐射\n\n1、辐射：\n\n光以电磁波形式或粒子（光子）形式传播的能量，这种能量及其传播过程称为光辐射。\n\n辐射是光在环境中的分布的基本特征——***渲染就是计算光的辐射***。\n\n2、光子（ photon）：\n\n光量子，简称光子，是传递电磁相互作用的基本粒子，是一种规范玻色子，在1905年由爱因斯坦提出。光子是电磁辐射的载体，而在量子场论中光子被认为是电磁相互作用的媒介子。光子静止质量为零。光子以光速运动，并具有能量、动量、质量。\n\n3、**辐射能（Radiant energy ）：“总击中”**\n\n一个想法：只在场景的整个持续时间内存储场景中任何地方出现的“击中”总数。确实，这个数字是捕获到达现场的所有光子的总能量。单位hit。\n\n每个光子的能量公式为： ![Q=\\frac{hc}{\\lambda}](https://www.zhihu.com/equation?tex=Q%3D%5Cfrac%7Bhc%7D%7B%5Clambda%7D)\n\nh:普朗克常数，单位是 ![j*s](https://www.zhihu.com/equation?tex=j%2As) \nc:光速,单位是 ![m/s](https://www.zhihu.com/equation?tex=m%2Fs) \n ![\\lambda](https://www.zhihu.com/equation?tex=%5Clambda) ：波长（颜色）,单位是 ![m](https://www.zhihu.com/equation?tex=m) \n所以这里的hit，其实单位是焦耳，也就是说，辐射能的单位是j\n通常来讲能量使用字母 ![Q](https://www.zhihu.com/equation?tex=Q) 来表示。\n\n4、**辐射通量（Radiant flux ）：“每秒击中”**\n\n对于人类感知水平上的光照现象，通常可以安全地假定平衡是立即达到的。因此，与其在某些(任意)时间内记录总能量，不如记录每秒的总击中次数。也就是能量的时间密度 。\n\n![Watts=j/s](https://www.zhihu.com/equation?tex=Watts%3Dj%2Fs) ,所以辐射通量的单位是w,瓦特。\n通常来说，辐射通量使用字母 ![\\Phi](https://www.zhihu.com/equation?tex=%5CPhi) 来表示。\n\n5、**辐照度是（Irradiance ）“每秒每单位面积的**击中**”**\n\n通常我们想要的不仅仅是总数，还需要知道击中发生在哪里。因此，计算某些“非常小”区域的每秒击中量，除以区域面积。这也可以理解为辐射通量的面积密度。\n\n> 辐照度的单位应当时 ![w/m^{2}](https://www.zhihu.com/equation?tex=w%2Fm%5E%7B2%7D) ，这是一个导出单位。\n> 通常来说辐照度使用字母 ![E](https://www.zhihu.com/equation?tex=E) 来表示\n\n因此：从这个角度出发，我们在图像生成方面的目标是估计图像中每个点的辐照度(或者每像素的总辐射通量)\n\n对于各项同性点源，我们的总辐射通量 ![\\Phi](https://www.zhihu.com/equation?tex=%5CPhi) 为 ![\\Phi=\\int_{s^{2}}^{}Id\\omega=4\\pi I](https://www.zhihu.com/equation?tex=%5CPhi%3D%5Cint_%7Bs%5E%7B2%7D%7D%5E%7B%7DId%5Comega%3D4%5Cpi+I) ,其中I是辐射强度，表示从点源发射的每一个固体角度的功率。\n\n那么，假定光以均匀的角度分布发射通量。由于总的辐射通量是完全不变的，那么随着半径R的增加，我们的辐照度 ![E](https://www.zhihu.com/equation?tex=E) 就会减少。由于等量的能量分布在越来越大的球体上，所以在越远的球面上就变得更暗。\n\n**6.辐射度是（ radiance ）“每单位投影面积、每单位立体角上的辐射通量”**\n\n辐射度是辐照度的立体角度密度。\n\n![L(P,w)=\\lim_{\\Delta\\rightarrow 0}{\\frac{dE_{w}(p)}{dw}}](https://www.zhihu.com/equation?tex=L%28P%2Cw%29%3D%5Clim_%7B%5CDelta%5Crightarrow+0%7D%7B%5Cfrac%7BdE_%7Bw%7D%28p%29%7D%7Bdw%7D%7D) ,其中 ![w](https://www.zhihu.com/equation?tex=w) 代表方向， ![E_{w}](https://www.zhihu.com/equation?tex=E_%7Bw%7D) 表示微分表面区域朝向该方向上的面。\n\n![dw=\\frac{dA}{r^{2}}](https://www.zhihu.com/equation?tex=dw%3D%5Cfrac%7BdA%7D%7Br%5E%7B2%7D%7D) \n\n![dA=r^{2}sin\\theta d\\theta d\\phi](https://www.zhihu.com/equation?tex=dA%3Dr%5E%7B2%7Dsin%5Ctheta+d%5Ctheta+d%5Cphi) \n\n换句话说，辐射度是沿着由原点p和方向 ![w](https://www.zhihu.com/equation?tex=w) 定义的射线的能量！\n\n**7.光谱辐射（Spectral Radiance）**\n\n综上所述，辐射是：单位时间、单位面积、单位固体角度的辐射能。\n\n但是，我们要真正得到光的完整描述，我们必须再分解一步：单位时间、单位面积、单位固体角度、**单位波长的辐射能量**。\n\n\n\n# 二.渲染方程\n\n这里我们暂且先直接给出我们的渲染方程（Kajiya)：\n\n![L_{0}(p,\\omega_{0})=L_{e}(p,\\omega_{0})+\\int_{\\xi^{2}}f_{r}(p,w_{i}\\rightarrow w_{0})L_{i}(p,\\omega_{i})cos\\theta d\\omega_{i}](https://www.zhihu.com/equation?tex=L_%7B0%7D%28p%2C%5Comega_%7B0%7D%29%3DL_%7Be%7D%28p%2C%5Comega_%7B0%7D%29%2B%5Cint_%7B%5Cxi%5E%7B2%7D%7Df_%7Br%7D%28p%2Cw_%7Bi%7D%5Crightarrow+w_%7B0%7D%29L_%7Bi%7D%28p%2C%5Comega_%7Bi%7D%29cos%5Ctheta+d%5Comega_%7Bi%7D) \n\n![L_{0}(p,\\omega_{0})](https://www.zhihu.com/equation?tex=L_%7B0%7D%28p%2C%5Comega_%7B0%7D%29) ：最后观察到的辐射度\n\n![p ](https://www.zhihu.com/equation?tex=p+) ：我们想要得到辐射度的这个点\n\n![\\omega_{0}](https://www.zhihu.com/equation?tex=%5Comega_%7B0%7D) :这个点的方向，法线\n\n![L_{e}(p,\\omega_{0})](https://www.zhihu.com/equation?tex=L_%7Be%7D%28p%2C%5Comega_%7B0%7D%29) ：出射辐射度\n\n![\\xi^{2}](https://www.zhihu.com/equation?tex=%5Cxi%5E%7B2%7D) :半球的各个方向\n\n![f_{r}](https://www.zhihu.com/equation?tex=f_%7Br%7D) :散射函数\n\n![L_{i}](https://www.zhihu.com/equation?tex=L_%7Bi%7D) :入射辐射度\n\n![\\omega_{i}](https://www.zhihu.com/equation?tex=%5Comega_%7Bi%7D) :入射方向\n\n![\\vartheta ](https://www.zhihu.com/equation?tex=%5Cvartheta+) ：传入方向与法线的夹角","tags":["ScienceVis"],"categories":["ScienceVis"]},{"title":"Hard 295 Find Median from Data Stream","url":"/2019/03/24/20190324/","content":"\n# 问题\n\n\n\nMedian is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\n\n中值是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值。中位数是两个中间值的均值。\n\n For example,  \n\n```\n[2,3,4]`, the median is `3\n```\n\n```\n[2,3]`, the median is `(2 + 3) / 2 = 2.5\n```\n\nDesign a data structure that supports the following two operations:\n\n- void addNum(int num) - Add a integer number from the data stream to the data structure.\n- double findMedian() - Return the median of all elements so far.\n\n**Example:**\n\n```\naddNum(1)\naddNum(2)\nfindMedian() -> 1.5\naddNum(3) \nfindMedian() -> 2\n```\n\n# 解\n\n根据评论区1位答案：\n\n- 把顺序数列一分为二，定义两个优先级队列small、large来分别保存更小的一半和更大的一半数字。\n\n- 在把数字加入队列的时候：\n\n  1、新来的数字先加入large的队列\n\n  2、把large队列的头部元素（也就是最小的数字）移除，取负号加入small队列。\n\n  【因为PriorityQueue的特点是自动按数字大小排序，large队列最后要取出最小的数时取头部数字即可，而small队列的头部数字不是我们想要的，我们想要small队列的最大值，因此在这里把small中的数都取负数，这样头部位置就是“-最大值”了】\n\n  3、检查如果small的size大于large的size，移除头部数字取负号加入large队列。即始终让中间值在large队列里，或者在small和large队各取一个数字➗2.\n\n  \n\n##### JAVA\n\n```\nclass MedianFinder {\n\n    /** initialize your data structure here. */\n    \n    Queue<Long> small = new PriorityQueue(),\n                        large = new PriorityQueue();\n\n    \n    \n    public void addNum(int num) {\n        large.add((long) num);\n        small.add(-large.poll());\n        if (large.size() < small.size())\n            large.add(-small.poll());\n\n    }\n    \n    public double findMedian() {\n        return large.size() > small.size()\n               ? large.peek()\n               : (large.peek() - small.peek()) / 2.0;\n\n    }\n}\n```\n\n\n\n**C++**\n\n```\nclass MedianFinder {\n    priority_queue<long> small, large;\npublic:\n\n    void addNum(int num) {\n        small.push(num);\n        large.push(-small.top());\n        small.pop();\n        if (small.size() < large.size()) {\n            small.push(-large.top());\n            large.pop();\n        }\n    }\n\n    double findMedian() {\n        return small.size() > large.size()\n               ? small.top()\n               : (small.top() - large.top()) / 2.0;\n    }\n};\n```\n\n\n\n**Python**\n\n```\nfrom heapq import *\n\nclass MedianFinder:\n\n    def __init__(self):\n        self.heaps = [], []\n\n    def addNum(self, num):\n        small, large = self.heaps\n        heappush(small, -heappushpop(large, num))\n        if len(large) < len(small):\n            heappush(large, -heappop(small))\n\n    def findMedian(self):\n        small, large = self.heaps\n        if len(large) > len(small):\n            return float(large[0])\n        return (large[0] - small[0]) / 2.0\n```\n\n\n\n# Java PriorityQueue class\n\n![Priority Queue](https://cdn2.howtodoinjava.com/wp-content/uploads/2018/10/priority-queue-pattern.png)\n\n### Java PriorityQueue Methods\n\nPriorityQueue class has below given important methods, you should know.\n\n- **boolean add(object)** : Inserts the specified element into this priority queue.\n- **boolean offer(object)** : Inserts the specified element into this priority queue.\n- **boolean remove(object)** : Removes a single instance of the specified element from this queue, if it is present.\n- **Object poll()** : Retrieves and removes the head of this queue, or returns null if this queue is empty.\n- **Object element()** : Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.\n- **Object peek()** : Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.\n- **void clear()** : Removes all of the elements from this priority queue.\n- **Comparator comparator()** : Returns the comparator used to order the elements in this queue, or null if this queue is sorted according to the natural ordering of its elements.\n- **boolean contains(Object o)** : Returns true if this queue contains the specified element.\n- **Iterator iterator()** : Returns an iterator over the elements in this queue.\n- **int size()** : Returns the number of elements in this queue.\n- **Object[] toArray()** : Returns an array containing all of the elements in this queue.\n\n本题中用到的知识：\n\n优先队列的头是基于自然排序或者Comparator排序的最小元素。如果有多个对象拥有同样的排序，那么就可能随机地取其中任意一个。当我们获取队列时，返回队列的头对象。\n\n优先队列的大小是不受限制的，但在创建时可以指定初始大小。当我们向优先队列增加元素的时候，队列大小会自动增加。","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Hard 239 Sliding Window Maximum","url":"/2019/03/20/20190321/","content":"\n\n\n<!-- more -->\n\n### ArrayDeque\n\n- 声明：Deque<Integer> q = new ArrayDeque<>()；\n- boolean offer(E e)\n  此方法将指定的元素，在此deque队列的末尾。\n\n- E peek()\n  此方法检索，但是**不**移除此deque队列表示的队列的**头部**，如果此deque队列为空，则返回null。\n- E peekLast()\n  此方法检索，但是**不**移除此deque队列的**最后**一个元素，如果此deque队列为空，则返回null。\n- E poll() \n  此方法检索并移除此deque队列表示的队列的**头部**，如果此deque队列为空，则返回null。\n- E pollLast()\n  此方法检索并移除此deque队列的**最后**一个元素，如果此deque队列为空，则返回nul。\n\n# 问题\n\nGiven an array *nums*, there is a sliding window of size *k* which is moving from the very left of the array to the very right. You can only see the *k* numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.\n\n  给定一个数组编号，有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口看到k个数字。每次滑动窗口右移一个位置。返回最大滑动窗口\n\n**Example:**\n\n  \n\n```\nInput: nums = [1,3,-1,-3,5,3,6,7], and k = 3\nOutput: [3,3,5,5,6,7] \nExplanation: \n\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n  \n\n**Note:** \n You may assume *k* is always valid, 1 ≤ k ≤ input array's size for non-empty array.\n\n# 解\n\n定义一个队列用来保存最大值们的序号。\n\n在遍历到每一个数组元素a[i]的时候：\n\n- 从队列头部开始轮询，有超过[i-k+1，i]范围的元素则删除，因为不在窗口的范围内。（因为加入的时候是从头加入，头部的序号最旧，最可能超出范围）\n- 从队列尾部开始轮询，检查若a[q.peekLast()] < a[i]，即序号指向的元素小于当前元素，说明已经不可能是最大值了，删除。（基于这种检查方法，越往尾部保存的序号，其指向的元素越小，故从尾部开始检查）\n- 把当前序号从尾部加入队列中。此时队列中没有超出窗口范围的序号，也没有指向的值更小的序号，留下的都是在窗口内且比当前指向值大的序号，并且最头部的序号，指向的元素最大。\n- 把该队列中序号指向的元素值加入结果中。因为i是从0开始的，往前k个算作窗口，故要从i=k-1开始才到第一个窗口的尾巴，进行保存到结果的操作。\n\n```\n public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums==null || k<=0){\n            return new int[0];\n        }\n        int n=nums.length;\n        int[] res=new int[n-k+1];\n        int j=0;\n        Deque<Integer> q=new ArrayDeque<>();\n        for(int i=0;i<n;i++){\n            while(!q.isEmpty() && q.peek()<i-k+1){\n                q.poll();\n            }\n            while(!q.isEmpty() && nums[q.peekLast()]<nums[i]){\n                q.pollLast();\n            }\n            q.offer(i);\n            if(i>k-2){\n                res[j++]=nums[q.peek()];\n            }\n        }\n        return res;\n    }\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Hard 352 Data Stream as Disjoint Intervals","url":"/2019/03/20/20190320/","content":"\nTreeMap\n\n<!-- more -->\n\nTreeMap知识：\n\nhttps://www.cnblogs.com/chenssy/p/3746600.html\n\n# 问题\n\nGiven a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals.\n\n  给出一个非负整数的输入流：a1, a2，……，将所看到的数字总结为不相交区间的列表。\n\nFor example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be:\n\n  例如，假设数据流中的整数是1、3、7、2、6、…，则总结如下:\n\n```\n[1, 1]\n[1, 1], [3, 3]\n[1, 1], [3, 3], [7, 7]\n[1, 3], [7, 7]\n[1, 3], [6, 7]\n```\n\n**Follow up:**\n What if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size?\n\n如果有很多合并，并且与数据流的大小相比，不相交间隔的数量很小，该怎么办?\n\n# 解\n\n- TreeMap中的key是区间的开始值，value是Interval类型的区间。\n\n- lowerKey（val）可以找到TreeMap中比val小的key中最大的key；higherKey（val）可找到TreeMap中比val大的key中最小的一个key。\n\n- 主要考虑四种情况：\n\n  前后都有邻接区间：\n\n  [1,1] [3,3] 输入2之后，区间会合并为一个[1,3]\n\n  前面有邻接区间，后面没有：\n\n  [3,3]...[7,7] 输入4之后，区间会扩展为[3,4]\n\n  后面有邻接区间，前面没有：\n\n  [3,3]...[7,7] 输入6后，区间会扩展为[6,7]\n\n  前后都没有邻接区间，直接插入：\n\n  [3,3]...[7,7] 输入5后，会增加区间[5,5]\n\n```\npublic class SummaryRanges {\n    TreeMap<Integer, Interval> tree;\n\n    public SummaryRanges() {\n        tree = new TreeMap<>();\n    }\n\n    public void addNum(int val) {\n        if(tree.containsKey(val)) return;\n        Integer l = tree.lowerKey(val);\n        Integer h = tree.higherKey(val);\n        if(l != null && h != null && tree.get(l).end + 1 == val && h == val + 1) {\n            tree.get(l).end = tree.get(h).end;\n            tree.remove(h);\n        } else if(l != null && tree.get(l).end + 1 >= val) {\n            tree.get(l).end = Math.max(tree.get(l).end, val);\n        } else if(h != null && h == val + 1) {\n            tree.put(val, new Interval(val, tree.get(h).end));\n            tree.remove(h);\n        } else {\n            tree.put(val, new Interval(val, val));\n        }\n    }\n\n    public List<Interval> getIntervals() {\n        return new ArrayList<>(tree.values());\n    }\n}\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Unity-Mecanim动画系统","url":"/2019/03/19/20190319/","content":"\n人形角色制作\n\n<!-- more -->\n\n### 1、创建和配置Avatar\n\n- 选择Project项目视图里的模型文件，在Inspector里单击AnimationType的下拉菜单，选择Humanoid，单击Apply按钮。\n\n- 一个Avatar被加入到该模型资源的子资源中。选择Avatar，单击ConfigureAvatar，会显示一个新的Avatar配置面板，包含了一个反映关键骨骼映射信息的视图。实线圆圈daib骨骼是必须的，虚线圆圈代表骨骼是可选的。\n\n- 用户提供的骨骼中应有所有必须匹配的骨骼，尽量通过骨骼代表的部位来给骨骼命名。\n\n- 若无法为模型找到合适的匹配，用户可通过以下办法进行手动配置：\n\n  单击Pose--SampleBindPose，得到模型的原始姿势。\n\n  单击Mapping--Automap，基于原始姿态创建一个骨骼映射。\n\n  单击Pose--Enforce T-Pose，强制模型贴近T形姿态，即动画的默认姿态。\n\n### 2、设置AnimatorController动画控制器\n\n创建一个AnimatorController，双击打开Animator动画视图，拖入动画，回到场景，把AnimatorController拖给模型的Animator组件的Controller。\n\n### 3、设置BlendTree动作混合树\n\n- 在Animator动画视图右键，create state--from new blend tree\n\n- 双击进入混合树视图，在Inspector检视视图中的Blend Type选择为2D Simple Directional.\n\n- 在Animator动画视图，选择Parameters标签，单击+按钮，创建两个参数分别名为InputH、InputV，用于在脚本中键盘控制模型移动。\n\n- 在BlendTree的Inspector视图中，在Motion选项里单击+按钮，并单击AddMotionField选项，创建4个参数，把四个向前向后向左向右的动画分别赋值给Motion里，并设置参数。这样当模型向四个方向移动的时候会自动调用对应的动画。\n\n- 返回到BasLayer层，在两个状态之间MakeTransition，从wait状态到walk状态连两根，设置的Conditions分别为InputV Greater 0.1和InputV Less -0.1；从walk状态到wait状态连一根，Conditions为InputV Less 0.1 且 InputV Greater -0.1。\n\n- 给模型添加Rigidbody组件，去掉Use Gravity勾选，并给Freeze Rotation三个轴打勾。写一个C#脚本，并拖给模型。\n\n- 可以控制模型的行走了。\n\n- C#脚本为：\n\n  ```\n  public class AniControl : MonoBehaviour {\n      public Animator anim;\n      private float inputH;\n      private float inputV;\n  \n  \t// Use this for initialization\n  \tvoid Start () {\n          anim = GetComponent<Animator>();\n  \t\t\n  \t}\n  \t\n  \t// Update is called once per frame\n  \tvoid Update () {\n          inputH = Input.GetAxis(\"Horizontal\");\n          inputV = Input.GetAxis(\"Vertical\");\n          anim.SetFloat(\"InputH\", inputH);\n          anim.SetFloat(\"InputV\", inputV);\n          float moveX = inputH * 0.2f * Time.deltaTime;\n          float moveZ = inputV * 0.5f * Time.deltaTime;\n          transform.Translate(moveX, 0, moveZ);\n      }\n  }\n  ```\n\n  ","tags":["Unity"],"categories":["Unity"]},{"title":"Medium 56 Merge Intervals","url":"/2019/03/18/20190318/","content":"\n合并区间\n\n<!-- more -->\n\n# 问题\n\nGiven a collection of intervals, merge all overlapping intervals.\n\n**Example 1:**\n\n```\nInput: [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].\n```\n\n**Example 2:**\n\n```\nInput: [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n```\n\n# 解\n\n比57题简单一点，没有额外插入的区间，只检查相邻区间即可。\n\n- 若没有区间或只有一个区间，则不存在合并，直接返回原list即可。\n\n- 使用匿名比较器从起点开始排序\n\n  intervals.sort((i1, i2) -> Integer.compare(i1.start, i2.start));\n\n- 比较每一个区间的起点和上一个区间的终点。如果interval.start <= end，更新合并区间的终点。\n\n- 直到遍历到的区间起点大于上一个区间的终点时，合并结束。\n\n- 把区间加入结果，更新起点和终点为当前区间的起点终点，继续遍历。\n\n  ```\n    public List<Interval> merge(List<Interval> intervals) {\n          List<Interval> res=new LinkedList<>();\n          if(intervals.size()<2){\n              return intervals;\n          }\n          int i=1;\n          intervals.sort((i1, i2) -> Integer.compare(i1.start, i2.start));\n          int start=intervals.get(0).start;\n          int end=intervals.get(0).end;\n          while(i<intervals.size()){\n              if(end >= intervals.get(i).start){\n                     start= Math.min(start,intervals.get(i).start);\n                     end= Math.max(end,intervals.get(i).end);\n              }else{\n                  res.add(new Interval(start,end));\n                  start=intervals.get(i).start;\n                  end=intervals.get(i).end;\n              }\n              i++;\n          }\n          res.add(new Interval(start,end));\n          return res;\n      }\n  ```\n\n  ","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Hard 57 Insert Interval","url":"/2019/03/17/20190317/","content":"\n区间插入\n\n<!-- more -->\n\n# 问题\n\nGiven a set of *non-overlapping* intervals, insert a new interval into the intervals (merge if necessary).\n\nYou may assume that the intervals were initially sorted according to their start times.\n\n给定一组不重叠的区间，在区间中插入一个新的区间(如果需要合并)。您可以假设这些区间最初是根据它们的开始时间排序的。\n\n**Example 1:**\n\n```\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n```\n\n**Example 2:**\n\n```\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n```\n\n# 解\n\n1. 先把所有在插入区间之前的区间加入结果List里面。\n\n   检查i不可超出范围，并且区间的end小于插入区间的start的话，说明这个区间在插入区间之前，可以直接加到结果里面。\n\n   while (i < intervals.size() && intervals.get(i).end < newInterval.start)\n           result.add(intervals.get(i++));\n\n2. 处理和插入区间有交集的区间们，若是多个则合并相交区间成为新区间。\n\n   检查i不可超出范围，并且区间的start小于等于插入区间的end的话，说明当前这个区间和插入区间有交集。根据此区间的start和end修改插入区间的start和end。\n\n   newInterval = new Interval( \n                   Math.min(newInterval.start, intervals.get(i).start),\n                   Math.max(newInterval.end, intervals.get(i).end))；\n\n   检查完所有和插入区间有交集的区间之后，把新的插曲区间加入结果List中。\n\n   把剩下的区间加入结果List。\n\n3. JAVA代码\n\n```\npublic List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n    List<Interval> result = new LinkedList<>();\n    int i = 0;\n    \n    while (i < intervals.size() && intervals.get(i).end < newInterval.start)\n        result.add(intervals.get(i++));\n    \n    while (i < intervals.size() && intervals.get(i).start <= newInterval.end) {\n        newInterval = new Interval( \n                Math.min(newInterval.start, intervals.get(i).start),\n                Math.max(newInterval.end, intervals.get(i).end));\n        i++;\n    }\n    result.add(newInterval); \n    \n    while (i < intervals.size()) result.add(intervals.get(i++)); \n    return result;\n}\n```\n\n另一种写法，遍历每个区间的时候检查：\n\n如果这个区间在插入区间之后，则把插入区间加入结果，把此区间赋给插入区间，检查下一个区间。其实就是把区间一个个加入到结果里了。\n\n如果这个区间在插入区间之前，则把这个区间加入结果，插入区间不变，再检查下一个区间和插入区间的关系。\n\n如果不是以上两种情况，则说明有交集，比较之后重新设定插入区间的start和end。\n\n遍历所有区间之后，把插入区间加入结果。\n\n```\npublic List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n        List<Interval> list = new LinkedList<>();\n        Interval pre = newInterval;\n        for(Interval curr: intervals){\n            if(pre.end < curr.start) {\n                list.add(pre);\n                pre = curr;\n            } else if (curr.end < pre.start) {   //Here is the difference.\n                list.add(curr);\n            }\n            else {\n                pre.start = Math.min(pre.start, curr.start);\n                pre.end = Math.max(pre.end, curr.end);\n            }\n        }\n        list.add(pre);\n        return list;\n    }\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Medium 289 Game of Life","url":"/2019/03/15/20190315/","content":"\n游戏人生\n<!-- more -->\n\n# 问题\n\nAccording to the Wikipedia's article: \"The **Game of Life**, also known simply as **Life**, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\n\n根据维基百科的文章:“生命的游戏，也就是简单的生命，是由英国数学家约翰·霍顿·康威在1970年发明的一种细胞自动机。”  \n\nGiven a *board* with *m* by *n* cells, each cell has an initial state *live* (1) or *dead* (0). Each cell interacts with its eight neighbors(horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\n给定一个由m×n个单元格组成的board，每个单元格都有一个初始状态live(1)或dead(0)。  每个单元格使用以下4条规则与它的8个相邻单元格(水平、垂直、对角线)交互(摘自上面Wikipedia文章):\n\n1. Any live cell with fewer than two live neighbors dies, as if caused by under-population.\n2. Any live cell with two or three live neighbors lives on to the next generation.\n3. Any live cell with more than three live neighbors dies, as if by over-population..\n4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\n任何活的细胞如果少于两个活的邻居，就会死亡，好像是由于人口不足造成的。\n\n任何有两个或三个邻居的活细胞都能活到下一代。\n\n任何有三个以上邻居的活细胞都会死亡，就好像是由于人口过剩。\n\n任何有三个活邻居的死细胞都会变成活细胞，就像通过繁殖一样。\n\nWrite a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.\n\n 编写一个函数来计算给定当前状态的下一个状态(在一次更新之后)。下一个状态是通过将上述规则同时应用于当前状态中的每个细胞而创建的，此时出生和死亡同时发生。\n\n**Example:**\n\n```\nInput: \n[\n  [0,1,0],\n  [0,0,1],\n  [1,1,1],\n  [0,0,0]\n]\nOutput: \n[\n  [0,0,0],\n  [1,0,1],\n  [0,1,1],\n  [0,1,0]\n]\n```\n\n  \n\n**Follow up**:\n\n1. Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.\n\n   你能当场解决吗?请记住，board 需要同时更新:您不能先更新某些单元格，然后使用它们的更新值来更新其他单元格。\n\n2. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\n\n   在这个问题中，我们使用2D数组来表示board 。从理论上讲，board 是无限的，当有源区域侵犯阵列边界时，会产生问题。你将如何解决这些问题?\n\n# 解\n\n来自评论区https://leetcode.com/problems/game-of-life/discuss/73223/Easiest-JAVA-solution-with-explanation\n\n为了解决这个问题，使用2bits来存储两个状态：未来和当前。\n\n[2nd bit, 1st bit] = [next state, current state]\n\n- 00  dead (next) <- dead (current)\n- 01  dead (next) <- live (current)  \n- 10  live (next) <- dead (current)  \n- 11  live (next) <- live (current) \n\n初始化阶段，每个cell都是 00 或 01，把未来2nd都初始化为0.\n\n未来状态2nd由当前决定。\n\n所有cells同时从1st向2nd位置变化。\n\n因此要计算每个cell的邻居的存活数lives，来得到2nd的值。\n\n得到当前状态的方法：按位与 &1（二进制 & 01\n\n转变到2nd位的方法：左移一位 >>1\n\n邻居livs数量对2nd位的影响：\n\n1. 1st=1：lives=2 or lives=3   01->11->3\n2. 1st=1：lives<2 or lives>3   01->01->1\n3. 1st=0：lives=3   00->10->2\n\n得到邻居lives的方法：\n\n1. 给定当前cell在第i行第j列（从0开始），一共m行n列。\n2. 对i-1行到i+1行遍历，保证i+1不大于m-1行。\n3. 对j-1列到j+1列遍历，保证j+1不大于n-1列。\n4. 取遍历到的cell的当前状态，也就是1st位置的值，也就是 &1操作。\n5. 把每个cell的状态相加（1为活0为死，故相加结果就是活的总数）\n6. 最后把给定cell元素的状态减掉（也就是不能算自己为自己的邻居）\n\n#### JAVA代码\n\n```\nclass Solution {\n    public void gameOfLife(int[][] board) {\n        if(board == null||board.length == 0)return ;\n        int m = board.length, n = board[0].length;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                int lives=liveNeighbors(board,m,n,i,j);\n                if(board[i][j]==0 && lives==3){\n                    board[i][j]=2;\n                }\n                else if(board[i][j]==1 && (lives==2||lives==3)){\n                    board[i][j]=3;\n                }\n                else if(board[i][j]==1 && (lives>3 || lives<2)){\n                    board[i][j]=1;\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                 board[i][j] >>= 1; \n            }\n        }\n    }\n        public int liveNeighbors(int[][] board, int m, int n, int i, int j) {\n               int lives = 0;\n               for (int x = Math.max(i - 1, 0); x <= Math.min(i + 1, m - 1); x++) {\n                    for (int y = Math.max(j - 1, 0); y <= Math.min(j + 1, n - 1); y++) {\n                         lives += board[x][y] & 1;\n                     }\n               }\n               lives -= board[i][j] & 1;\n               return lives;\n\n        }\n}\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Medium 287 Find the Duplicate Number","url":"/2019/03/13/20190313/","content":"\nleetcode第287题\n<!-- more -->\n\n# 问题\n\nGiven an array *nums* containing *n* + 1 integers where each integer is between 1 and *n* (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\n\n  \n\n**Example 1:**\n\n  \n\n```\nInput: [1,3,4,2,2]\nOutput: 2\n```\n\n  \n\n**Example 2:**\n\n  \n\n```\nInput: [3,1,3,4,2]\nOutput: 3\n```\n\n  \n\n**Note:**\n\n  \n\n1. You **must not** modify the array (assume the array is read only).\n2. You must use only constant, *O*(1) extra space.\n3. Your runtime complexity should be less than *O*(*n*2).\n4. There is only one duplicate number in the array, but it could be repeated more than once.\n\n# 解\n\n```\npublic int findDuplicate(int[] nums) {\n    int n = nums.length;\n    int slow = n;\n    int fast = n;\n    do{\n        slow = nums[slow-1];\n        fast = nums[nums[fast-1]-1];\n    }while(slow != fast);\n    slow = n;\n    while(slow != fast){\n        slow = nums[slow-1];\n        fast = nums[fast-1];\n    }\n    return slow;\n\n```\n\n具体没咋看明白。。\n\nsuppose the array is\n\n \n\n> index: 0 1 2 3 4 5\n>\n>  \n>\n> value: 2 5 1 1 4 3\n>\n>  \n\n \n\n\n\nfirst subtract 1 from each element in the array, so it is much easy to understand.\n use the value as pointer. the array becomes:\n\n \n\n> index: 0 1 2 3 4 5\n>\n>  \n>\n> value: 1 4 0 0 3 2\n>\n>  \n\n \n\n\n\n![enter image description here](http://cyukang.com/images/cycle3.png)\n\n \n\nSecond if the array is\n\n \n\n> index: 0 1 2 3 4 5\n>\n>  \n>\n> value: 0 1 2 4 2 3\n>\n>  \n\n \n\n\n\nwe must choose the last element as the head of the linked list. If we choose 0, we can not detect the cycle.\n\n \n\nNow the problem is the same as find the cycle in linkedlist!\n\n \n\n```\npublic int findDuplicate(int[] nums) {\n    int n = nums.length;\n    for(int i=0;i<nums.length;i++) nums[i]--;\n    int slow = n-1;\n    int fast = n-1;\n    do{\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    }while(slow != fast);\n    slow = n-1;\n    while(slow != fast){\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n    return slow+1;\n}\n```","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Hard 164 Maximum Gap//Bucket Sort","url":"/2019/03/12/20190312/","content":"\n找到相邻顺序列的最大差\n\n<!-- more -->\n\n相关JAVA基础知识：\n\n**Java—ceil() 方法**http://www.runoob.com/java/number-ceil.html\n\n**Java—Sort排序**https://blog.csdn.net/whp1473/article/details/79678974\n\n\n\n# 问题\n\nGiven an unsorted array, find the maximum difference between the successive elements in its sorted form.\n\nReturn 0 if the array contains less than 2 elements.\n\n**Example 1:**\n\n```\nInput: [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either\n             (3,6) or (6,9) has the maximum difference 3.\n```\n\n**Example 2:**\n\n```\nInput: [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0.\n```\n\n**Note:**\n\n- You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.\n- Try to solve it in linear time/space.\n\n# 解\n\n### 个人的笨方法：\n\n```\n public int maximumGap(int[] nums) {\n        if(nums.length<2){\n            return 0;\n        }\n        Arrays.sort(nums);\n        int res=0;\n        for(int i=0;i<nums.length-1;i++){\n            res=(res<(nums[i+1]-nums[i]))?nums[i+1]-nums[i]:res;\n        }\n        return res;\n    }\n```\n\n### Bucket Sort：\n\n1、数组长度为N，已知数组里的min和max，那么最大连续差最小是gap=ceiling[(***max*** - ***min*** ) / (N - 1)]【ceil() 方法可对一个数进行上舍入】。\n\n2、bucket方法是把数组里的除了min和max的所有n-2个数字放入n-1个篮子里，篮子包含的数字范围差是gap，假如min=1且gap=2，那么[1,3)是一个篮子、[3,5)是一个篮子，以此类推。那么设篮子序号为k，则第k个篮子要放入[ min+(k-1)gap,min+k*gap )范围内的数字。\n\n3、这个方法并不需要真的定义k个数组，只要保存每个篮子的最大值和最小值，（因为gap为最小的连续差，说明最后得到的结果一定大于等于这个篮子的范围，大于这个范围的话一定要篮子之间的数字相减），只需要把上一个有数字放入的篮子的最小值和下一个有数字放入的篮子的最大值相减作差，得到的新的gap，和原来的gap比较并保存最大值。\n\n4、因此这个方法需要定义两个数组，分别存放每个篮子的最小值和最大值。\n\n```\nint[] bucketsMIN = new int[num.length - 1]; \nint[] bucketsMAX = new int[num.length - 1]; \n```\n\n第几个篮子，即在这两个数组里的正确位置：\n\n```\nint idx = (i - min) / gap;\n```\n\n则存放每个篮子最大值和最小值的过程：\n\n```\nfor (int i:num) {\n        if (i == min || i == max)\n            continue;\n        int idx = (i - min) / gap; \n        bucketsMIN[idx] = Math.min(i, bucketsMIN[idx]);\n        bucketsMAX[idx] = Math.max(i, bucketsMAX[idx]);\n    }\n```\n\n5、定义被除数初始值为min：\n\n```\nint previous = min;\n```\n\n每次计算完新的差后更新：\n\n```\nprevious = bucketsMAX[i];\n```\n\n遍历两个数组中存放的篮子们的最大值最小值，若篮子为空则跳过，看下一个。用当前篮子的最小值减去上一个保存的篮子的最大值得到新的差，再和原来的差比较：\n\n```\nmaxGap = Math.max(maxGap, bucketsMIN[i] - previous);\n```\n\n最后还要让max和上一个保存的篮子最大值相减，因为在把数放入篮子们也就是计入两个数组的过程中，没有考虑min和max。\n\n```\nmaxGap = Math.max(maxGap, max - previous);\n```\n\n\n\n#### 完整代码:\n\n```\npublic class Solution {\npublic int maximumGap(int[] num) {\n    if (num == null || num.length < 2)\n        return 0;\n    // get the max and min value of the array\n    int min = num[0];\n    int max = num[0];\n    for (int i:num) {\n        min = Math.min(min, i);\n        max = Math.max(max, i);\n    }\n    // the minimum possibale gap, ceiling of the integer division\n    int gap = (int)Math.ceil((double)(max - min)/(num.length - 1));\n    int[] bucketsMIN = new int[num.length - 1]; // store the min value in that bucket\n    int[] bucketsMAX = new int[num.length - 1]; // store the max value in that bucket\n    Arrays.fill(bucketsMIN, Integer.MAX_VALUE);\n    Arrays.fill(bucketsMAX, Integer.MIN_VALUE);\n    // put numbers into buckets\n    for (int i:num) {\n        if (i == min || i == max)\n            continue;\n        int idx = (i - min) / gap; // index of the right position in the buckets\n        bucketsMIN[idx] = Math.min(i, bucketsMIN[idx]);\n        bucketsMAX[idx] = Math.max(i, bucketsMAX[idx]);\n    }\n    // scan the buckets for the max gap\n    int maxGap = Integer.MIN_VALUE;\n    int previous = min;\n    for (int i = 0; i < num.length - 1; i++) {\n        if (bucketsMIN[i] == Integer.MAX_VALUE && bucketsMAX[i] == Integer.MIN_VALUE)\n            // empty bucket\n            continue;\n        // min value minus the previous value is the current gap\n        maxGap = Math.max(maxGap, bucketsMIN[i] - previous);\n        // update previous bucket value\n        previous = bucketsMAX[i];\n    }\n    maxGap = Math.max(maxGap, max - previous); // updata the final max value gap\n    return maxGap;\n}\n```","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"unity二进制存档和读档","url":"/2019/03/11/20190311/","content":"\n源自siki学院里的一个读存档例子\n\n<!-- more -->\n\n这个游戏是一个九宫格打怪物的游戏，其中，九个格子分别存以0~8的Target Positions，每个格子有当前激活的0~3的怪物类型Monster Types 。\n\n#### 1、新建一个save类来保存序列\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n[System.Serializable]\npublic class Save{\n\n    public List<int> livingTargetPositions = new List<int>();\n    public List<int> livingMonsterTypes = new List<int>();\n\n    public int shootNum = 0;\n    public int score = 0;\n}\n```\n\n#### 2、在GameManager.cs里实例化Save对象，并存储当前游戏状态信息。\n\n```\n private Save CreateSaveGO()\n    {\n        //新建Save对象\n        Save save = new Save();\n        //遍历所有的target\n        //如果其中有处于激活状态的怪物，就把该target的位置信息和激活状态的怪物的类型添加到List中\n        foreach (GameObject targetGO in targetGOs)\n        {\n            TargetManager targetManager = targetGO.GetComponent<TargetManager>();\n            if (targetManager.activeMonster != null)\n            {\n                save.livingTargetPositions.Add(targetManager.targetPosition);\n                int type = targetManager.activeMonster.GetComponent<MonsterManager>().monsterType;\n                save.livingMonsterTypes.Add(type);\n            }\n        }\n        //把shootNum和score保存在Save对象中\n        save.shootNum = UIManager._instance.shootNum;\n        save.score = UIManager._instance.score;\n        //返回该Save对象\n        return save;\n    }\n```\n\n#### 3、二进制存档\n\n需要的命名空间\n\n```\nusing UnityEngine;\nusing System.IO;\nusing System.Runtime.Serialization.Formatters.Binary;\n```\n\n\n\n```\n private void SaveByBin()\n    {\n        //序列化过程（将Save对象转换为字节流）\n        //创建Save对象并保存当前游戏状态\n        Save save = CreateSaveGO();\n        //创建一个二进制格式化程序\n        BinaryFormatter bf = new BinaryFormatter();\n        //创建一个文件流\n        FileStream fileStream = File.Create(Application.dataPath + \"/StreamingFile\" + \"/byBin.txt\");\n        //用二进制格式化程序的序列化方法来序列化Save对象,参数：创建的文件流和需要序列化的对象\n        bf.Serialize(fileStream, save);\n        //关闭流\n        fileStream.Close();\n\n        //如果文件存在，则显示保存成功\n        if (File.Exists(Application.dataPath + \"/StreamingFile\" + \"/byBin.txt\"))\n        {\n            UIManager._instance.ShowMessage(\"保存成功\");\n        }\n    }\n```\n\n1. 创建一个二进制格式化程序\n           BinaryFormatter bf = new BinaryFormatter();\n2. 创建一个文件流\n           FileStream fileStream = File.Create(Application.dataPath + \"/StreamingFile\" + \"/byBin.txt\");\n3. 用二进制格式化程序的序列化方法来序列化Save对象,参数：创建的文件流和需要序列化的对象\n           bf.Serialize(fileStream, save);\n4. 关闭流\n           fileStream.Close();\n\n#### 4、二进制读档\n\n```\nprivate void LoadByBin()\n    {\n        if(File.Exists(Application.dataPath + \"/StreamingFile\" + \"/byBin.txt\"))\n        {\n            //反序列化过程\n            //创建一个二进制格式化程序\n            BinaryFormatter bf = new BinaryFormatter();\n            //打开一个文件流\n            FileStream fileStream = File.Open(Application.dataPath + \"/StreamingFile\" + \"/byBin.txt\", FileMode.Open);\n            //调用格式化程序的反序列化方法，将文件流转换为一个Save对象\n            Save save = (Save)bf.Deserialize(fileStream);\n            //关闭文件流\n            fileStream.Close();\n\n            SetGame(save);\n            UIManager._instance.ShowMessage(\"\");\n\n        }\n        else\n        {\n            UIManager._instance.ShowMessage(\"存档文件不存在\");\n        }\n    }\n```\n\n1. 创建一个二进制格式化程序\n               BinaryFormatter bf = new BinaryFormatter();\n2. 打开一个文件流\n               FileStream fileStream = File.Open(Application.dataPath + \"/StreamingFile\" + \"/byBin.txt\", FileMode.Open);\n3. 调用格式化程序的反序列化方法，将文件流转换为一个Save对象\n               Save save = (Save)bf.Deserialize(fileStream);\n4. 关闭文件流\n               fileStream.Close();\n\n#### 5、通过读档信息重置我们的游戏状态（分数、激活状态的怪物）\n\n```\nprivate void SetGame(Save save)\n    {\n        //先将所有的targrt里面的怪物清空，并重置所有的计时\n        foreach(GameObject targetGO in targetGOs)\n        {\n            targetGO.GetComponent<TargetManager>().UpdateMonsters();\n        }\n        //通过反序列化得到的Save对象中存储的信息，激活指定的怪物\n        for(int i = 0; i < save.livingTargetPositions.Count; i++)\n        {\n            int position = save.livingTargetPositions[i];\n            int type = save.livingMonsterTypes[i];\n            targetGOs[position].GetComponent<TargetManager>().ActivateMonsterByType(type);\n        }\n\n        //更新UI显示\n        UIManager._instance.shootNum = save.shootNum;\n        UIManager._instance.score = save.score;\n        //调整为未暂停状态\n        UnPause();\n    }\n```\n\n","tags":["Unity"],"categories":["Unity"]},{"title":"unity JSON存档和读档","url":"/2019/03/10/20190310/","content":"\n源自siki学院里的一个读存档例子\n\n<!-- more -->\n\n这个游戏是一个九宫格打怪物的游戏，其中，九个格子分别存以0~8的Target Positions，每个格子有当前激活的0~3的怪物类型Monster Types 。\n\n#### 1、新建一个save类来保存序列\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n[System.Serializable]\npublic class Save{\n\n    public List<int> livingTargetPositions = new List<int>();\n    public List<int> livingMonsterTypes = new List<int>();\n\n    public int shootNum = 0;\n    public int score = 0;\n}\n```\n\n#### 2、在GameManager.cs里实例化Save对象，并存储当前游戏状态信息。\n\n```\n private Save CreateSaveGO()\n    {\n        //新建Save对象\n        Save save = new Save();\n        //遍历所有的target\n        //如果其中有处于激活状态的怪物，就把该target的位置信息和激活状态的怪物的类型添加到List中\n        foreach (GameObject targetGO in targetGOs)\n        {\n            TargetManager targetManager = targetGO.GetComponent<TargetManager>();\n            if (targetManager.activeMonster != null)\n            {\n                save.livingTargetPositions.Add(targetManager.targetPosition);\n                int type = targetManager.activeMonster.GetComponent<MonsterManager>().monsterType;\n                save.livingMonsterTypes.Add(type);\n            }\n        }\n        //把shootNum和score保存在Save对象中\n        save.shootNum = UIManager._instance.shootNum;\n        save.score = UIManager._instance.score;\n        //返回该Save对象\n        return save;\n    }\n```\n\n#### 3、JSON存档\n\n需要的命名空间\n\n```\nusing UnityEngine;\nusing System.IO;\nusing LitJson;\n```\n\n\n\n```\nprivate void SaveByJson()\n    {\n        Save save = CreateSaveGO();\n        string filePath = Application.dataPath + \"/StreamingFile\" + \"/byJson.json\";\n        //利用JsonMapper将save对象转换为Json格式的字符串\n        string saveJsonStr = JsonMapper.ToJson(save);\n        //将这个字符串写入到文件中\n        //创建一个StreamWriter，并将字符串写入文件中\n        StreamWriter sw = new StreamWriter(filePath);\n        sw.Write(saveJsonStr);\n        //关闭StreamWriter\n        sw.Close();\n\n        UIManager._instance.ShowMessage(\"保存成功\");\n    }\n```\n\n1. 写好存储地址：（斜杠不能丢下\n   string filePath = Application.dataPath + \"/StreamingFile\" + \"/byJson.json\";\n2. 将其他类型的对象转换为Json格式的字符串：\n   string saveJsonStr = JsonMapper.ToJson(save);\n3. 创建一个StreamWriter，并将字符串写入文件中\n   StreamWriter sw = new StreamWriter(filePath);\n   sw.Write(saveJsonStr);\n4. 关闭StreamWriter\n   sw.Close();\n\n#### 4、二进制读档\n\n```\nprivate void LoadByJson()\n    { \n        string filePath = Application.dataPath + \"/StreamingFile\" + \"/byJson.json\";\n        if(File.Exists(filePath))\n        {\n            //创建一个StreamReader，用来读取流\n            StreamReader sr = new StreamReader(filePath);\n            //将读取到的流赋值给jsonStr\n            string jsonStr = sr.ReadToEnd();\n            //关闭\n            sr.Close();\n\n            //将字符串jsonStr转换为Save对象\n            Save save = JsonMapper.ToObject<Save>(jsonStr);\n            SetGame(save);\n            UIManager._instance.ShowMessage(\"\");\n        }\n        else\n        {\n            UIManager._instance.ShowMessage(\"存档文件不存在\");\n        }\n    }\n```\n\n1. 创建一个StreamReader，用来读取流\n   StreamReader sr = new StreamReader(filePath);\n2. 将读取到的流赋值给jsonStr\n   string jsonStr = sr.ReadToEnd();\n3. 关闭 sr.Close();\n4. 将字符串jsonStr转换为其它对象\n    Save save = JsonMapper.ToObject<Save>(jsonStr);\n\n#### 5、通过读档信息重置我们的游戏状态（分数、激活状态的怪物）\n\n```\nprivate void SetGame(Save save)\n    {\n        //先将所有的targrt里面的怪物清空，并重置所有的计时\n        foreach(GameObject targetGO in targetGOs)\n        {\n            targetGO.GetComponent<TargetManager>().UpdateMonsters();\n        }\n        //通过反序列化得到的Save对象中存储的信息，激活指定的怪物\n        for(int i = 0; i < save.livingTargetPositions.Count; i++)\n        {\n            int position = save.livingTargetPositions[i];\n            int type = save.livingMonsterTypes[i];\n            targetGOs[position].GetComponent<TargetManager>().ActivateMonsterByType(type);\n        }\n\n        //更新UI显示\n        UIManager._instance.shootNum = save.shootNum;\n        UIManager._instance.score = save.score;\n        //调整为未暂停状态\n        UnPause();\n    }\n```\n\n","tags":["Unity"],"categories":["Unity"]},{"title":"unity XML存档和读档","url":"/2019/03/09/20190309/","content":"\n源自siki学院里的一个读存档例子\n\n<!-- more -->\n\n这个游戏是一个九宫格打怪物的游戏，其中，九个格子分别存以0~8的Target Positions，每个格子有当前激活的0~3的怪物类型Monster Types 。\n\n#### 1、新建一个save类来保存序列\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n[System.Serializable]\npublic class Save{\n\n    public List<int> livingTargetPositions = new List<int>();\n    public List<int> livingMonsterTypes = new List<int>();\n\n    public int shootNum = 0;\n    public int score = 0;\n}\n```\n\n#### 2、在GameManager.cs里实例化Save对象，并存储当前游戏状态信息。\n\n```\n private Save CreateSaveGO()\n    {\n        //新建Save对象\n        Save save = new Save();\n        //遍历所有的target\n        //如果其中有处于激活状态的怪物，就把该target的位置信息和激活状态的怪物的类型添加到List中\n        foreach (GameObject targetGO in targetGOs)\n        {\n            TargetManager targetManager = targetGO.GetComponent<TargetManager>();\n            if (targetManager.activeMonster != null)\n            {\n                save.livingTargetPositions.Add(targetManager.targetPosition);\n                int type = targetManager.activeMonster.GetComponent<MonsterManager>().monsterType;\n                save.livingMonsterTypes.Add(type);\n            }\n        }\n        //把shootNum和score保存在Save对象中\n        save.shootNum = UIManager._instance.shootNum;\n        save.score = UIManager._instance.score;\n        //返回该Save对象\n        return save;\n    }\n```\n\n#### 3、XML存档\n\n需要的命名空间\n\n```\nusing UnityEngine;\nusing System.IO;\nusing System.Xml;\n```\n\n```\n private void SaveByXml()\n    {\n        Save save = CreateSaveGO();\n        //创建XML文件的存储路径\n        string filePath = Application.dataPath + \"/StreamingFile\" + \"/byXML.txt\";\n        //创建XML文档\n        XmlDocument xmlDoc = new XmlDocument();\n        //创建根节点，即最上层节点\n        XmlElement root = xmlDoc.CreateElement(\"save\");\n        //设置根节点中的值\n        root.SetAttribute(\"name\", \"saveFile1\");\n\n        //创建XmlElement\n        XmlElement target;\n        XmlElement targetPosition;\n        XmlElement monsterType;\n\n        //遍历save中存储的数据，将数据转换成XML格式\n        for(int i = 0; i < save.livingTargetPositions.Count; i++)\n        {\n            target = xmlDoc.CreateElement(\"target\");\n            targetPosition = xmlDoc.CreateElement(\"targetPosition\");\n            //设置InnerText值\n            targetPosition.InnerText = save.livingTargetPositions[i].ToString();\n            monsterType = xmlDoc.CreateElement(\"monsterType\");\n            monsterType.InnerText = save.livingMonsterTypes[i].ToString();\n\n            //设置节点间的层级关系 root -- target -- (targetPosition, monsterType)\n            target.AppendChild(targetPosition);\n            target.AppendChild(monsterType);\n            root.AppendChild(target);\n        }\n\n        //设置射击数和分数节点并设置层级关系  xmlDoc -- root --(target-- (targetPosition, monsterType), shootNum, score)\n        XmlElement shootNum = xmlDoc.CreateElement(\"shootNum\");\n        shootNum.InnerText = save.shootNum.ToString();\n        root.AppendChild(shootNum);\n\n        XmlElement score = xmlDoc.CreateElement(\"score\");\n        score.InnerText = save.score.ToString();\n        root.AppendChild(score);\n\n        xmlDoc.AppendChild(root);\n        xmlDoc.Save(filePath);\n\n        if(File.Exists(Application.dataPath + \"/StreamingFile\" + \"/byXML.txt\"))\n        {\n            UIManager._instance.ShowMessage(\"保存成功\");\n        }\n    }\n```\n\n1. 创建XML文档 XmlDocument xmlDoc = new XmlDocument();\n\n2. 创建名为save的根节点，即最上层节点\n           XmlElement root = xmlDoc.CreateElement(\"save\");\n\n3.  设置根节点中的值name=saveFile1\n           root.SetAttribute(\"name\", \"saveFile1\");\n\n4.  创建XmlElement子结点\n           XmlElement target; [ target = xmlDoc.CreateElement(\"target\"); ]\n           XmlElement targetPosition;\n           XmlElement monsterType;\n\n5. 为子结点们加入内容，例如:  \n               targetPosition = xmlDoc.CreateElement(\"targetPosition\");\n               targetPosition.InnerText = save.livingTargetPositions[i].ToString();\n\n6. 设置结点间层级关系： target.AppendChild(targetPosition);\n\n7. 设置根节点层级关系并保存\n\n   ​        root.AppendChild(target);\n\n   ​        xmlDoc.AppendChild(root);\n   ​        xmlDoc.Save(filePath);\n\n   \n\n#### 4、二进制读档\n\n```\nprivate void LoadByXml()\n    {\n        string filePath = Application.dataPath + \"/StreamingFile\" + \"/byXML.txt\";\n        if(File.Exists(filePath))\n        {\n            Save save = new Save();\n            //加载XML文档\n            XmlDocument xmlDoc = new XmlDocument();\n            xmlDoc.Load(filePath);\n\n            //通过节点名称来获取元素，结果为XmlNodeList类型\n            XmlNodeList targets = xmlDoc.GetElementsByTagName(\"target\");\n            //遍历所有的target节点，并获得子节点和子节点的InnerText\n            if(targets.Count != 0)\n            {\n                foreach(XmlNode target in targets)\n                {\n                    XmlNode targetPosition = target.ChildNodes[0];\n                    int targetPositionIndex = int.Parse(targetPosition.InnerText);\n                    //把得到的值存储到save中\n                    save.livingTargetPositions.Add(targetPositionIndex);\n\n                    XmlNode monsterType = target.ChildNodes[1];\n                    int monsterTypeIndex = int.Parse(monsterType.InnerText);\n                    save.livingMonsterTypes.Add(monsterTypeIndex);\n                }\n            }\n            \n            //得到存储的射击数和分数\n            XmlNodeList shootNum = xmlDoc.GetElementsByTagName(\"shootNum\");\n            int shootNumCount = int.Parse(shootNum[0].InnerText);\n            save.shootNum = shootNumCount;\n\n            XmlNodeList score = xmlDoc.GetElementsByTagName(\"score\");\n            int scoreCount = int.Parse(score[0].InnerText);\n            save.score = scoreCount;\n\n            SetGame(save);\n            UIManager._instance.ShowMessage(\"\");\n\n        }\n        else\n        {\n            UIManager._instance.ShowMessage(\"存档文件不存在\");\n        }\n    }\n```\n\n1. 加载XML文档\n               XmlDocument xmlDoc = new XmlDocument();\n               xmlDoc.Load(filePath);\n\n2. 获取名为target的所有节点元素们，结果为XmlNodeList类型\n               XmlNodeList targets = xmlDoc.GetElementsByTagName(\"target\");\n\n3. 遍历所有的target节点们，并获得子节点和子节点的InnerText\n               foreach(XmlNode target in targets)\n\n4. 获取一个target节点中的第一/二个子结点的内容\n   XmlNode targetPosition = target.ChildNodes[0];\n\n   int targetPositionIndex = int.Parse(targetPosition.InnerText);\n\n   XmlNode monsterType = target.ChildNodes[1];\n\n   int monsterTypeIndex = int.Parse(monsterType.InnerText);\n\n#### 5、通过读档信息重置我们的游戏状态（分数、激活状态的怪物）\n\n```\nprivate void SetGame(Save save)\n    {\n        //先将所有的targrt里面的怪物清空，并重置所有的计时\n        foreach(GameObject targetGO in targetGOs)\n        {\n            targetGO.GetComponent<TargetManager>().UpdateMonsters();\n        }\n        //通过反序列化得到的Save对象中存储的信息，激活指定的怪物\n        for(int i = 0; i < save.livingTargetPositions.Count; i++)\n        {\n            int position = save.livingTargetPositions[i];\n            int type = save.livingMonsterTypes[i];\n            targetGOs[position].GetComponent<TargetManager>().ActivateMonsterByType(type);\n        }\n\n        //更新UI显示\n        UIManager._instance.shootNum = save.shootNum;\n        UIManager._instance.score = save.score;\n        //调整为未暂停状态\n        UnPause();\n    }\n```\n\n","tags":["Unity"],"categories":["Unity"]},{"title":"Hard 128 Longest Consecutive Sequence//HashMap","url":"/2019/03/08/20190308/","content":"\n跳一跳\n\n最长连续序列\n\n<!-- more -->\n\n###### HashMap相关知识\n\nhttps://www.cnblogs.com/skywang12345/p/3310835.html#b1\n\n# 问题\n\nGiven an unsorted array of integers, find the length of the longest consecutive elements sequence.\n\nYour algorithm should run in O(*n*) complexity.\n\n**Example:**\n\n```\nInput: [100, 4, 200, 1, 3, 2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n```\n\n# 解\n\n使用到了JAVA中的HashMap【HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。】，我们把数组中的数字设为key，包含key的最长连续子数列的长度设为value。\n\n1. 遍历nums数组中的数n，对于每一个n，查看map中是否存在n-1和n+1（比如有数字3，找2和4是否存在于map中），若存在则获取其value（也就是包括该数字的当前最长的子数列长度），存为left和right。\n2. sum=left+right+1为数字n目前的最长子数列长度。\n3. 把（n，sum）存入map。\n4. 把（n-left，sum）和（n+right，sum）存入map。利用已知的left和right两个长度得到n当前所在连续子数列的左右两端的数字n-left和n+right，用这次得到的新的长度sum代替以前存的旧长度，也便于第1步中获取当前最长的left和right。\n\n总时间复杂度为O(n)。\n\n```\npublic int longestConsecutive(int[] num) {\n    int res = 0;\n    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n    for (int n : num) {\n        if (!map.containsKey(n)) {\n            int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0;\n            int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0;\n            // sum: length of the sequence n is in\n            int sum = left + right + 1;\n            map.put(n, sum);\n            \n            // keep track of the max length \n            res = Math.max(res, sum);\n            \n            // extend the length to the boundary(s)\n            // of the sequence\n            // will do nothing if n has no neighbors\n            map.put(n - left, sum);\n            map.put(n + right, sum);\n        }\n        else {\n            // duplicates\n            continue;\n        }\n    }\n    return res;\n}\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"unity序列化 XML\\JSON","url":"/2019/03/06/20190306/","content":"\nhttps://blog.csdn.net/y1196645376/article/details/52541882\n\n<!-- more -->\n\n## 1.先介绍一下 XML 和 JSON 是什么东西吧？\n\n###       (1)XML\n\n扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进 行定义的源语言。 XML使用DTD(document type definition)文档类型定义来组织数据;格式统一，跨平台和语言，早已成为业界公认的标准。\nXML是标准通用标记语言 (SGML) 的子集，非常适合 Web 传输。XML 提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。\n\n###       (2)Json\n\nJSON(JavaScript Object Notation)一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。可在不同平台之间进行数据交换。JSON采用兼容性很高的、完全独立于语言文本格式，同时也具备类似于C语言的习惯(包括C, C++, C#, Java, JavaScript, Perl,\n Python等)体系的行为。这些特性使JSON成为理想的数据交换语言。\n        说了那么多，其实就是数据的两种保存格式。主要用于配置文件，描述数据，存储数据，数据传输等等。\n\n## 2.因为Xml和Json都可以办到这些事情，那么它们之间有什么区别么？各自的优缺点？\n\n###       (1)XML\n\n优点：格式统一，符合标准；.容易与其他系统进行远程交互，数据共享比较方便。\n        缺点：XML文件庞大，文件格式复杂，传输占带宽；服务器端和客户端解析XML花费较多的资源和时间；需要花费大量代码来解析XML；\n\n###       (2)Json\n\n优点：数据格式比较简单，易于读写，格式都是压缩的，占用带宽小；.支持多种语言；\n        缺点：可读性较xml略差；\n         ***总而言之，两者可以相互转换，功能都是相差无几的。但是json比xml较好，但xml更加通用。***\n\n## 3.XML使用的简单介绍.\n\n**a.先来看一段简单的xml代码。**\n\n```\n<team name=\"Dreamer\">\t\n    <student>\t\t\n        <name>Tom</name>\t\t\n        <age>20</age>\t\t\n        <id>20111234</id>\t\n    </student>\t\n        <student>\t\t\n        <name>Shierly</name>\t\t         <age>19</age>\t\t\n        <id>20113210</id>\t\n    </student>\t\n    <student>\t\t\n        <name>Lili</name>\t\t\n        <age>21</age>\t\t\n    <id>20111110</id>\t\n    </student>\n</team>\n\n```\n\n#### Unity3D中使用（可以使用C#自带的库,不需要引入其他库。using System.Xml\n\n```\n\npublic void CreateXML()\n\n{\n\n \n\n    //xml保存的路径，注意路径。\n\n    string filepath = \"E:/my.xml\";\n\n    //继续判断当前路径下是否有该文件\n\n    if(!File.Exists (filepath))\n\n    {\n\n        //创建XML文档实例\n\n        XmlDocument xmlDoc = new XmlDocument();\n\n        //创建root节点，也就是最上一层节点\n\n        XmlElement root = xmlDoc.CreateElement(\"team\");\n\n        root.SetAttribute(\"name\", \"Dreamer\");\n\n        //继续创建下一层节点\n\n        XmlElement student = xmlDoc.CreateElement(\"student\");\n\n \n\n        //继续创建下一层节点\n\n        XmlElement name = xmlDoc.CreateElement(\"name\");\n\n        //设置节点中的数值\n\n        name.InnerText = \"Tom\";\n\n        XmlElement age = xmlDoc.CreateElement(\"age\");\n\n        age.InnerText = \"20\";\n\n        XmlElement id = xmlDoc.CreateElement(\"id\");\n\n        id.InnerText = \"20111234\";\n\n \n\n        //把节点一层一层的添加至XMLDoc中 ，请仔细看它们之间的先后顺序，这将是生成XML文件的顺序\n\n        student.AppendChild(name);\n\n        student.AppendChild(age);\n\n        student.AppendChild(id);\n\n        root.AppendChild(student);\n\n \n\n        student = xmlDoc.CreateElement(\"student\");\n\n        name = xmlDoc.CreateElement(\"name\");\n\n        name.InnerText = \"Shierly\";\n\n        age = xmlDoc.CreateElement(\"age\");\n\n        age.InnerText = \"19\";\n\n        id = xmlDoc.CreateElement(\"id\");\n\n        id.InnerText = \"20113210\";\n\n        student.AppendChild(name);\n\n        student.AppendChild(age);\n\n        student.AppendChild(id);\n\n        root.AppendChild(student);\n\n \n\n        student = xmlDoc.CreateElement(\"student\");\n\n        name = xmlDoc.CreateElement(\"name\");\n\n        name.InnerText = \"Lili\";\n\n        age = xmlDoc.CreateElement(\"age\");\n\n        age.InnerText = \"21\";\n\n        id = xmlDoc.CreateElement(\"id\");\n\n        id.InnerText = \"20111110\";\n\n        student.AppendChild(name);\n\n        student.AppendChild(age);\n\n        student.AppendChild(id);\n\n        root.AppendChild(student);\n\n \n\n        xmlDoc.AppendChild(root);\n\n        //把XML文件保存至本地\n\n        xmlDoc.Save(filepath);\n\n    }\n\n \n\n}\n\n```\n\n这个代码运行后就会在目标文件夹中生成一个xml文件而文件内容就是1中的那段xml代码。\n可以看出来 XmlElement 是基本结构单元。也就是xml中的一对<Name></Name>。\n1.我们可以对这个结构单元添加属性：xmlelement.SetAttribute(name,value)。\n2.也可以对这个结构单元添加子结构单元：xmlelement.AppendChild(childelement)。\n\n3.如果该结构单元没有子结构了还可以设置它的内容值：xmlelement.InnerText = value.\n\n。。。","tags":["Unity"],"categories":["Unity"]},{"title":"Hard 42 Trapping Rain Water","url":"/2019/03/05/20190305/","content":"\n捕获雨水\n\n<!-- more -->\n\n# 问题\n\nGiven *n* non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n\n  \n\n![img](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)\n The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. **Thanks Marcos** for contributing this image!\n\n  \n\n**Example:**\n\n  \n\n```\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\n```\n\n# 解\n\n每块储水区域的横坐标单位都为1，主要计算每一个储水条条高度相加就可以了。\n\n设定左右两个游标，哪边矮就把哪边的游标往中间移动一个单位，并计算那一边的水量。\n\n```\n public int trap(int[] height) {\n        int left=0,right=height.length-1,maxleft=0,maxright=0,res=0;\n        while(left<=right){\n            if(height[left]<height[right]){\n                if(height[left]>maxleft){\n                    maxleft=height[left];\n                }\n                else{\n                    res+=maxleft-height[left];\n                }\n                left++;\n            }\n            else{\n                if(height[right]>maxright){\n                    maxright=height[right];\n                }\n                else{\n                    res+=maxright-height[right];\n                }\n                right--;\n            }\n        }\n        return res;\n    }\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"121+122+123 Best Time to Buy and Sell Stock","url":"/2019/03/03/20190303/","content":"\n炒股票：这一系列问题是典型的dp问题，dp的关键是找到表示状态的变量，并推导出过渡函数。\n\n<!-- more -->\n\n[TOC]\n\n\n\n# 问题1\n\nSay you have an array for which the *i*th element is the price of a given stock on day *i*.\n\nIf you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.\n\nNote that you cannot sell a stock before you buy one.\n\n假设有一个数组，其中的第i*个元素是给定股票在第i*天的价格。\n\n如果只允许您完成最多一项交易(即(即买一股，卖一股)，设计一种算法来寻找最大利润。\n\n注意，你不能在买股票之前就把它卖掉。\n\n**Example 1:**\n\n```\nInput: [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\n             Not 7-1 = 6, as selling price needs to be larger than buying price.\n```\n\n**Example 2:**\n\n```\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\n```\n\n# 解\n\n#### 很笨的方法：\n\n```\n public int maxProfit(int[] prices) {\n        int profit=0;\n        for(int i=0;i<prices.length-1;i++){\n            for(int j=i;j<prices.length;j++){\n                if(prices[j] < prices[i]){\n                    continue;\n                }\n                profit=Math.max(profit,prices[j]-prices[i]);\n            }\n        }\n        return profit;\n    }\n```\n\nRuntime: 252 ms, faster than 13.07% of Java online submissions for Best Time to Buy and Sell Stock.\n\nMemory Usage: 37.3 MB, less than 71.25% of Java online submissions forBest Time to Buy and Sell Stock.\n\n#### 一种聪明的方法：\n\n```\npublic int maxProfit(int[] prices) {\n        int maxCur = 0, maxSoFar = 0;\n        for(int i = 1; i < prices.length; i++) {\n            maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]);\n            maxSoFar = Math.max(maxCur, maxSoFar);\n        }\n        return maxSoFar;\n    }\n```\n\nRuntime: 1 ms, faster than 99.69% of Java online submissions for Best Time to Buy and Sell Stock.\n\nMemory Usage: 35.5 MB, less than 98.16% of Java online submissions forBest Time to Buy and Sell Stock.\n\n#### 还有一种方法：找到最小值\n\n```\nint maxProfit(vector<int> &prices) {\n    int maxPro = 0;\n    int minPrice = INT_MAX;\n    for(int i = 0; i < prices.size(); i++){\n        minPrice = min(minPrice, prices[i]);\n        maxPro = max(maxPro, prices[i] - minPrice);\n    }\n    return maxPro;\n}\n```\n\n# 问题2\n\n可交易多次。\n\n**Example** 1:\n\n```\nInput: [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n```\n\n**Example 2:**\n\n```\nInput: [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\n             engaging multiple transactions at the same time. You must sell before buying again.\n```\n\n**Example 3:**\n\n```\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\n```\n\n# 解\n\n很简单的方法：\n\n```\npublic int maxProfit(int[] prices) {\n        int maxCur = 0;\n        for(int i = 1; i < prices.length; i++) {\n            if(prices[i]>prices[i-1]){\n                 maxCur += prices[i] - prices[i-1];\n            }\n        }\n        return maxCur;\n    }\n```\n\n#### 找局部最大值和最小值的方法：\n\n```\npublic int maxProfit(int[] prices) {\n    int profit = 0, i = 0;\n    while (i < prices.length) {\n        // find next local minimum\n        while (i < prices.length-1 && prices[i+1] <= prices[i]) i++;\n        int min = prices[i++]; // need increment to avoid infinite loop for \"[1]\"\n        // find next local maximum\n        while (i < prices.length-1 && prices[i+1] >= prices[i]) i++;\n        profit += i < prices.length ? prices[i++] - min : 0;\n    }\n    return profit;\n}\n```\n\n# 问题3\n\n最多交易两次\n\nSay you have an array for which the *i* th element is the price of a given stock on day *i*.\n\nDesign an algorithm to find the maximum profit. You may complete at most *two* transactions.\n\n**Note:** You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n\n假设有一个数组，其中的第i*个元素是给定股票在第i*天的价格。\n\n设计一种寻找最大利润的算法。您最多可以完成两次交易。\n\n**注:**阁下不得同时进行多项交易(即你必须先把股票卖了，然后再买。\n\n# 解\n\n### \n\n#### 方法一\n\n假设我们一开始只有0元，4个变量来保存一些到目前为止有趣的“上限”——\n\n如果我们只买第一支股票，\n\n如果我们只卖第一支股票，\n\n如果我们只买第二支股票，\n\n如果我们只卖第二支股票。\n\n```\npublic int maxProfit(int[] prices) {\n        int hold1 = Integer.MIN_VALUE, hold2 = Integer.MIN_VALUE;\n        int release1 = 0, release2 = 0;\n        for(int i:prices){                              public int maxProfit(int[] prices) {\n        int hold1 = Integer.MIN_VALUE, hold2 = Integer.MIN_VALUE;\n        int release1 = 0, release2 = 0;\n        for(int i:prices){                              \n            hold1    = Math.max(hold1,    -i);          \n            release1 = Math.max(release1, hold1+i);    \n            hold2    = Math.max(hold2,    release1-i);  \n            release2 = Math.max(release2, hold2+i);    \n        }\n        return release2;\n\n    }\n```\n\n每天，我们以尽可能低的价格买进股票，以尽可能高的价格卖出股票。对于第二笔交易，我们将第一笔交易的利润整合到第二笔购买的成本中，那么第二笔出售的利润就是两笔交易的总利润。\n\n#### 方法二：\n\n对于第 k 轮交易、一共第 i 天，设定获利为 dp[k, i]。\n\n如果第 i 天没有进行交易，那么获利和前一天一样，即dp[k, i]= dp[k, i-1] 。\n\n如果我们在第 j 天买股票 j=[0..i-1]，然后在第 i 天卖出股票，那么利润就是 prices[i] - prices[j] + dp[k-1, j-1] 。实际上 j 也可以是 i ，当 j = i 时，prices[i] - prices[j] + dp[k-1, j] = dp[k-1, i] ，看来我们只是失去了一次交易的机会。\n\n我们希望prices[i] - prices[j] + dp[k-1, j-1] 最大，那么 prices[i]要最大，prices[j] - dp[k-1, j-1]就要最小。因此有了min = Math.Min(min, prices[i] - dp[k-1, i-1])，和dp[k, i] = Math.Max(dp[k, i-1], prices[i] - min)。\n\n```\npublic int MaxProfitDpCompact1(int[] prices) {\n           if (prices.length == 0) return 0;\n        int[][] dp = new int[3][prices.length];\n        for (int k = 1; k <= 2; k++) {\n            int min = prices[0];\n            for (int i = 1; i < prices.length; i++) {\n                min = Math.min(min, prices[i] - dp[k-1][i-1]);\n                dp[k][i] = Math.max(dp[k][i-1], prices[i] - min);\n            }\n        }\n\n        return dp[2][prices.length - 1];\n        }\n```\n\nTime complexity is O(kn), space complexity is O(kn).\n\n# 问题309\n\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75927/Share-my-thinking-process\n\n```\npublic int maxProfit(int[] prices) {\n    int sell = 0, prev_sell = 0, buy = Integer.MIN_VALUE, prev_buy;\n    for (int price : prices) {\n        prev_buy = buy;\n        buy = Math.max(prev_sell - price, prev_buy);\n        prev_sell = sell;\n        sell = Math.max(prev_buy + price, prev_sell);\n    }\n    return sell;\n}\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Medium 55+Hard 45 Jump Game","url":"/2019/03/02/20190302/","content":"\n跳一跳\n\n<!-- more -->\n\n# 问题1\n\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\n\nEach element in the array represents your maximum jump length at that position.\n\nDetermine if you are able to reach the last index.\n\n**Example 1:**\n\n```\nInput: [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n```\n\n**Example 2:**\n\n```\nInput: [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum\n             jump length is 0, which makes it impossible to reach the last index.\n```\n\n# 解\n\n每个数组元素存的是从当前位置最多可以跳多少个，而像例二就是不论从前三个哪一个位置都跳不到第四个位置，是false的。\n\n使用一个jumpmax记录当前最大距离。\n\n在每个新位置起跳的最远距离是(i+nums[i])，也就是跳到这个位置使用的步数+从这个位置开始跳的最大步数。\n\n如果jumpmax<i，就说明走不到i这个位置。\n\n```\n   public boolean canJump(int[] nums) {\n        int jumpmax=0;\n        for(int i=0;i<nums.length;i++){\n            if(jumpmax<i){\n                return false;\n            }\n            jumpmax=Math.max(jumpmax,(i+nums[i]));\n        }\n        return true;\n    }\n```\n\n# 问题2\n\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\n\nEach element in the array represents your maximum jump length at that position.\n\nYour goal is to reach the last index in the minimum number of jumps.\n\n**Example:**\n\n```\nInput: [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2.\n    Jump 1 step from index 0 to 1, then 3 steps to the last index.\n```\n\n和问题1 的区别：输出结果是，用最小的跳数跳到最后一个位置。\n\n# 解\n\n```\npublic int jump(int[] nums) {\n        int jumps=0,steps=nums[0],end=0;\n        for(int i=0;i<nums.length-1;i++){\n            steps=Math.max(steps,(i+nums[i]));\n            if(i==end){\n                jumps++;\n                end=steps;\n            }\n        }\n        return jumps;\n}\n```\n\n\n\n### 评论区的一个c++解:\n\n使用了start和end两个数来记录当前这一跳的起点和最远能跳到的终点，用maxend来找到在这段距离中开始下一跳能达到的最远的步数。\n\n```\nint jump(vector<int>& nums) {\n        int n = nums.size(), step = 0, start = 0, end = 0;\n        while (end < n - 1) {\n            step++; \n\t\t\tint maxend = end + 1;\n\t\t\tfor (int i = start; i <= end; i++) {\n                if (i + nums[i] >= n - 1) return step;\n\t\t\t\tmaxend = max(maxend, i + nums[i]);\n\t\t\t}\n            start = end + 1;\n            end = maxend;\n        }\n\t\treturn step;\n    }\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Easy 217 Contains Duplicate","url":"/2019/02/28/20190228/","content":"\n检查数组是否内容重复\n\n<!-- more -->\n\n# 问题\n\nGiven an array of integers, find if the array contains any duplicates.\n\nYour function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n\n**Example 1:**\n\n```\nInput: [1,2,3,1]\nOutput: true\n```\n\n**Example 2:**\n\n```\nInput: [1,2,3,4]\nOutput: false\n```\n\n**Example 3:**\n\n```\nInput: [1,1,1,3,3,4,3,2,4,2]\nOutput: true\n```\n\n# 解\n\n#### HUSH\n\nTime complexity: O(N), memory: O(N)\n\n我们可以使用一个众所周知的数据结构哈希表，它将帮助我们识别一个元素是否以前在数组中遇到过。\n\n------\n\n```\npublic boolean containsDuplicate(int[] nums) {\n    final Set<Integer> distinct = new HashSet<Integer>();\n    for(int num : nums) {\n        if(distinct.contains(num)) {\n            return true;\n        }\n        distinct.add(num);\n    }\n    return false;\n}\n```\n\n这是时空权衡的一个很好的例子。\n\n另外两种native方法：\n\n#### 1\n\nTime complexity: O(N^2), memory: O(1)\n\n最天真烂漫的方法就是迭代每一个数字，检查是否有与它重复的，导致时间复杂度高达O(N^2)。\n\n------\n\n```\npublic boolean containsDuplicate(int[] nums) {\n\n        for(int i = 0; i < nums.length; i++) {\n            for(int j = i + 1; j < nums.length; j++) {\n                if(nums[i] == nums[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n```\n\n#### 2\n\nTime complexity: O(N lg N), memory: O(1) - not counting the memory used by sort\n\n先排序，重复的数字会排在一起，这样查重起来非常方便。\n\n------\n\n```\n    public boolean containsDuplicate(int[] nums) {\n\n        Arrays.sort(nums);\n        for(int ind = 1; ind < nums.length; ind++) {\n            if(nums[ind] == nums[ind - 1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n```","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Medium 274 H-Index","url":"/2019/02/27/20190227/","content":"\n科学家的引用文献数问题\n\n<!-- more -->\n\n# 问题\n\nGiven an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): \"A scientist has index *h* if *h* of his/her *N *papers have **at least** *h* citations each, and the other *N − h* papers have **no more than** *h* citations each.\"\n\n**Example:**\n\n```\nInput: citations = [3,0,6,1,5]\nOutput: 3 \nExplanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had \n             received 3, 0, 6, 1, 5 citations respectively. \n             Since the researcher has 3 papers with at least 3 citations each and the remaining \n             two with no more than 3 citations each, her h-index is 3.\n```\n\n**Note:** If there are several possible values for *h*, the maximum one is taken as the h-index.\n\n# 思路\n\n在一共N篇文章里，有h篇文章的索引大于等于h个，其它N-h篇文章的文献小于h个，要找到这个h值。\n\n统计有0、1、2、3、....、>=h个索引的文章数分别是多少，然后把文章数从后往前累加，直到文章数>=索引数。\n\n```\n  public int hIndex(int[] citations) {\n        int n=citations.length;\n        int[] buckets=new int[n+1];\n        for(int i:citations){\n            if(i>=n){\n                buckets[n]++;\n            }\n            else{\n                buckets[i]++;\n            }\n        }\n        int count=0;\n        for(int j=n;j>=0;j--){\n            count+=buckets[j];\n            if(count>=j)\n            {\n                return j;\n            }\n        }\n        return 0;\n   }\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Medium 134 Gas Station","url":"/2019/02/26/20190226/","content":"\n加油站问题=￣ω￣=\n\n<!-- more -->\n\n# 问题\n\nThere are *N* gas stations along a circular route, where the amount of gas at station *i* is `gas[i]`.\n\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from station *i* to its next station (*i*+1). You begin the journey with an empty tank at one of the gas stations.\n\nReturn the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.\n\n**Note:**\n\n- If there exists a solution, it is guaranteed to be unique.\n- Both input arrays are non-empty and have the same length.\n- Each element in the input arrays is a non-negative integer.\n\n**Example 1:**\n\n```\nInput: \ngas  = [1,2,3,4,5]\ncost = [3,4,5,1,2]\n\nOutput: 3\n\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n```\n\n**Example 2:**\n\n```\nInput: \ngas  = [2,3,4]\ncost = [3,4,3]\n\nOutput: -1\n\nExplanation:\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.\n```\n\n# 解\n\n思路：\n\n假设以 i 站为起点，到 i+j 站没油了只能停止，那么从 i+1 站到 i+j-1 站中任何一站都不能到达 i+j 站。也就是说，如果A地能到B地，B地能到C地，那么A地能到C地。\n\n因此可以先写一个for循环，令起点 i 的范围是0~n-1，每次i=i+j；j是内部for循环的一个值，内部for循环代表的是以 i 为起点往后移动，计算每一步移动后的总油量，若油量为负则结束内循环，让外部 i 跳过这一段，也就是i=i+j，再在新 i 的基础上往后移动并计算。\n\n代码：\n\n```\n int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int i,j,n=gas.size();\n        for(i=0;i<n;i+=j){\n            int sum=0;\n            for(j=1;j<n+1;j++){\n                sum+=gas[(i+j-1)%n]-cost[(i+j-1)%n];\n                if(sum<0){\n                    break;\n                }\n            }\n            if(sum>=0){\n                return i;\n            }\n        }\n        return -1;\n    }\n```\n\n评论区另外一个写法，思路是差不多的：\n\n```\nint canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\n        int start(0),total(0),tank(0);\n        //if car fails at 'start', record the next station\n        for(int i=0;i<gas.size();i++){\n            if((tank=tank+gas[i]-cost[i])<0) \n            {\n                start=i+1;\n                total+=tank;\n                tank=0;\n            }\n        }\n        return (total+tank<0)? -1:start;\n}\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Medium 299 Bulls and Cows","url":"/2019/02/24/2019022402/","content":"\n一个猜谜小游戏\n\n<!-- more -->\n\n# 问题\n\nYou are playing the following [Bulls and Cows](https://en.wikipedia.org/wiki/Bulls_and_Cows) game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called \"bulls\") and how many digits match the secret number but locate in the wrong position (called \"cows\"). Your friend will use successive guesses and hints to eventually derive the secret number.\n\n  \n\nWrite a function to return a hint according to the secret number and friend's guess, use `A` to indicate the bulls and `B` to indicate the cows. \n\n  \n\nPlease note that both secret number and friend's guess may contain duplicate digits.\n\n  \n\n**Example 1:**\n\n  \n\n```\nInput: secret = \"1807\", guess = \"7810\"\n\nOutput: \"1A3B\"\n\nExplanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.\n```\n\n  \n\n**Example 2:**\n\n  \n\n```\nInput: secret = \"1123\", guess = \"0111\"\n\nOutput: \"1A1B\"\n\nExplanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.\n```\n\n  \n\n**Note:** You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.\n\n\n\n就是说，如果位置和数字都对，就bull+1，如果数字有但是位置不对，就guess+1.\n\n# 解\n\n```\nclass Solution {\npublic:\n    string getHint(string secret, string guess) {\n        int bull=0,cows=0;\n        vector<int> sec(10,0);\n        vector<int> gus(10,0);//0~9的容器\n        if(secret.size()!=guess.size() || guess.empty()){\n            return \"0A0B\";\n        }\n        for(int i=0;i<guess.size();i++){\n            char se=secret[i];\n            char gu=guess[i];\n            if(se==gu){\n                bull++;\n            }else{\n                sec[se-'0']++;\n                gus[gu-'0']++;\n            }\n        }\n        for(int j=0;j<sec.size();j++){\n            cows+=min(sec[j],gus[j]);\n        }\n        return to_string(bull)+'A'+to_string(cows)+'B';\n        \n    }\n};\n```\n\nbull很容易得到，cows得到的方法：\n\n新建两个长为10的int型容器，每个容器的10个位置分别存储数字0到9的个数。如secret=‘’1807“，则容器里面{1，1，0，0，0，0，0，1，1，0}.。最后把两个容器里对应位置的最小值相加，就是数字对了但是位置不对的个数，则是cows。","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"hard 41 First Missing Positive","url":"/2019/02/24/20190224/","content":"\n第一个丢失的正整数\n\n<!-- more -->\n\n# 问题\n\nGiven an unsorted integer array, find the smallest missing positive integer.\n\n**Example 1:**\n\n```\nInput: [1,2,0]\nOutput: 3\n```\n\n**Example 2:**\n\n```\nInput: [3,4,-1,1]\nOutput: 2\n```\n\n**Example 3:**\n\n```\nInput: [7,8,9,11,12]\nOutput: 1\n```\n\n**Note:\n\nYour algorithm should run in *O*(*n*) time and uses constant extra space.\n\n# 解\n\n这个题的意思大概就是，例如input=【1，2，0】，和【1，2，3】对比少了【1】；input=【3，4，-1，1】，和【1，2，3，4】对比少了【2】。\n\n评论区一个解是：\n\n```\nclass Solution\n{\npublic:\n    int firstMissingPositive(int A[], int n)\n    {\n        int n=nums.size();\n        //遍历每个数字\n        for(int i = 0; i < n; ++ i){  \n            while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]){\n            //若A[i]-1!=i则交换到正确的位置\n            //while条件可以在交换之后再检查一次新的A[i]值，保证不遗漏\n                swap(nums[i], nums[nums[i] - 1]);//交换位置\n            }\n        }\n        for(int i = 0; i < n; ++ i){\n            if(nums[i] != i + 1){\n                return i + 1;\n            }   \n        }\n        return n + 1;\n    }\n};\n```\n\n用一个等大的数组来顺序保存这些数字，把正确存在的数放在应该放的位置，丢失了也就是没存在的位置记为-1，比如数组【3，4，-1，1，8】，把其保存为【1，-1，3，4，-1】，数组的每个位置都保存着比下标+1的数。然后只需要遍历数组，第一个a[i]!=i+1，就说明缺失了i+1。\n\n于是按照以上思路，不需要用一个额外的数组，可以直接把原数组当成新数组来使用，会出现的问题就是可能覆盖掉之前的有用的数。可以采用交换的方法，把被覆盖的数移动到要去覆盖的数的位置，也就是交换一下位置，例如【3，4，-1，1，8】，要把nums[0]的数字【3】移动到【-1】，不直接覆盖，而是交换位置，变成【-1，4，3，1，8】。然后判断当前nums[0]的数字【-1】，不是正数，忽略。\n\n最后只需要遍历nums数组，第一个。nums[i]!=i+1，就说明缺失了i+1。","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"easy 189 Rotate Array","url":"/2019/02/22/20190222/","content":"\n旋转数组(●'◡'●)\n\n<!-- more -->\n\n# 问题\n\nGiven an array, rotate the array to the right by *k* steps, where *k* is non-negative.\n\n**Example 1:**\n\n```\nInput: [1,2,3,4,5,6,7] and k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n```\n\n**Example 2:**\n\n```\nInput: [-1,-100,3,99] and k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n```\n\n**Note:**\n\n- Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\n- Could you do it in-place with O(1) extra space?\n\n# 解\n\n自己写的方法复杂度太高，去评论区学习了几种其它思路：\n\n#### 1、对数组拷贝一份，然后再旋转。\n\ntc：O(n)   sc：O(n)\n\n```\nvoid rotate(int nums[], int n, int k) \n        {\n            if ((n == 0) || (k <= 0))\n            {\n                return;\n            }\n            \n            // Make a copy of nums\n            vector<int> numsCopy(n);\n            for (int i = 0; i < n; i++)\n            {\n                numsCopy[i] = nums[i];\n            }\n            \n            // Rotate the elements.\n            for (int i = 0; i < n; i++)\n            {\n                nums[(i + k)%n] = numsCopy[i];\n            }\n        }\n```\n\n#### 2、从一个元素开始旋转，直到旋转n个元素\n\ntc：O(n)   sc：O(1)\n\n以数组1、2、3、4、5、6（k=2）为例，\n\n结果是5，6，1，2，3，4\n\n1. 内部do-while做的事情是：把1放在3的位置，把3放在5的位置，把5放在1的位置，回到了起点1，则结束此循环。\n2. 内部循环次数小于数组长度n，则不离开大循环while。起点+1，再次进入内部do-while。\n3. 内部do-while做的事情是：把2放在4的位置，把4放在6的位置，把6放在2的位置，回到了起点2，则结束此循环。\n\n\n\n```\nvoid rotate(int nums[], int n, int k) \n        {\n            if ((n == 0) || (k <= 0))\n            {\n                return;\n            }\n            \n            int cntRotated = 0;\n            int start = 0;\n            int curr = 0;\n            int numToBeRotated = nums[0];\n            int tmp = 0;\n            // 循环直到旋转n个不同的元素\n            while (cntRotated < n)\n            {\n                do\n                {\n                    tmp = nums[(curr + k)%n];\n                    nums[(curr+k)%n] = numToBeRotated;\n                    numToBeRotated = tmp;\n                    curr = (curr + k)%n;\n                    cntRotated++;\n                } while (curr != start);\n                // 回到起点就结束一个循环\n                // 对下一个元素开始循环\n                start++;\n                curr = start;\n                numToBeRotated = nums[curr];\n            }\n        }\n```\n\n#### 3、先置换前n-k个元素，再置换后k个元素，最后整体n个元素置换。\n\ntc：O(n)   sc：O(1)\n\n```\n void rotate(int nums[], int n, int k) \n        {\n            k = k%n;\n    \n            // Reverse the first n - k numbers.\n            // Index i (0 <= i < n - k) becomes n - k - i.\n            reverse(nums, nums + n - k);\n            \n            // Reverse tha last k numbers.\n            // Index n - k + i (0 <= i < k) becomes n - i.\n            reverse(nums + n - k, nums + n);\n            \n            // Reverse all the numbers.\n            // Index i (0 <= i < n - k) becomes n - (n - k - i) = i + k.\n            // Index n - k + i (0 <= i < k) becomes n - (n - i) = i.\n            reverse(nums, nums + n);\n        }\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"26+80 Remove Duplicates from Sorted Array","url":"/2019/02/20/20190220/","content":"\n# 问题26\n\nGiven a sorted array *nums*, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each element appear only *once* and return the new length.\n\n  \n\nDo not allocate extra space for another array, you must do this by **modifying the input array in-place** with O(1) extra memory.\n\n  \n\n**Example 1:**\n\n  \n\n```\nGiven nums = [1,1,2],\n\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\n\nIt doesn't matter what you leave beyond the returned length.\n```\n\n  \n\n**Example 2:**\n\n  \n\n```\nGiven nums = [0,0,1,1,1,2,2,3,3,4],\n\nYour function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.\n\nIt doesn't matter what values are set beyond the returned length.\n```\n\n  \n\n**Clarification:**\n\n  \n\nConfused why the returned value is an integer but your answer is an array?\n\n  \n\nNote that the input array is passed in by **reference**, which means modification to the input array will be known to the caller as well.\n\n  \n\nInternally you can think of this:\n\n  \n\n```\n// nums is passed in by reference. (i.e., without making a copy)\nint len = removeDuplicates(nums);\n\n// any modification to nums in your function would be known by the caller.\n// using the length returned by your function, it prints the first len elements.\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n# c++解\n\n```\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if(nums.size()==0){\n            return 0;\n        }\n        int length=0;\n        for(int i=1 ; i<nums.size() ; i++){\n            if(nums[i]!=nums[i-1]){\n                length++;\n                nums[length]=nums[i];\n                \n            }\n        }\n        return length+1;\n    }\n};\n```\n\n\n\n# 问题80\n\nGiven a sorted array *nums*, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that duplicates appeared at most *twice* and return the new length.\n\n  \n\nDo not allocate extra space for another array, you must do this by **modifying the input array in-place** with O(1) extra memory.\n\n  \n\n**Example 1:**\n\n  \n\n```\nGiven nums = [1,1,1,2,2,3],\n\nYour function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\n\nIt doesn't matter what you leave beyond the returned length.\n```\n\n  \n\n**Example 2:**\n\n  \n\n```\nGiven nums = [0,0,1,1,1,1,2,3,3],\n\nYour function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.\n\nIt doesn't matter what values are set beyond the returned length.\n```\n\n  \n\n**Clarification:**\n\nConfused why the returned value is an integer but your answer is an array?\n\nNote that the input array is passed in by **reference**, which means modification to the input array will be known to the caller as well.  \n\nInternally you can think of this:  \n\n```\n// nums is passed in by reference. (i.e., without making a copy)\nint len = removeDuplicates(nums);\n\n// any modification to nums in your function would be known by the caller.\n// using the length returned by your function, it prints the first len elements.\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n# c++解\n\n```\nint removeDuplicates(vector<int>& nums) {\n        int count=0;\n        for(int i=2 ; i<nums.size() ; i++){\n            if((nums[i]==nums[i-2-count])){\n                count++;\n            }\n            else\n            {\n                nums[i-count]=nums[i];\n            }\n        }\n        return nums.size()-count;\n    }\n```\n\n\n\n# 一个好聪明的解\n\n**C++**\n\n```\nint removeDuplicates(vector<int>& nums) {\n    int i = 0;\n    for (int n : nums)\n        if (i < 2 || n > nums[i-2])\n            nums[i++] = n;\n    return i;\n}\n```\n\n \n\n\n\n**Java**\n\n```\npublic int removeDuplicates(int[] nums) {\n    int i = 0;\n    for (int n : nums)\n        if (i < 2 || n > nums[i-2])\n            nums[i++] = n;\n    return i;\n}\n```\n\n \n\n\n\n**Python**\n\n```\ndef removeDuplicates(self, nums):\n    i = 0\n    for n in nums:\n        if i < 2 or n > nums[i-2]:\n            nums[i] = n\n            i += 1\n    return i\n```\n\n \n\n\n\n**Ruby**\n\n```\ndef remove_duplicates(nums)\n    i = 0\n    nums.each { |n| nums[(i+=1)-1] = n if i < 2 || n > nums[i-2] }\n    i\nend\n```","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"Unity Lod 和 Occlusion Culling","url":"/2019/02/18/20190218/","content":"\n# **Lod和Occlusion Culling**\n\n### Lod和遮挡剔除\n\n##### **遮挡剔除**\n\n在我们的场景中，如果物体1在Camera渲染中遮挡了另一个物体2，那物体2就不会再Camera中进行渲染，虽然物体2没有在Camera中进行渲染但是在整个游戏场景中这个物体同样存在。为了优化效率，这里就需要使用遮挡剔除。\n\n**Lod**\n\n如果一个物体离我们的Camera很远，我们自然就看不见这个物体（或者只能看见一个“小点”）。但是这个物体在场景中仍然会根据它的顶点结构进行渲染并消耗性能。这时候为了优化，如果它离我们的Camera距离很远，我们就不需要对它进行渲染，也就是Lod。\n\n### **Occlusion Culling（遮挡剔除）**\n\n![img](https://upload-images.jianshu.io/upload_images/3600976-226b76471d7ae219.gif?imageMogr2/auto-orient/)\n\n遮挡剔除功能在Unity中使用Occlusion Culling（遮挡剔除）组件来进行实现\n\n- 首先我们需要对需要进行遮挡以及被遮挡的物体进行烘焙。\n- 在烘焙的时候，我们需要对遮挡的物体和被遮挡的物体进行选择不同的情况不同的解决方案。（比如一个玻璃物体遮挡住了另一个物体这时我们也应该对玻璃后的物体进行渲染）\n- 这里不考虑这种情况，直接进行烘焙。\n\n### **Lod**\n\n- Lod功能，unity内置的组件也会为我们提供了一套解决方案。（LOD Group组件）\n\n- 首先我们先创建一个小球，可以看见camera已经距离很远，此时只能看见一个小点。但它仍然是场景中进行了渲染。\n\n- 实现LOD优化，为它添加LOD Group组件。\n\n![img](https://upload-images.jianshu.io/upload_images/3600976-372ceaa3e2fd32f9.png?imageMogr2/auto-orient/)\n\n- 其中LOD 0，LOD 1分别为Camera距离这个球的距离区域划分。\n- 我们可以在这些相对距离区域中选择是否要在这个距离对小球渲染。\n\n### 以上方案的缺陷。\n\n- 以上完成的操作都是静态的物体，但是在我们的实际项目开发中，NPC,Monster，建筑物等都是动态生成的。这种情况肯定就无法烘焙成静态的。\n\n### 动态解决方案。（LOD）\n\n- 这时我们使用脚本来控制。而LOD的核心也就是在距离远的时候将小球的MeshRender组件失活我们根据这个核心点去编写代码。\n  - 为我们的Camera添加一个LODAndOcclusionController的脚本。\n  - 完成简单的动态LOD功能。\n\n![img](https://upload-images.jianshu.io/upload_images/3600976-8f16279f0728bbd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/660)\n\n场景测试。 \n\n- 这时我们可以发现当Camera和小球的距离超过5米的时候，小球则不会进行渲染。小球是动态运动的也同样没有关系。\n\n### **动态解决方案。（遮挡剔除）**\n\n- 使用Ray射线来进行判断。\n\n- 我们将所有需要进行遮罩剔除的物体添加Tag为Occlusion。\n- 并为我们的Camera添加脚本。\n\n![img](https://upload-images.jianshu.io/upload_images/3600976-03a28dc50bb5523a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/898)\n\n### **总结：**\n\n我们的LOD以及Occlusion，都是基于GameObject的MeshRender组件来实现的。只有掌握好核心点，不让它们进行渲染，这样减少了Draw Call自然就优化了性能。（主要为什么是让MeshRender组件失活，因为我们直接把整个游戏对象都失活了，那所有的碰撞信息也全部都会失效。）\n\n作者：Levi_Wan\n\n链接：https://www.jianshu.com/p/be81fd0a9380\n\n來源：简书\n\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","tags":["unity"],"categories":["unity"]},{"title":"XML到底是干什么的","url":"/2019/02/17/2019021702/","content":"\nXML科普\n\n<!-- more -->\n\n链接：https://www.zhihu.com/question/31353595/answer/60826602\n\n来源：知乎\n\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\nxml本身是一种格式规范，是一种包含了数据以及数据说明的文本格式规范。 \n\n接下来煮几个栗子说明一下。\n\n比如，我们要给对方传输一段数据，数据内容是“too young,too simple,sometimes naive”，要将这段话按照属性拆分为三个数据的话，就是，年龄too young，阅历too simple，结果sometimes naive。\n\n我们都知道程序不像人，可以体会字面意思，并自动拆分出数据，因此，我们需要帮助程序做拆分，因此出现了各种各样的数据格式以及拆分方式。\n\n比如，可以是这样的\n数据为“too young,too simple,sometimes naive”\n然后按照逗号拆分，第一部分为年龄，第二部分为阅历，第三部分为结果。\n\n也可以是这样的\n数据为“too_young**too_simple*sometimes_naive”\n从数据开头开始截取前面十一个字符，去掉*号并把下划线替换为空格作为第一部分，再截取接下来的十一个字符同样去掉*并替换下划线为空格作为第二部分，最后把剩下的字符同样去*号体会空格作为第三部分。\n\n这两种方式都可以用来容纳数据并能够被解析，但是不直观，通用性也不好，而且如果出现超过限定字数的字符串就容纳不了，也可能出现数据本身就下划线字符导致需要做转义。\n\n基于这种情况，出现了xml这种数据格式， 上面的数据用XML表示的话\n\n可以是这样\n\n```xml\n<person age=\"too young\" experience=\"too simple\" result=\"sometimes naive\" />\n```\n\n也可以是这样\n\n```xml\n<person>\n    <age value=\"too young\" />\n    <experience value=\"too simple\" />\n    <result value=\"sometimes naive\" />\n</person>\n```\n\n两种方式都是xml，都很直观，附带了对数据的说明，并且具备通用的格式规范可以让程序做解析。\n\n如果用json格式来表示的话，就是下面这样\n\n```text\n{\n    \"age\":\"too young\",\n    \"experience\":\"too simple\",\n    \"result\":\"sometimes naive\"\n}\n```\n\n看出来没，其实数据都是一样的，不同的只是数据的格式而已，同样的数据，我用xml格式传给你，你用xml格式解析出三个数据，用json格式传给你，你就用json格式解析出三个数据，还可以我本地保存的是xml格式的数据，我自己先解析出三个数据，然后构造成json格式传给你，你解析json格式，获得三个数据，再自己构造成xml格式保存起来，说白了，不管是xml还是json，都只是包装数据的不同格式而已，重要的是其中含有的数据，而不是包装的格式。","tags":["Unity"],"categories":["Unity"]},{"title":"easy27-Remove Element","url":"/2019/02/17/20190217/","content":"\nleetcode第27题\n<!-- more -->\n\n# 问题\n\nGiven an array *nums* and a value *val*, remove all instances of that value [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) and return the new length.\n\nDo not allocate extra space for another array, you must do this by **modifying the input array in-place** with O(1) extra memory.\n\nThe order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\n**Example 1:**\n\n```\nGiven nums = [3,2,2,3], val = 3,\n\nYour function should return length = 2, with the first two elements of nums being 2.\n\nIt doesn't matter what you leave beyond the returned length.\n```\n\n**Example 2:**\n\n```\nGiven nums = [0,1,2,2,3,0,4,2], val = 2,\n\nYour function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.\n\nNote that the order of those five elements can be arbitrary.\n\nIt doesn't matter what values are set beyond the returned length.\n```\n\n**Clarification:**\n\nConfused why the returned value is an integer but your answer is an array?\n\nNote that the input array is passed in by **reference**, which means modification to the input array will be known to the caller as well.\n\nInternally you can think of this:\n\n```\n// nums is passed in by reference. (i.e., without making a copy)\nint len = removeElement(nums, val);\n\n// any modification to nums in your function would be known by the caller.\n// using the length returned by your function, it prints the first len elements.\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n# c++解\n\n```\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int length=0;\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]!=val){\n                nums[length]=nums[i];\n                length++;\n            }\n        }\n        return length;\n    }\n};\n```\n\n","tags":["leetcode","array"],"categories":["leetcode","array"]},{"title":"多个链表合并","url":"/2019/02/01/20190201/","content":"\n要用到 简单合并两个有序链表\n\n<!-- more -->\n\n# 问题\n\nMerge *k* sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n\n**Example:**\n\n```\nInput:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nOutput: 1->1->2->3->4->4->5->6\n```\n\n# 解\n\n很简单先合并前两个成为一个链表，再合并这个新链表和下一个链表，一直用到的都是合并两个的代码：\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.empty()){\n        return nullptr;\n    }\n    while(lists.size() > 1){\n        lists.push_back(mergeTwoLists(lists[0], lists[1]));\n        lists.erase(lists.begin());\n        lists.erase(lists.begin());\n    }\n    return lists.front();\n    }\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode head(-1);\n        ListNode* l3 = &head;\n        while(l1 && l2){\n            if(l1->val <= l2->val){\n                l3->next = l1;\n                l1 = l1->next;\n            }else{\n                l3->next = l2;\n                l2 = l2->next;\n            }\n            l3 = l3->next;\n        }\n        l3->next = l1? l1:l2;\n        return head.next;\n    }\n    \n```\n\n","tags":["leetcode","list"],"categories":["leetcode"]},{"title":"生成括号对","url":"/2019/01/31/20190131/","content":"\n1月的最后一天啦，放假太颓废了真的，很快又要开学了呜呜呜\n\n<!-- more -->\n\n# 问题\n\nGiven *n* pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\nFor example, given *n* = 3, a solution set is:\n\n```\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n```\n\n给出所有正确的括号组合。\n\n# 解\n\n先不考虑代码，用笔算的话要怎么解决这个问题？\n\nN=3的话就会进行如下思考：\n\n1、（\n\n2、（）or （（\n\n3、【（）（ 】or 【（（） or （（（】\n\n4、【（）（（or （）（）】or【（（））or（（）（】or【（（（）】\n\n可以总结一下规律：\n\n- 第一步先写（，下一步可能是（ 或者 ）\n- 当前左括号数>右括号数时，下一步才可以写 ）\n- 当左括号数==n时，不可再写（；右括号数==n时，结束。\n\n这种每一步都是相同的操作，即+（  或者  +）操作的题目，可以考虑使用递归的方法来解决。\n\n# C++代码\n\n```\nclass Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<string> res;\n        getparen(res,\"\",n,0,0);\n        return res;\n    }\n    void getparen(vector<string> &res,string str,int n,int left,int right){\n        if(left==n && right==n){\n            res.push_back(str);\n            return;\n        }\n        if(left<n){\n            getparen(res,str+\"(\",n,left+1,right);\n        }\n        if(right<left){\n            getparen(res,str+\")\",n,left,right+1);\n        }\n    }\n};\n```\n\n# python3代码\n\n```\nclass Solution:\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        def generate(p, left, right, n, parens=[]):\n            if left < n:         \n                generate(p + '(', left+1, right, n)\n            if right < left: \n                generate(p + ')', left, right+1, n)\n            if left==n and right==n:    \n                parens += p,\n            return parens\n        return generate('', 0 , 0 , n )\n\n```\n\n","tags":["leetcode"],"categories":["leetcode"]},{"title":"HOLOLENS入门之MRinput","url":"/2019/01/29/20190129/","content":"\n大半年没看了，hololens 加了不少东西呢😄\n\n<!-- more -->\n\n# 环境\n\nhttps://docs.microsoft.com/en-us/windows/mixed-reality/install-the-tools\n\n该网址都讲了↑\n\n1、windows 10\n\n2、visual studio 2017\n\n3、windows 10 sdk\n\n4、Unity long term support（LTS）version：官网建议安装unity的LTS stream版本（17年的时候还没有这样说呢...)，但是我根据推荐安装了新的LTS版unity工具包还不支持，到底版本怎么对应的啊喂！\n\n5、MRTK for unity：工具包的版本和unity的版本一定要对应上，对上了开发就是so easy，对不上就是几百个报错贼闹心。\n\n我这次尝试的：\n\nUnity2017.4.19f1\n\nHoloToolkit-2017.4.3.0\n\nHoloToolkit-Examples-2017.4.3.0\n\n\n\nMRTK里面的封装内容博大精深，要是全都能整明白开发MR应用都不是什么难题了。\n\n# Unity设置\n\n- **Edit > Project Settings > Player > Windows Store > XR Settings  ** 在 Virtual Reality Supported 中添加 Virtual Reality SDKs ；把Other Settings 中的 Scripting Backend 设置为 .NET\n- **Edit > Project Settings > Quality**.选择windows store图标下的default小箭头，选择 Fastest\n- **导出**：在unity的导出界面里---->选择**Universal Windows Platform**；**Target device**设为 **HoloLens**. ； **Build Type **设置为D3D ；**SDK** 设置为 **Latest installed** （至少为 SDK 16299)\n\n# MR Input\n\n在众多官方教程里，最基础的教程为MR input：210、211、212、213\n\n## 210：Gaze\n\n","tags":["hololens"],"categories":["hololens"]},{"title":"简单合并两个有序链表","url":"/2019/01/28/20190128/","content":"\n# 问题\n\nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n\n**Example:**\n\n```\nInput: 1->2->4, 1->3->4\nOutput: 1->1->2->3->4->4\n```\n\n# 解\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode head(-1);\n        ListNode* l3 = &head;\n        while(l1 && l2){\n            if(l1->val <= l2->val){\n                l3->next = l1;\n                l1 = l1->next;\n            }else{\n                l3->next = l2;\n                l2 = l2->next;\n            }\n            l3 = l3->next;\n        }\n        l3->next = l1? l1:l2;\n        return head.next;\n    }\n};\n```\n\n","tags":["leetcode","list"],"categories":["leetcode"]},{"title":"移除链表中的倒数第n个结点","url":"/2019/01/27/2019012701/","content":"\nleetcode第19题\n<!-- more -->\n\n# 问题\n\nGiven a linked list, remove the *n*-th node from the end of list and return its head.\n\n**Example:**\n\n```\nGiven linked list: 1->2->3->4->5, and n = 2.\n\nAfter removing the second node from the end, the linked list becomes 1->2->3->5.\n```\n\n**Note:**\n\nGiven *n* will always be valid.\n\n**Follow up:**\n\nCould you do this in one pass?\n\n# 解\n\n要求删除倒数第n个链表节点，难点在于获取“倒数第n个”，可以用两个指针，slow和fast相隔n个节点，当fast走到链表的末尾，则距离fast有n个距离的slow正好指向要删除的那“倒数第n个”。\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *removeNthFromEnd(ListNode *head, int n) \n   {\n        if (!head)\n            return nullptr;\n        ListNode new_head(-1);\n        new_head.next = head;\n       \n        ListNode *slow = &new_head, *fast = &new_head;\n        \n        \n        for (int i = 0; i < n; i++)\n            fast = fast->next;\n\n        while (fast->next) \n        {\n            fast = fast->next;\n            slow = slow->next;\n        }\n\n        ListNode *to_be_deleted = slow->next;\n        delete to_be_deleted;\n        slow->next = slow->next->next;\n    \n        \n\n        return new_head.next;\n     }\n};\n\nPYTHON：\nclass Solution:\n    def removeNthFromEnd(self, head, n):\n        fast = slow = head\n        for _ in range(n):\n            fast = fast.next\n        if not fast:\n            return head.next\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        slow.next = slow.next.next\n        return head\n```\n\n\n\n","tags":["list"],"categories":["leetcode"]},{"title":"3Sum","url":"/2019/01/24/20190124/","content":"\nleetcode第15题\n<!-- more -->\n\n# 问题\n\nGiven an array `nums` of *n* integers, are there elements *a*, *b*, *c* in `nums` such that *a*+ *b* + *c* = 0? Find all unique triplets in the array which gives the sum of zero.\n\n**Note:**\n\nThe solution set must not contain duplicate triplets.\n\n例子\n\n```\nGiven array nums = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n```\n\n# 解答\n\n比第18题简单一些，原理差不多\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int>> results;\n        sort(nums.begin(),nums.end());\n        int n=nums.size();\n       // if(n)\n        for(int i=0;i<n-2;i++){\n            while(i>0&&nums[i]==nums[i-1]){\n                i++;\n            }\n            int left=i+1,right=n-1;\n            while(left<right){\n                int sum2 = nums[left]+nums[right];\n                if(sum2<0-nums[i]){\n                    left++;\n                }\n                else if(sum2>0-nums[i]){\n                    right--;\n                }\n                else{\n                    results.push_back( vector<int>{nums[i],nums[left],nums[right]} );\n                    do{ left++; }while( nums[left]==nums[left-1] && left<right );\n                    do{ right--; }while( nums[right]==nums[right+1] && left<right );\n                }\n            }    \n        }\n        return results;\n    }\n};\n```\n\n","tags":["leetcode"],"categories":["leetcode"]},{"title":"有效的括号","url":"/2019/01/23/20190123/","content":"\nleetcode第20题\n<!-- more -->\n\n# 问题\n\nGiven a string containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n\nNote that an empty string is also considered valid.\n\n例子\n\n```\nInput: \"()\"\nOutput: true\nInput: \"()[]{}\"\nOutput: true\nInput: \"(]\"\nOutput: false\n\n```\n\n# 解\n\nc++解法：\n\n```\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> character;\n        for(int i=0;i<s.size();i++){\n            char c=s[i];\n            switch(c){\n                case '(': character.push(c); break;\n                case '{': character.push(c); break;\n                case '[': character.push(c); break;\n                case ')': \n                    if (character.empty() || character.top()!='(')\n                        return false;\n                    else character.pop();\n                    break;\n                case '}': \n                    if (character.empty() || character.top()!='{') \n                        return false; \n                    else character.pop(); \n                    break;\n                case ']': \n                    if (character.empty() || character.top()!='[') \n                        return false;\n                    else character.pop(); \n                    break;\n                default: ; // pass \n            }\n        }\n        return character.empty();\n    }\n};\n\n```\n\npython3\n\n```\nclass Solution:\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        stack = []\n        dicts = {\"]\":\"[\", \"}\":\"{\", \")\":\"(\"}\n        for charr in s:\n            if charr in dicts.values():\n                stack.append(charr);\n            elif charr in dicts.keys():\n                if stack==[] or dicts[charr]!=stack.pop():\n                    return False\n            else:\n                return False\n        return stack==[]\n```\n\n","tags":["leetcode"],"categories":["leetcode"]},{"title":"四个数字相加等于指定数","url":"/2019/01/22/20190122/","content":"\nleetcode第18题\n<!-- more -->\n\n\n\n# 问题\n\nGiven an array `nums` of *n* integers and an integer `target`, are there elements *a*, *b*, *c*, and *d* in `nums` such that *a* + *b* + *c* + *d*= `target`? Find all unique quadruplets in the array which gives the sum of `target`.\n\n**Note:**\n\nThe solution set must not contain duplicate quadruplets.\n\n#### 例子\n\n```\nGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0.\n#就是看这里面哪四个数相加能等于0\nA solution set is:\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n```\n\n# 解\n\n【python】\n\n采用嵌套的方式比较好解这个题\n\n设要求nums数集里N个数的和，满足target\n\n```\n先把nums的数排序，然后调用函数findsum：\n1、检查是否为空解，以下条件满足则return：\n      nums长度<N||\n      target<nums最小值 * N||\n      target>nums最大值 * N\n   \n2、\nif N>2\n  i 从第一个到倒数第三个：\n    如果第i个和第i-1个相同，则跳过去，避免重复\n    findsum（nums[i+1:],target-nums[i],result+nums[i],results）\n    (result是每一个条目，组成了结果results)\n    \n    \n3、\nif N==2\n   l=0,r=nums[-1]\n   while l<r:\n       如果找到了一对数 nums[l]+nums[r]==target\n           则加入results：results.append(result+[nums[l]+nums[r]])\n           左侧游标移动一位l=l+1\n           把重复的跳过去\n       如果 和小于目标，则左侧游标往右边移动\n       如果 和大于目标，则右侧游标往左侧移动\n           \n```\n\n\n\n```\ndef fourSum(self, nums, target):\n    def findNsum(nums, target, N, result, results):\n        if len(nums) < N or N < 2 or target < nums[0]*N or target > nums[-1]*N:  # early termination\n            return\n        if N == 2: # two pointers solve sorted 2-sum problem\n            l,r = 0,len(nums)-1\n            while l < r:\n                s = nums[l] + nums[r]\n                if s == target:\n                    results.append(result + [nums[l], nums[r]])\n                    l += 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                elif s < target:\n                    l += 1\n                else:\n                    r -= 1\n        else: # recursively reduce N\n            for i in range(len(nums)-N+1):\n                if i == 0 or (i > 0 and nums[i-1] != nums[i]):\n                    findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\n\n    results = []\n    findNsum(sorted(nums), target, 4, [], results)\n    return results\n```\n\n【c++】\n\n不使用嵌套的话，也是一样的意思，给nums排序，先固定第一个数，再固定第二个数，找后两个数的和满足target-nums[i]-nums[j]的组合，再依次换第二个数第一个数。\n\n```\n第一个数i从0到倒数第四个：\n    if（第i个=第i-1个）重复了，本轮跳过去\n    if（前四个数和>目标）结束，没找到符合的数\n    if（第i个+倒数3个数<目标）第i个数太小，本轮跳过去\n    第二个数j从i+1到倒数第三个：\n        if（第j个=第j-1个）重复了跳过去\n        if（第一个数i+j范围内的前三个数>目标）数太大，结束\n        if（第一个数i+j范围内最后三个数<目标）数太小，本轮跳过去\n        设定left=j+1，right=n-1最后两个数从头和尾开始遍历\n        while（left<right）\n            sum=[left]+[right]+[i]+[j]\n            if （sum<目标） 和小了要增大值 left++\n            if （sum>目标） 和大了要减小值 right--\n            else\n                说明sum=目标，\n                把{[i],[j],[left],[right]}加入结果\n                如果左右两个值重复了则跳过去\n return\n                \n            \n```\n\n\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        vector<vector<int>> total;\n        int n = nums.size();\n        if(n<4)  return total;\n        sort(nums.begin(),nums.end());\n        for(int i=0;i<n-3;i++)\n        {\n            if(i>0&&nums[i]==nums[i-1]) continue;\n            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;\n            if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target) continue;\n            for(int j=i+1;j<n-2;j++)\n            {\n                if(j>i+1&&nums[j]==nums[j-1]) continue;\n                if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;\n                if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;\n                int left=j+1,right=n-1;\n                while(left<right){\n                    int sum=nums[left]+nums[right]+nums[i]+nums[j];\n                    if(sum<target) left++;\n                    else if(sum>target) right--;\n                    else{\n                        total.push_back(vector<int>{nums[i],nums[j],nums[left],nums[right]});\n                        do{left++;}while(nums[left]==nums[left-1]&&left<right);\n                        do{right--;}while(nums[right]==nums[right+1]&&left<right);\n                    }\n                }\n            }\n        }\n        return total;\n    }\n};\n```\n\n","categories":["leetcode"]},{"title":"Letter Combinations of a Phone Number","url":"/2019/01/21/20190121/","content":"\nleetcode第17题\n<!-- more -->\n\n# 问题\n\nGiven a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n给定包含“2-9”数字的字符串，返回该数字可能表示的所有字母组合。\n\n下面给出一个数字到字母的映射(就像电话按钮一样)。注意1不映射到任何字母。\n\n![img](https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png)\n\n例子\n\n```\nInput: \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n```\n\n# 解\n\n```\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        string m[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        vector<string> res;\n        if(digits==\"\"){\n            return res;\n        }\n        res.push_back(\"\");\n        for(int n=0;n<digits.size();n++){\n            int num=digits[n]-'0';\n            if(num<0||num>9){\n                break;\n            }\n            string x=m[num];\n            vector<string> nres;\n            \n            for(int j=0;j<res.size();j++){\n                for(int i=0;i<x.size();i++){\n                    nres.push_back(res[j]+x[i]);\n                }\n            }\n            res.swap(nres);\n        }\n        return res;\n    }\n};\n```\n\n","categories":["leetcode"]},{"title":"C++STL之哈希表||unordered_map","url":"/2019/01/20/20190120/","content":"\nC++ STL中，哈希表对应的容器是 `unordered_map`（since C++ 11）。根据 C++ 11 标准的推荐，用 `unordered_map` 代替 `hash_map`。\n\n<!-- more -->\n\n## 哈希表\n\n先来回顾一下数据结构中哈希表相关的知识。\n\n哈希表是根据关键码值(key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数。\n\n哈希表的一个重要问题就是如何解决映射冲突的问题。常用的有两种：**开放地址法** 和 **链地址法**。\n\nSTL中，`map` 对应的数据结构是 **红黑树**。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 **O(logN)**。而 `unordered_map` 对应 **哈希表**，哈希表的特点就是查找效率高，时间复杂度为常数级别 **O(1)**， 而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 `unordered_map` 容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 `map` 容器。\n\n## 说明\n\n- unordered_map 是一种关联容器，用于存储由关键值 (Key Value，以下称为Key 值) 和映射值 (Mapped Value，以下称为映射值) 组成的元素，并且允许根据其 Key 值快速检索各个元素。 \n\n- 在 unordered_map 容器中，Key 值通常用来唯一标识元素，映射值是与该 Key 值关联内容的对象。Key 值与映射值的类型可能不同。 \n\n- 在 unordered_map 内部，元素没有按照其 Key 值与映射值的任何顺序进行排序 ，而是根据它们的 Hash 值组织成桶，允许它们通过其 Key 值直接快速访问单个元素（通常具有常数等级的平均时间复杂度）。 \n\n- unordered_map 容器与 map 容器相比，通过 Key 值访问各个元素的速度更快，然而通过其元素子集进行范围迭代的效率通常较低。 \n\n- unordered_map 实现了直接访问操作符 (operator[])，它允许使用 Key 值作为输入参数，直接访问映射值。 \n\n- 容器中的迭代器至少是前向迭代器。\n\n  ## 容器属性\n\n  **关联性** \n  关联容器中的元素的参考地址指的是其 Key 值，而不是他们在容器中的绝对地址；\n  **无序性** \n  无序容器使用 Hash 表来组织元素，这些 Hash 表允许无序容器通过 Key 值快速访问元素；\n  **映射** \n  每个元素将一个 Key 值与映射值关联起来，Key 值用于标识其主要内容是映射值的元素；\n  **唯一关键值** \n  容器中不存在同时拥有相同 Key 值的两个元素；\n  **分配器感知** \n\n  map 容器使用分配器对象动态处理其存储需求。\n\n## 常用函数\n\n#### bucket\n\nsize_type bucket ( const key_type& k ) const;\n\n定位元素所在的桶，返回 Key 值为输入参数 k 的元素的所在桶号。 \n桶是容器内部 Hash 表中的一个槽，槽中的元素根据 Key 值分配元素。桶号的编号从 0 到 (bucket_count - 1)。 桶中单个元素可以通过 unordered_map::begin 和 unordered_map::end 返回的范围迭代器进行访问。\n\n#### count\n\nsize_type count ( const key_type& k ) const;\n\n搜索容器中 Key 值为输入参数 k 的元素，并返回找到元素的数量。由于 unordered_map 容器不允许存在重复的 Key 值，这说明如果容器中存在具有该 Key 值的元素，则该函数返回 1，否则返回 0。\n\n#### clear\n\n 清除 map 中所有元素；\n\n#### erase\n\n 删除 map 中指定位置的元素；\n\n#### insert\n\n 在 map 指定位置添加 pair 类型的元素；\n\n#### find\n\n 获取 map 中元素的迭代器；\n\n#### begin, end\n\n map 的正向迭代器的起始位置与终点位置\n\n## 例题\n\n摘选自[ Leetcode 问题 Two Sum](https://leetcode.com/problems/two-sum/description/)：给出一个整数数组，返回两个数的下标值，令其和等于一个指定的目标值。\n\n例子\n\n```\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n```\n\n解\n\n```\n#include <unordered_map>\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int> &numbers, int target)\n    {\n        //Key is the number and value is its index in the vector.\n        unordered_map<int, int> hash;\n        vector<int> result;\n        for (int i = 0; i < numbers.size(); i++) {\n            int numberToFind = target - numbers[i];\n\n            //if numberToFind is found in map, return them\n            if (hash.find(numberToFind) != hash.end()) {\n                result.push_back(hash[numberToFind]);\n                result.push_back(i);            \n                return result;\n            }\n\n            //number was not found. Put it in the map.\n            hash[numbers[i]] = i;\n        }\n        return result;\n    }\n};\n```\n\n","tags":["c++"],"categories":["c++"]},{"title":"Integer to Roman and roman to integer","url":"/2019/01/19/20190119/","content":"\nleetcode第12题和13题\n<!-- more -->\n\n# 问题1\n\n罗马数字由七种不同的符号表示:I、V、X、L、C、D和M。\n\n```\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\n例如，2在罗马数字中写成II，只是两个1相加。12写成，XII，也就是X + II。数字27写成XXVII，也就是XX + V + II。\n\n罗马数字通常从左到右从大到小。然而，4的数字不是IIII。相反，数字4写成IV，因为1在5之前我们减去它得到4。同样的原理也适用于数字9，即写为IX。使用减法的情况有六种:\n\n- I可以放在V(5)和X(10)之前得到4和9。\n\n- X可以放在L(50)和C(100)之前，得到40和90。\n\n- C可以放在D(500)和M(1000)之前，得到400和900。\n\n  \n\n  给定一个整数，将其转换为罗马数字。输入保证在1到3999之间。\n\n  ```\n  Input: 3\n  Output: \"III\"\n  \n  Input: 4\n  Output: \"IV\"\n  \n  Input: 9\n  Output: \"IX\"\n  \n  Input: 58\n  Output: \"LVIII\"\n  Explanation: L = 50, V = 5, III = 3.\n  ```\n\n  # 极其机智的解答\n\n  依次把个位十位百位千位挑出来\n\n```\npublic static String intToRoman(int num) {\n    String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\n    String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n    String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n    String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];\n}\n```\n\n# 问题2\n\n把上一题反过来\n\n# 解答\n\n通过从后到前处理字符串并使用映射，问题更容易解决。运行速度为88毫秒。\n\n*string*::front –访问第一个字符; \n\n*string*::*back* –访问最后一个字符;\n\n *string*::data –访问基础数组\n\n```\nint romanToInt(string s) \n{\n    unordered_map<char, int> T = { { 'I' , 1 },\n                                   { 'V' , 5 },\n                                   { 'X' , 10 },\n                                   { 'L' , 50 },\n                                   { 'C' , 100 },\n                                   { 'D' , 500 },\n                                   { 'M' , 1000 } };\n                                   \n   int sum = T[s.back()];\n   for (int i = s.length() - 2; i >= 0; --i) \n   {\n       if (T[s[i]] < T[s[i + 1]])\n       {\n           sum -= T[s[i]];\n       }\n       else\n       {\n           sum += T[s[i]];\n       }\n   }\n   \n   return sum;\n}\n```\n\n","categories":["leetcode"]},{"title":"分层强化学习","url":"/2019/01/18/2019011801/","content":"\n[TOC]\n\n\n\n# 1为什么会出现分层强化学习\n\n​        强化学习要研究的问题是智能体（agents）如何在一个环境（environment）中学到一定的策略（policy），使得长期的奖赏（reward）最大。 但是传统的强化学习方法面临着维度灾难，即当环境较为复杂或者任务较为困难时，agent的状态（state）空间过 大，会导致需要学习的参数以及所需的存储空间急速增长，强化学习难以取得理想的效果。 为了解决维度灾难，研究者提出了分层强化学习（hierarchical reinforcement learning，HRL）。HRL 的主要目标是将复杂的问题分解成多个小问题，分别解决小问题从而达到解决原问题的目的。 近些年来，人们认为分层强化学习基本可以解决强化学习的维度灾难问题，转而将研究方向转向如何将复杂的问题抽象成不同的层级，从而更好地解决这些问题。 \n\n# 2背景知识\n\n​        本部分主要介绍强化学习、马尔可夫决策过程mdp和半马尔可夫决策过程semi-mdp的相关内容和背景知识。\n\n## 2.1RL与MDP\n\n​        强化学习主要研究的问题是agent通过和environment直接交互的过程来学习策略，使得达到目标后的总体奖励最大。大多数关于强化学习RL的研究都建立在马尔可夫决策过程MDP上。\n\n#### 2.1.1马尔可夫决策过程的定义\n\n​        MDP可以表示为一个五元组〈Ｓ，Ａ，Ｐ，Ｒ，γ〉。 其中，Ｓ为环境状态state的有限集合，集合中某个状态表示为s∈S；A为动作 action的有限集合，集合中某个动作表示为 a∈A，A 为状态s下可执行的动作集合；P状态转移方程，P(s′|s,a) 表示在状态s执行动作a后将以 P的概率跳转到状态 s′；R为奖赏函数；γ 为折损系数， ０≤γ≤１。 \n\n​        假设一个agent观察到自己的状态s，此时它选择一个动作a，它会得到一个即时的奖赏ｒ=R(s,a)，然后以 P(s′ |s,a) 的概率达到下一个状态s′。 马尔可夫决策过程有马尔可夫性，即系统的下个状态只与当前状态有关，与之前的状态无关。 当马尔可夫决策过程中作出决策时，只需要考虑当前的状态，而不需要历史数据，这样大大降低了问题的复杂度。 \n\n{% asset_img 131433102201.jpg This is an example image %}\n\n![01](2019011801\\131433102201.jpg)\n\n#### 2.1.2值函数\n\n​        强化学习需要agent学习到一个策略 π，通过 π (s,a) 的值来指导agent进行动作的选择。衡量这个策略的标准依赖于回报，增强学习往往具有延迟回报的特点 : 如果在第n步输掉了棋，那么只有状态sn和动作an获得了立即回报r(sn,an)=-1，前面的所有状态立即回报均为0。所以对于之前的任意状态s和动作a，立即回报函数r(s,a)无法说明策略的好坏。因而需要定义值函数 (value function，又叫效用函数) 来表明当前状态下策略π的长期影响。 \n\n​        令Ｖ(ｓ) 表示在状态s的**值函数**，即从状态s开始一直按照某个策略执行最终达到终止状态的期望累计奖赏。我们的目标是希望学到一个最优的策略 π，最大化每一个状态下的Ｖ值。\n\n![02](2019011801\\02.png)\n\n是值函数最常见的形式，式中γ∈[0,1]称为折合因子，表明了未来的回报相对于当前回报的重要程度。特别的，γ=0时，相当于只考虑立即不考虑长期回报，γ=1时，将长期回报和立即回报看得同等重要。接下来把这个值函数展开，其中ri表示未来第i步回报，s'表示下一步状态，则有：\n\n![03](2019011801\\03.png)\n\n给定策略π和初始状态s，则动作a=π(s)，下个时刻将以概率p(s'|s,a)转向下个状态s'，那么上式的期望可以拆开，可以重写为：\n\n![04](2019011801\\04.png)\n\nπ和初始状态s是我们给定的，而初始动作a是由策略π和状态s决定的，即a=π(s)。\n\n#### 2.1.3动作值函数\n\n​        除了值函数，期望累计奖赏也可以用**动作-值函数**来表示，令 Ｑ(s,a)  在状态s执行动作a之后按照某个策略执行直到达到终止状态的期望累计奖赏。我们也希望通过学习到一个最优的Ｑ函数，使agent可以直接通过Ｑ函数来选择当前状态下应该执行的动作。定义动作值函数(action value functionQ函数)如下：\n\n![05](2019011801\\05.png)\n\n给定当前状态s和当前动作a，在未来遵循策略π，那么系统将以概率p(s'|s,a)转向下个状态s'，上式可以重写为：\n\n![06](2019011801\\06.png)\n\n在Qπ(s,a)中，不仅策略π和初始状态s是我们给定的，当前的动作a也是我们给定的，这是Qπ(s,a)和Vπ(a)的主要区别。\n\n​        知道值函数的概念后，一个MDP的最优策略可以由下式表示：\n\n![07](2019011801\\07.png)\n\n即我们寻找的是在任意初始条件s下，能够最大化值函数的策略π*。\n\n​        经过多年的研究，已经出现一些算法，致力于解决传统的强化学习问题，比如Ｑ⁃learning、蒙特卡洛方法（Monte-Carlo learning）、时 序 差 分方法（temporal-difference learning）等。其中 Ｑ⁃learning 方法常常在分层强化学习中被使用。Ｑ⁃learning通 过不断迭代更新Ｑ函数的值来逼近最优的Ｑ∗。\n\n#### 2.1.4Ｑ⁃learning\n\n[ql]: http://zhangmeng.ga/2019/01/17/20190116001/\t\"ql\"\n\n\n\n## 2.2 SMDP\n\n​        青蛙在荷叶上跳动，在每个不同的荷叶上表示不同的状态，从一个荷叶跳到另一个荷叶表示状态的转移，该转移过程只依赖于现在所处荷叶，而与以前呆过的荷叶无关，如果只考虑青蛙跳跃的时刻序列，这个过程就是离散时间的马氏过程，如果考虑青蛙在荷叶上呆了一段时间，且这段时间是服从指数分布的，那这个过程是连续时间马氏过程，如果时间是非指数分布的，那这个过程是半马氏分布。\n\n​        马尔可夫决策过程中，选择一个动作后，agent 会立刻根据状态转移方程P跳转到下一个状态，而在半马尔可夫决策过程SMDP中，当前状态到下 一个状态的步数是个随机变量 τ，即在某个状态s下选择一个动作a，经过 τ 步才会以一个概率转移到下一个状态s′。 此时的状态转移概率是s 和 τ 的联合概率P（s′,τ |s,a）。 根据 τ 的定义域不同，SMDP所定义的系统也有所不同。 当 τ 的取值为实数值，则SMDP构建了一个连续时间-离散事件系统；而当 τ 的取值为正整 数，则是一个离散时间SMDP。 出于简单考虑，绝大部分分层强化学习都是在离散时间SMDP上进行讨论。 \n\n# 3分层强化学习\n\n​        分层强化学习是将复杂的强化学习问题分解成一些容易解决的子问题，通过分别解决这些子问题，最终解决原本的强化学习问题。 常见的分层强化学习方法可以大致分为四种，分别为基于选项的强化学习、基于分层抽象机 的分层强化学习、基于 MaxQ函数分解的分层强化学习，以及端到端的分层强化学习。本节将对它们逐一进行探讨。 \n\n​        对于HRL，抽象是至关重要的。通过抽象可去掉子任务中一些冗余或无关的信息，简化问题的表示，更容易、更方便地解决问题。在HRL中，抽象包括时间抽象 (动作抽象) 和空间抽象 (状态抽象) 。\n\n​        时间抽象是一种将若干动作封装在一起， 被视为单个抽象动作，其主要目的在于充分利用问题的分层结构。每个抽象动作对应一个定义在环境状态子集上、具有终止条件的闭环局部策略，研究者有时称这些策略为抉择(options)、时间扩展的动作(temporally-extended actions)。抽象动作允许 agent 按照其局部策略用多个时间步调用所封装的底层动作，直到终止。【个人理解：其实就是把几个小动作封装成一个整体，在状态s下通过全局策略的决定进入这个大的整体之后，按照这个整体内部自己的局部策略执行小动作，在达到终止条件的时候结束这个整体动作，达到一个宏观上的新状态，再通过全局策略选择下一个整体动作进入。】\n\n​        空间抽象可分为两种情况，一种是将若干状态封装在一起，被视为单个抽象状态；另一种是针对环境状态可用矢量表示，即状态可分解的情形，删掉与子任务无关的状态变量，从而达到简化状态表示的目的。\n\n### 3.1基于选项的分层强化学习\n\n​        基于option的分层强化学习的过程如下：假设 agent 当前在某个状态，选择一个option，通过这个 option的策略，agent 选择了一个动作或者另一个 option。 若选择了一个动作，则直接执行转移到下一 个状态；若选择了另一个 option，则用选择的新 option继续选择，直到最后得出一个动作。\n\n​        最简单的option为直接定义在MDP上的马尔可夫option，是一个三元组 < I , Π , T> 。其中：l∈S是option入口状态集合； Π：s×A[0，1]为option内部策略；T：S [ 0，1 ]为option终止条件，也就是出口。当option被激活后，agent根据 Π 选择执行的动作，最后根据 T 随机终止。对于任意动作a∈A可看成是单步opfion。\n\n​        另一种比较灵活的option是半马尔可夫option，其内部策略和终止条件均依赖于option激活后所经历的状态、动作和回报等历史。令Ω表示历史集，形式上半马尔可夫option也是一 个三元组< I , Π , T>。I 的含义与马尔可夫option的 I 相同，但内部策略和终止条件分别定义为 Π ：ΩXA→[0，1]和T：Ω→ [0，1]。 \n\n​         令O为option集合。如果将策略定义在options之上，即定义为 μ ：s×O→[0，1]，则形成options分层机制。在这种机制下，agent根据 μ 选择一个option执行，直到终止，agent再依照 μ 选择另一个option执行，依此类推。如果将O叠加到 MDP上，将产生一个离散时间SMDP，因而可使用SMDP所有的理论和算法。\n\n​        把MDP单步模型里的action替换成options并去掉折合因子，就可以得到最优值函数和最优option值函数：\n\n![08](2019011801\\08.png)\n\n​        此时的Q-Learning的更新公式为：\n\n![09](2019011801\\09.png)\n\n其中，ak为第k轮迭代时的学习率，τ 表示option  o 在执行 τ 步之后在状态 St+τ 停止，而 ｏ′ 为在 ｏ 执行 结束后的下一个option。 可以注意到，**当所有的option均为one⁃step option时，这个Ｑ⁃learning就退 化为普通的Ｑ⁃learning过程。** \n\n### 3.2基于分层抽象机的分层强化学习\n\n​        分层抽象机（hierarchies of abstract machines,HAMs）是Parr和Russell提出的方法。和option的方法类似，HAMs的方法也是建立在SMDP 的理论基础之上的。 HAMs的主要思想是将当前所在状态以及有限状态机的状态结合考虑，从而选择不同的策略。 \n\n​        令M为一个有限MDP，{Hi}为一个有限状态机集合，每个有限状态机都有一个状态集合Si、一个概率转移方程以及一个随机函数fi。状态集合包括：action、call、choice、stop。\n\n- action类型的状态会根据状态机的具体状态执行一个MDP中的动作。\n\n- call类型的状态时，当前状态机被挂起，根据该状态机的当前状态得到下一个状态机，对其用随机函数初始化（得到状态）。\n\n- choice类型的状态时，不确定地选择当前状态机地下一个状态。\n\n- stop类型的状态时，停止当前状态机的活动，恢复调用它的状态机的活动，同时agent根据之前的动作进行动作转移并得到奖励。（如果某个状态机H刚被调用就被随机函数初始化到了stop状态，返回的时候没有选出来要执行的动作，则M保持当前的状态。）\n\n  ![10](2019011801\\10.png)\n\n  \n\n  ​         总之，options和HAM都是把MDP转换为了单个SMDP问题，而MAXQ和HEXQ方法创建了多个SMDP的分层，使得每个SMDP同时学习。\n\n  ### 3.3基于 MaxQ函数分解的分层强化学习\n\n  ​        MaxQ 值分解是由Dietterich提出的另外一种分层强化学习的方法。首先把一个马尔可夫决策过程M分解成多个子任务{M0，M1,...,Mn}, M0为根子任务，解决了它就意味着解决了原问题M。每一个子任务都有一个终止断言T和一个动作集合A。A中的元素可以是其他的子任务也可以是一个MDP中的action。子任务的目标是转移到一个状态可以满足终止断言使得子任务完成并终止。\n\n  图１为利用MaxQ方法解决出租车问题的任务划分示意图：\n\n  ![11](2019011801\\11.png)\n\n  ​        出租车问题是指一个出租车agent需要到特定位置接一位乘客并且把他送到特定的位置让其下车。 一共有6个动作，分别是上车（pickup）、下车 (dropoff），以及向东南西北四个方向开车的动作。 这里使用MaxQ方法，将原问题分解成了get和put两个子任务，这两个子任务又进行分解，get分解成一个基本动作pickup和一个子任务navigate，而put也分解成了一个基本动作dropoff和一个子任务navigate。 子任务navigate(t)表示t时刻应该开车的方向。 对于这个强化学习问题，agent首先选择get， 然后get子问题navigate，直到到达乘客所在地，然后get选择pickup动作，乘客上车。 之后agent选择put子任务，put子任务选择navigate，直到到达乘客目的地，之后put子任务选择dropoff动作，乘客下车，任务完成。 \n\n  ### 3.4端到端的分层强化学习\n\n  ​         上述3种方法，都需要人工来做很多工作， 比如人工进行option的选取，人工进行HAMs的构 建，人工划分子任务等。 人工设计不仅耗时耗力， 并且会直接影响最终强化学习结果的好坏。 近些年来人们关注如何让agent自己学到合理的分层抽象，而非人为进行划分和指定。\n\n  。。。。。。\n\n  ## 4对比\n\n  ![12](2019011801\\12.png)\n\n分层最优指的是：该策略是与分层结构兼容的所有分层策略中具有最高累计回报的策略。\n\n递归最优指的是：一个分层策略使得对于每个子任务，对应的策略都是最优的。\n\n分层最优策略和递归最优策略的根本区别在于，前者的子任务不仅要考虑所调用的下级子任务，也要考虑如何加入到上级子任务中；而后者的子任务没有考虑其应用环境。\n\n安全状态抽象是指值函数在抽象前后保持一致的状态抽象。","tags":["reinforcement learning"],"categories":["reinforcement learning"]},{"title":"Container With Most Water","url":"/2019/01/17/2019011702/","content":"\n# 问题\n\nGiven *n* non-negative integers *a1*, *a2*, ..., *an* , where each represents a point at coordinate (*i*, *ai*). *n* vertical lines are drawn such that the two endpoints of line *i* is at (*i*, *ai*) and (*i*, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n\n**Note:** You may not slant the container and *n* is at least 2.\n\n给定n个非负整数a1 a2…， an，其中每个点表示坐标(i, ai)上的一个点。画n条垂直线，使直线i的两个端点分别为(i, ai)和(i, 0)，找出两条直线，它们与x轴一起构成一个容器，使容器中含有最多的水。\n\n注意:容器不能倾斜，n至少为2。\n\n\n\n\n\n因为所求水是【两个直线x轴的差 * 短直线的y轴值】，先要使前者尽量大，所以从头和尾开始推进，计算当前面积，然后\n\n1.长的一边先保留，推进短的一边。这种方法慢一些。\n\n2.两边都找下一个比短边长的，比短边还短的直接忽略。这种方法快。\n\n# C++解\n\n```\n30ms：\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int i=0,j=height.size()-1;\n        int water=0;\n        while(i<j){\n            water=max(water,min(height[i],height[j])*(j-i));\n            if(height[i]<height[j]){\n                i++;\n            }\n            else{\n                j--;\n            }\n        }\n        return water;\n    }\n};\n\n16ms:\nclass Solution {\n    public:\n    int maxArea(vector<int>& height) {\n       int water = 0;\n       int i = 0, j = height.size() - 1;\n       while (i < j) {\n           int h = min(height[i], height[j]);\n           water = max(water, (j - i) * h);\n           while (height[i] <= h && i < j) i++;\n           while (height[j] <= h && i < j) j--;\n       }\n    return water;\n   }\n};\n```\n\n# python写法\n\n```\nclass Solution:\n    def maxArea(self, height):\n        i, j = 0, len(height) - 1\n        water = 0\n        while i < j:\n            water = max(water, (j - i) * min(height[i], height[j]))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return water\n```\n\n","tags":["leetcode"],"categories":["leetcode"]},{"title":"Policy Gradients","url":"/2019/01/17/2019011701/","content":"\n策略梯度\n\n<!-- more -->\n\n强化学习是一个通过奖惩来学习正确行为的机制. 家族中有很多种不一样的成员, 有学习奖惩值, 根据自己认为的高价值选行为, 比如 Q learning, Deep Q Network, 也有不通过分析奖励值, 直接输出行为的方法, 这就是今天要说的 Policy Gradients 了. \n\nPolicy gradient 是 RL 中另外一个大家族, 他借用神经网络，在无穷多的动作中计算价值, 从而选择行为。不像 Value-based 方法 (Q learning, Sarsa), 他也要接受环境信息 (observation), 不同的是他**要输出不是 action 的 value, 而是具体的那一个 action**, 这样 policy gradient 就跳过了 value 这个阶段. 而且个人认为 Policy gradient 最大的一个优势是: 输出的这个 action 可以是一个连续的值, 之前我们说到的 value-based 方法输出的都是不连续的值, 然后再选择值最大的 action. 而 policy gradient 可以在一个连续分布上选取 action.\n\n### 算法\n\n![](2019011701\\2159902-13d5d1a3acbf2157.png)\n\n在深度强化学习中，**Policy Π 可以看做是一个参数为 θ 的神经网络**，输入当前的state，输出可能的action的概率分布，选择概率最大的一个action作为要执行的操作。\n\nPolicy Gradient不通过误差反向传播，它通过观测信息选出一个行为直接进行反向传播，当然出人意料的是他并没有误差，而是利用reward奖励直接对选择行为的可能性进行增强和减弱，好的行为会被增加下一次被选中的概率，不好的行为会被减弱下次被选中的概率。\n\n以游戏为例，从游戏开始到结束，叫做一个episode，简单理解为回合。episode结束，游戏过程中所有的reward相加得到该回合的总reward（角色挂与未挂可能是一个负reward或一个大的正reward）。\n\n![](D:\\hexo\\web2\\source\\_posts\\2019011701\\2159902-ddae732feac73216.png)\n\n这里强化学习的目标就是学习一个Policy，即一个网络，使其每看到一个画面，做出一个action, 并做到最终获得最大总reward。\n\n#### 算法细节\n\n游戏的进程相应的可以表示成state,action交替的序列：\n\n![](2019011701\\2159902-2083b56a56aada88.png)\n\n游戏引擎（Environment）产生一个画面（state）,接着神经网络玩家（Actor）产生一个action，接着影响Environment，并产生下一个state，如此反复到游戏结束，一个完整的序列（1-T）为一个Trajectory，一轮游戏一轮回合，或者叫一轮采样。该序列发生的概率，即在策略Π 的参数为θ 情况下Trajectory τ发生的概率：\n\n![](2019011701\\2159902-4ddd6fd020512976.png)\n\n这样在此Trajectory下会得到一个总的回报R(τ)，可以想到，玩游戏有很大的随机性，不同的action就可能会有不同的state，反之亦然。因此R(τ)实际是一个变量（根据游戏场景过程的变化而变化），因此为了衡量一个策略Π的好坏，需要考虑一个期望的回报R_E(τ)。游戏的过程当然也不可能穷举，因此就需要采样来计算期望回报（“平均”回报），可以理解为Policy固定情况下反复的试玩N回合游戏，每回合的reward***以回合发生概率为权重相加取平均***，即为当前策略的期望reward。目标也就是***不断更新Policy的参数θ，使期望reward得到最大***。****\n\n![](2019011701\\2159902-9f56dcfcdca9ffca.png)\n\n#### 策略梯度提升\n\n有了目标，下面就是用合适的方法，使期望reward最大，一种方法便是策略梯度提升的方法（与最小化loss的梯度下降相对）。由上面可知期望reward是参数θ的函数，所以参数更新的方式为：\n\n![](2019011701\\2159902-aea1a369ca61875b.png)\n\n下面的问题就是期望reward对θ的导数的求法，走一波公式推导：\n\n![](2019011701\\2159902-0e5293f2a59fb71f.png)\n\n公式推导并不复杂，主要是蓝框里的一个常用小技巧变换（同时乘和除f(x)）。然后第二行等式到第三行将累加转换为期望表示；接着约等于N次采样的期望值。第三行到第四行将上面的p_{θ}(τ)带入，去掉与θ无关的环境相关概率p(s_{t+1}|s_t, a_t)和p(s_1),得到最终结果：\n\n![](2019011701\\2159902-666c1f7037af194e.png)\n\n下面就是不断采样，更新参数的过程（根据当前策略玩游戏，得回报，修正策略）：\n\n![](2019011701\\2159902-8a275b32e2655751.png)\n\n图示左边表示根据当前policy参数采样得到N个Trajectory，计算一次期望reward，然后梯度上升的方法更新policy参数，用更新后的policy再进行下一轮采样，如此往复直到收敛，得到期望reward最大的policy。最终该policy（神经网络表示）就学会了根据游戏画面做合适的action，最终赢得游戏。\n\n##### 优点：\n\n- 连续的动作空间（或者高维空间）中更加高效；\n- 可以实现随机化的策略；\n- 某种情况下，价值函数可能比较难以计算，而策略函数较容易。\n\n##### 缺点：\n\n- 通常收敛到局部最优而非全局最优\n- 评估一个策略通常低效（这个过程可能慢，但是具有更高的可变性，其中也会出现很多并不有效的尝试，而且方差高\n\n\n\n","tags":["reinforcement learning"],"categories":["reinforcement learning"]},{"title":"Qlearning和sarsa","url":"/2019/01/17/20190116001/","content":"\n强化学习\n\n<!-- more -->\n\n强化学习 (Reinforcement Learning) 是一个机器学习大家族中的分支, 由于近些年来的技术突破, 和深度学习 (Deep Learning) 的整合, 使得强化学习有了进一步的运用. 比如让计算机学着玩游戏, AlphaGo 挑战世界围棋高手, 都是强化学习在行的事. 强化学习也是让你的程序从对当前环境完全陌生, 成长为一个在环境中游刃有余的高手.\n\n[TOC]\n\n\n\n\n#### 1.1 强化学习与监督学习，非监督学习之间的关系![img](https://img-blog.csdn.net/20180202094621583?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3N3dzQwNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n#### 1.2 强化学习的学习过程\n\n强化学习它有自己的一套学习方法，下图是强化学习的示意图：\n\n![img](https://img-blog.csdn.net/20180202094806935?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3N3dzQwNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n从图上我们可以看到强化学习它由两部分组成：智能体和环境。我们可以这样理解，俗话解释一下：\n\n比如，我们从沙发旁走到门口，当我们起身之后，首先大脑获取路的位置信息，然后我们确定从当前位置向前走一步，不幸运的是我们撞墙了，这明显是个负反馈，因此环境会给我们一个负奖励，告诉我们这是一个比较差的走路方式，因此我们尝试换个方向走（走哪个方向比较好呢，后文会会讲到随机策略、确定性策略等策略决策），就这样不断的和环境交互尝试，最终找到一套策略，确保我们能够从沙发旁边走到门口。在这个过程中会得到一个最大的累计期望奖励。基于以上过程，非常值得一提的是奖励函数的设置，因为这个强化学习过程中对智能体动作好坏的评价。\n\n#### 1.3 强化学习的应用\n\n说了这么多，为什么要学习这门技术呢，无非有两种原因，1、找到新方向，继续学术研究；2、将该技术能够实际的用到工业界中，产生效益。还是不谈人生谈技术， 那么强化学习目前有哪些应用呢？目前调查了有以下： \n\n  1、控制类：机械臂控制、视频游戏（CNN获取图像信息，提取特征信息等处理），无人驾驶等       https://www.youtube.com/watch?v=W_gxLKSsSIE&list=PL5nBAYUyJTrM48dViibyi68urttMlUv7e       https://www.youtube.com/watch?v=CIF2SBVY-J0       https://www.youtube.com/watch?v=5WXVJ1A0k6Q       https://www.youtube.com/watch?v=-YMfJLFynmA  \n\n 2、文本序列预测，机器翻译等 https://zhuanlan.zhihu.com/p/22385421， https://zhuanlan.zhihu.com/p/29168803   \n\n3、推荐系统：（https://m.aliyun.com/yunqi/articles/66158，http://geek.csdn.net/news/detail/112318）还有很多的应用场景，陆续补充，但用一句话总结：只要涉及到智能决策问题，在符合强化学习的学习规则的情况下的都可以使用。\n\n#### 2.1  Reward and return 奖励和回报\n\n当前在状态St，根据方针(policy) π(a|s)，选择了一个动作at；根据动态（dynamics） p(st+1|st,at)，到达了状态St+1。奖励（reward）是 rt = r(St,at,St+1)，累计的回报（return）Rt 就是把每一步的奖励加起来。如果简单地忽略衰减函数的话，我们只是想让期望的return最大化。\n\n#### 2.2 Value值\n\n在状态 s 采取动作 a 并且遵从方针 π 的value是：\n\n![d](20190116001\\微信截图_20190116205205.png)\n\n得到的期望是关于遵从方针和动态从(St = s,At = a) 生成的轨迹 (St+k,At+k,k =1 ,2,...) 。期望的最优值就是Q的最大值。\n\n同样，我们可以定义状态的值：\n\n![2](20190116001\\微信截图_20190116205236.png)\n\n#### 2.3 Q-learning\n\n![q1](20190116001\\q1.png)\n\n我们做事情都会有一个自己的行为准则, 比如小时候爸妈常说”不写完作业就不准看电视”. 所以我们在 写作业的这种状态下, 好的行为就是继续写作业, 直到写完它, 我们还可以得到奖励, 不好的行为 就是没写完就跑去看电视了, 被爸妈发现, 后果很严重. 小时候这种事情做多了, 也就变成我们不可磨灭的记忆. 这和我们要提到的 Q learning 有什么关系呢? 原来 Q learning 也是一个决策过程, 和小时候的这种情况差不多. 我们举例说明.\n\n假设现在我们处于写作业的状态而且我们以前并没有尝试过写作业时看电视, 所以现在我们有两种选择 , 1, 继续写作业, 2, 跑去看电视. 因为以前没有被罚过, 所以我选看电视, 然后现在的状态变成了看电视, 我又选了 继续看电视, 接着我还是看电视, 最后爸妈回家, 发现我没写完作业就去看电视了, 狠狠地惩罚了我一次, 我也深刻地记下了这一次经历, 并在我的脑海中将 “没写完作业就看电视” 这种行为更改为负面行为, 我们在看看 Q learning 根据很多这样的经历是如何来决策的吧.\n\n##### Q-Learning 决策 \n\n![q2](20190116001\\q2.png)\n\n假设我们的行为准则已经学习好了, 现在我们处于状态s1, 我在写作业, 我有两个行为 a1, a2, 分别是看电视和写作业, 根据我的经验, 在这种 s1 状态下, a2 写作业 带来的潜在奖励要比 a1 看电视高, 这里的潜在奖励我们可以用一个有关于 s 和 a 的 Q 表格代替, 在我的记忆Q表格中, Q(s1, a1)=-2 要小于 Q(s1, a2)=1, 所以我们判断要选择 a2 作为下一个行为. 现在我们的状态更新成 s2 , 我们还是有两个同样的选择, 重复上面的过程, 在行为准则Q 表中寻找 Q(s2, a1) Q(s2, a2) 的值, 并比较他们的大小, 选取较大的一个. 接着根据 a2 我们到达 s3 并在此重复上面的决策过程. Q learning 的方法也就是这样决策的. 看完决策, 我看在来研究一下这张行为准则 Q 表是通过什么样的方式更改, 提升的.\n\n##### Q-Learning 更新 [¶](https://morvanzhou.github.io/tutorials/machine-learning/ML-intro/4-03-q-learning/#Q-Learning-%E6%9B%B4%E6%96%B0)\n\n![q3](20190116001\\q3.png)\n\n所以我们回到之前的流程, 根据 Q 表的估计, 因为在 s1 中, a2 的值比较大, 通过之前的决策方法, 我们在 s1 采取了 a2, 并到达 s2, 这时我们开始更新用于决策的 Q 表。\n\n接着我们**并没有在实际中采取任何行为**, 而是再想象自己在 s2 上采取了每种行为, 分别看看两种行为哪一个的 Q 值大。比如说 Q(s2, a2) 的值比 Q(s2, a1) 的大, 所以我们把大的 Q(s2, a2) 乘上一个衰减值 gamma (比如是0.9) 并加上到达s2时所获取的奖励 R (这里还没有获取到我们的棒棒糖, 所以奖励为 0), 因为会获取实实在在的奖励 R , 我们将这个作为我现实中 Q(s1, a2) 的值。 但是我们之前是根据 Q 表估计 Q(s1, a2) 的值， 所以有了现实和估计值，我们就能更新Q(s1, a2) ， 根据 估计与现实的差距，将这个差距乘以一个学习效率 alpha 累加上老的 Q(s1, a2) 的值 变成新的值。 \n\n但时刻记住，我们虽然用 maxQ(s2) 估算了一下 s2 状态，但还没有在 s2 做出任何的行为，s2 的行为决策要等到更新完了以后再重新另外做。这就是 **off-policy** 的 Q learning 是如何决策和学习优化决策的过程.\n\n##### Q-Learning 整体算法\n\n![q4](20190116001\\q4.png)\n\n这一张图概括了我们之前所有的内容. 这也是 Q learning 的算法, 每次更新我们都用到了 Q 现实和 Q 估计, 而且 Q learning 的迷人之处就是 在 Q(s1, a2) 现实 中, 也包含了一个 Q(s2) 的最大估计值, 将对下一步的衰减的最大估计和当前所得到的奖励当成这一步的现实, 很奇妙吧.\n\n 最后我们来说说这套算法中一些参数的意义. \n\n- Epsilon greedy 是用在决策上的一种策略, 比如 epsilon = 0.9 时, 就说明有90% 的情况我会按照 Q 表的最优值选择行为, 10% 的时间使用随机选行为. \n\n- alpha是学习率, 来决定这次的误差有多少是要被学习的, alpha是一个小于1 的数. \n\n- gamma 是对未来 reward 的衰减值. 我们可以这样想象.\n\n##### Q-Learning 中的 Gamma \n\n![q5](20190116001\\q5.png)\n\n我们重写一下 Q(s1) 的公式, 将 Q(s2) 拆开, 因为Q(s2)可以像 Q(s1)一样,是关于Q(s3) 的, 所以可以写成这样, 然后以此类推, 不停地这样写下去, 最后就能写成这样, 可以看出Q(s1) 是有关于之后所有的奖励, 但这些奖励正在衰减, 离 s1 越远的状态衰减越严重. \n\n不好理解? 行, 我们想象 Qlearning 的机器人天生近视眼, gamma = 1 时, 机器人有了一副合适的眼镜, 在 s1 看到的 Q 是未来没有任何衰变的奖励, 也就是机器人能清清楚楚地看到之后所有步的全部价值, 但是当 gamma =0, 近视机器人没了眼镜, 只能摸到眼前的 reward, 同样也就只在乎最近的大奖励, 如果 gamma 从 0 变到 1, 眼镜的度数由浅变深, 对远处的价值看得越清楚, 所以机器人渐渐变得有远见, 不仅仅只看眼前的利益, 也为自己的未来着想.\n\n#### 2.4 Sarsa\n\n在强化学习中 Sarsa 和 Q learning及其类似, 这节内容会基于之前的 Q learning. 和上次一样, 我们还是使用写作业和看电视这个例子. 没写完作业去看电视被打, 写完了作业有糖吃.\n\n##### Sarsa决策\n\n![s2](20190116001\\s2.png)\n\nSarsa 的决策部分和 [Q learning]一模一样, 因为我们使用的是 Q 表的形式决策, 所以我们会在 Q 表中挑选值较大的动作值施加在环境中来换取奖惩. 但是不同的地方在于 Sarsa 的更新方式是不一样的.\n\n##### Sarsa 更新行为准则\n\n![s3](20190116001\\s3.png)\n\n同样, 我们会经历正在写作业的状态 s1, 然后再挑选一个带来最大潜在奖励的动作 a2, 这样我们就到达了 继续写作业状态 s2, 而在这一步, 如果你用的是 Q learning, 你会观看一下在 s2 上选取哪一个动作会带来最大的奖励。但是在真正要做决定时, 却不一定会选取到那个带来最大奖励的动作, Q-learning 在这一步只是估计了一下接下来的动作值。\n\n而 Sarsa 是实践派, 他说到做到, 在 s2 这一步估算的动作也是接下来要做的动作。所以 Q(s1, a2) 现实的计算值, 我们也会稍稍改动, 去掉maxQ, 取而代之的是在 s2 上我们实实在在选取的 a2 的 Q 值. 最后像 Q learning 一样, 求出现实和估计的差距 并更新 Q 表里的 Q(s1, a2)。\n\n##### 对比Sarsa和Q-learning\n\n##### ![s4](20190116001\\s4.png)\n\n从算法来看, 这就是他们两最大的不同之处：\n\n因为 Sarsa 是说到做到型，所以我们也叫他 on-policy，在线学习，学着自己在做的事情。\n\n 而 Q learning 是说到但并不一定做到， 所以它也叫作 Off-policy，离线学习，而因为有了 maxQ，Q-learning 也是一个特别勇敢的算法。\n\n![s5](20190116001\\s5.png)\n\n为什么说他勇敢呢， 因为 Q learning 机器人永远都会选择最近的一条通往成功的道路，不管这条路会有多危险；而 Sarsa 则是相当保守，他会选择离危险远远的，拿到宝藏是次要的，保住自己的小命才是王道，这就是使用 Sarsa 方法的不同之处。\n\n这种不同之处使得 Sarsa 相对于 Qlearning更加的胆小。因为 Qlearning 永远都是想着 `maxQ`最大化， 因为这个 `maxQ` 而变得贪婪， 不考虑其他非 `maxQ` 的结果。我们可以理解成 Qlearning 是一种贪婪、大胆、勇敢的算法，对于错误、 死亡并不在乎；而 Sarsa 是一种保守的算法，他在乎每一步决策，对于错误和死亡比较敏感。两种算法都有他们的好处，比如在实际中，你比较在乎机器的损害，用一种保守的算法，在训练时就能减少损坏的次数。\n\n##### 什么是Sarsa（lambda）\n\n现在我们知道了Sarsa是一种在线学习法，但是这个 lambda 到底是什么。\n\n其实吧, Sarsa 是一种单步更新法，在环境中每走一步，更新一次自己的行为准则，我们可以在这样的 Sarsa 后面打一个括号， 说他是 Sarsa(0)， 因为他等走完这一步以后直接更新行为准则。如果延续这种想法，走完这步，再走一步，然后再更新，我们可以叫他 Sarsa(1)。同理， 如果等待回合完毕我们一次性再更新呢，比如这回合我们走了 n 步，那我们就叫 Sarsa(n)。为了统一这样的流程，我们就有了一个 lambda值来代替我们想要选择的步数，这也就是 Sarsa(lambda) 的由来。我们看看最极端的两个例子，对比单步更新和回合更新，看看回合更新的优势在哪里。\n\n![sl3](20190116001\\sl3.png)\n\n虽然我们每一步都在更新，但是在没有获取宝藏的时候，我们现在站着的这一步的没有得到任何更新，也就是直到获取宝藏时，我们才为获取到宝藏的上一步更新为：这一步很好, 和获取宝藏是有关联的，而之前为了获取宝藏所走的所有步都被认为和获取宝藏没关系。回合更新虽然我要等到这回合结束，才开始对本回合所经历的所有步都添加更新，但是这所有的步都是和宝藏有关系的，都是为了得到宝藏需要学习的步，所以每一个脚印在下回合被选则的几率又高了一些。在这种角度来看，回合更新似乎会有效率一些。\n\n我们看看这种情况，还是使用单步更新的方法在每一步都进行更新，但是同时记下之前的寻宝之路。你可以想像，每走一步，插上一个小旗子，这样我们就能清楚的知道除了最近的一步，找到宝物时还需要更新哪些步了。\n\n 不过, 有时候情况可能没有这么乐观。开始的几次，因为完全没有头绪，我可能在原地打转了很久，然后才找到宝藏，那些重复的脚步真的对我拿到宝藏很有必要吗? 答案我们都知道。所以Sarsa(lambda)就来拯救你啦。\n\n##### Lambda含义与取值\n\n![sl4](20190116001\\sl4.png)\n\n其实 lambda 就是一个衰变值, 他可以让你知道离奖励越远的步可能并不是让你最快拿到奖励的步, 所以我们想象我们站在宝藏的位置, 回头看看我们走过的寻宝之路, 离宝藏越近的脚印越看得清, 远处的脚印太渺小, 我们都很难看清, 那我们就索性记下离宝藏越近的脚印越重要, 越需要被好好的更新。和之前我们提到过的 奖励衰减值 gamma 一样, lambda 是脚步衰减值, 都是一个在 0 和 1 之间的数。\n\n![sl5](20190116001\\sl5.png)\n\n当 lambda 取0, 就变成了 Sarsa 的单步更新；当 lambda 取 1, 就变成了回合更新, 对所有步更新的力度都是一样。当 lambda 在 0 和 1 之间, 取值越大, 离宝藏越近的步更新力度越大。这样我们就不用受限于单步更新的每次只能更新最近的一步, 我们可以更有效率的更新所有相关步了。\n\nSarsa-lambda 是基于 Sarsa 方法的升级版, 他能更有效率地学习到怎么样获得好的 reward. 如果说 Sarsa 和 Qlearning 都是每次获取到 reward, 只更新获取到 reward 的前一步. 那 Sarsa-lambda 就是更新获取到 reward 的前 lambda 步. lambda 是在 [0, 1] 之间取值,\n\n如果 lambda = 0, Sarsa-lambda 就是 Sarsa, 只更新获取到 reward 前经历的最后一步.\n\n如果 lambda = 1, Sarsa-lambda 更新的是 获取到 reward 前所有经历的步.\n\n[学习更多-莫烦PYTHON]: https://morvanzhou.github.io/tutorials/machine-learning/reinforcement-learning/3-3-tabular-sarsa-lambda/\t\"莫烦PYTHON\"\n\n","categories":["reinforcement learning"]},{"title":"实现将字符串转换为整数","url":"/2019/01/16/2019011602/","content":"\n实现将字符串转换为整数的atoi。该函数首先丢弃尽可能多的空白字符，直到找到第一个非空白字符。然后，从这个字符开始，取一个可选的初始加号或减号，后面跟着尽可能多的数字，并将它们解释为一个数值。\n\n字符串可以在组成整数的字符之后包含其他字符，这些字符将被忽略，并且对该函数的行为没有影响。\n\n如果str中的第一个非空格字符序列不是有效的整数，或者由于str为空或只包含空格字符而不存在这样的序列，则不执行转换。如果无法执行有效的转换，则返回零值。\n\n<!-- more -->\n\n## Problem\n\n**Note:**\n\n- Only the space character `' '` is considered as whitespace character.\n\n- Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.\n\n- **Example 1:**\n\n  ```\n  Input: \"42\"\n  Output: 42\n  ```\n\n  **Example 2:**\n\n  ```\n  Input: \"   -42\"\n  Output: -42\n  Explanation: The first non-whitespace character is '-', which is the minus sign.\n               Then take as many numerical digits as possible, which gets 42.\n  ```\n\n  **Example 3:**\n\n  ```\n  Input: \"4193 with words\"\n  Output: 4193\n  Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.\n  ```\n\n  **Example 4:**\n\n  ```\n  Input: \"words and 987\"\n  Output: 0\n  Explanation: The first non-whitespace character is 'w', which is not a numerical \n               digit or a +/- sign. Therefore no valid conversion could be performed.\n  ```\n\n  **Example 5:**\n\n  ```\n  Input: \"-91283472332\"\n  Output: -2147483648\n  Explanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer.\n               Thefore INT_MIN (−231) is returned.\n  ```\n\n------\n\n## Solution\n\n【c++】\n\n```\nint myAtoi(string str) {\n    long result = 0;\n    int indicator = 1;\n    for(int i = 0; i<str.size();)\n    {\n        i = str.find_first_not_of(' ');\n        if(str[i] == '-' || str[i] == '+')\n            indicator = (str[i++] == '-')? -1 : 1;\n        while('0'<= str[i] && str[i] <= '9') \n        {\n            result = result*10 + (str[i++]-'0');\n            if(result*indicator >= INT_MAX) return INT_MAX;\n            if(result*indicator <= INT_MIN) return INT_MIN;                \n        }\n        return result*indicator;\n    }\n}\n```","tags":["Arrays","leetcode"],"categories":["leetcode"]},{"title":"tensorflow随笔","url":"/2019/01/15/2019011502/","content":"\n### CNN网络搭建\n\n<!-- more -->\n\n**CNN网络结构**\n\n输入的图像shape为 [batch_size, height, width, depth]\n\n第一层：卷积层 conv1\n\n第二层：池化层 pool1\n\n第三层：标准化层 norm1\n\n第四层：卷积层 conv2\n\n第五层：标准化层 norm2\n\n第六层：池化层 pool2\n\n第七层：全联接层 local1\n\n第八层：全联接层 local2\n\n第九层：输出层 softmax_linear\n\n\n\n**tf.nn.conv1d( value, filters, stride,padding,use_cudnn_on_gpu=None,data_format=None, name=None)**\n\nvalue的格式为：[batch, in_width, in_channels]，batch为样本维，表示多少个样本，in_width为宽度维，表示样本的宽度，in_channels维通道维，表示样本有多少个通道。 事实上，也可以把格式看作如下:[batch, 行数, 列数]，把每一个样本看作一个平铺开的二维数组。这样的话可以方便理解。\n\nfilters：在注释中，filters的格式为：[filter_width, in_channels, out_channels]。按照value的第二种看法，filter_width可以看作每次与value进行卷积的行数，in_channels表示value一共有多少列（与value中的in_channels相对应）。out_channels表示输出通道，可以理解为一共有多少个卷积核，即卷积核的数目。\n\nstride：一个整数，表示步长，每次（向下）移动的距离（TensorFlow中解释是向右移动的距离，这里可以看作向下移动的距离）。\n\npadding：同conv2d，value是否需要在下方填补0。\n\n\n\n**tf.nn.conv2d(input, filter, strides, padding, use_cudnn_on_gpu=None, name=None) **\n\n除去name参数用以指定该操作的name，与方法有关的一共五个参数：\n\n- input： \n  指需要做卷积的输入图像，它要求是一个Tensor，具有[batch, in_height, in_width, in_channels]这样的shape，具体含义是[训练时一个batch的图片数量, 图片高度, 图片宽度, 图像通道数]，注意这是一个4维的Tensor，要求类型为float32和float64其中之一。\n\n\n- filter： \n  相当于CNN中的卷积核，它要求是一个Tensor，具有[filter_height, filter_width, in_channels, out_channels]这样的shape，具体含义是[卷积核的高度，卷积核的宽度，图像通道数，卷积核个数]，要求类型与参数input相同，有一个地方需要注意，第三维in_channels，就是参数input的第四维。\n\n\n- strides：卷积时在图像每一维的步长，这是一个一维的向量，长度4。\n\n\n- padding： \n  string类型的量，只能是”SAME”,”VALID”其中之一，这个值决定了不同的卷积方式（后面会介绍）\n\n\n- use_cudnn_on_gpu： bool类型，是否使用cudnn加速，默认为true。\n\n  \n\n**tf.nn.max_pool(value, ksize, strides, padding, name=None)**\n参数是四个，和卷积很类似：\n\n- 第一个参数value：需要池化的输入，一般池化层接在卷积层后面，所以输入通常是feature map，依然是[batch, height, width, channels]这样的shape\n\n- 第二个参数ksize：池化窗口的大小，取一个四维向量，一般是[1, height, width, 1]，因为我们不想在batch和channels上做池化，所以这两个维度设为了1\n\n- 第三个参数strides：和卷积类似，窗口在每一个维度上滑动的步长，一般也是[1, stride,stride, 1]\n\n- 第四个参数padding：和卷积类似，可以取'VALID' 或者'SAME'\n\n- 返回一个Tensor，类型不变，shape仍然是[batch, height, width, channels]这种形式\n\n  \n\n**tf.get_variable(name,  shape, initializer):** \n\nname就是变量的名称，shape是变量的维度，initializer是变量初始化的方式。\n\n- tf.constant_initializer：常量初始化函数\n\n- tf.random_normal_initializer：正态分布\n\n- tf.truncated_normal_initializer：截取的正态分布\n\n- tf.random_uniform_initializer：均匀分布\n\n- tf.zeros_initializer：全部是0\n\n- tf.ones_initializer：全是1\n\n- tf.uniform_unit_scaling_initializer：满足均匀分布，但不影响输出数量级的随机值\n\n  \n\n1. tf.constant_initializer：常量初始化函数\n\n2. tf.random_normal_initializer：正态分布\n\n3. tf.truncated_normal_initializer：截取的正态分布\n\n4. tf.random_uniform_initializer：均匀分布\n\n5. tf.zeros_initializer：全部是0\n\n6. tf.ones_initializer：全是1\n\n7. tf.uniform_unit_scaling_initializer：满足均匀分布，但不影响输出数量级的随机值\n\n\n**tf.variable_scope**可以让变量有相同的命名，包括tf.get_variable得到的变量，还有tf.Variable的变量。\n\n**tf.name_scope**可以让变量有相同的命名，只是限于tf.Variable的变量。\n\n**tf.truncated_normal_initializer()**，或者简写为tf.TruncatedNormal()生成截断正态分布的随机数，这个初始化方法好像在tf中用得比较多。它有四个参数（mean=0.0, stddev=1.0, seed=None, dtype=dtypes.float32)，分别用于指定均值、标准差、随机数种子和随机数的数据类型，一般只需要设置stddev这一个参数就可以了。\n\n**tf.multiply（）**两个矩阵中对应元素各自相乘\n **tf.matmul（）**将矩阵a乘以矩阵b，生成a * b。\n\n\n\n**np*.*prod()**函数用来计算所有元素的乘积，对于有多个维度的数组可以指定轴，如axis=1指定计算每一行的乘积。\n\n**np.sqrt(x) ** 计算数组各元素的平方根。","tags":["tensorflow"],"categories":["tensorflow"]},{"title":"32位有符号整数的反转数字","url":"/2019/01/15/20190115/","content":"leetcode第7题\n<!-- more -->\n\n# 【leetcode第7题】\n\nGiven a 32-bit signed integer, reverse digits of an integer.\n\n给定一个32位有符号整数，得到该整数的反转数字。\n\n> Example 1:\n> Input: 123\n> Output: 321\n> Example 2:\n> Input: -123\n> Output: -321\n> Example 3:\n> Input: 120\n> Output: 21\n> Note:\n> Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\n>\n> 假设我们正在处理一个环境，只能在32位带符号整数存储整数范围：[−231,  231 − 1]。\n>\n> 对于这个问题，假设函数在反整数溢出时返回0。\n\n# 【c++】\n\n```\nclass Solution {\npublic:\n    int reverse(int x) {\n        long y=0;\n        while(x){ \n            y=y*10+x%10;\n            x/=10;\n        }\n       return (y>INT_MIN && y<INT_MAX)?y:0;\n    }\n};\n```\n# 关于INT_MAX INT_MIN的运算\nValue of INT_MAX is +2147483647.\nValue of INT_MIN is -2147483648.\n因为int占4字节32位，根据二进制编码的规则，INT_MAX = 2^31-1，INT_MIN= -2^31.\n\nC/C++中，所有超过该限值的数，都会出现溢出，出现warning，但是并不会出现error。\n\n如果想表示的整数超过了该限值，可以使用长整型long long 占8字节64位。\n\n由于二进制编码按原码、补码和反码的规则进行运算，所有程序中对INT_MAX和INT_MIN的运算应当格外注意，在出现溢出的时候，不遵循数学规则。\n\nINT_MAX + 1 = INT_MIN\n\nINT_MIN - 1 = INT_MAX\n\nabs(INT_MIN) = INT_MIN\n\n比较有趣的是，INT_MAX + 1 < INT_MAX， INT_MIN - 1 > INT_MIN, abs(INT_MIN) < 0.\n","tags":["leetcode"],"categories":["leetcode"]},{"title":"查找两个数组的中间值","url":"/2019/01/14/20190114/","content":"leetcode第4题\n<!-- more -->\n\n# # 【leetcode第4题】\n\nThere are two sorted arrays nums1 and nums2 of size m and n respectively.\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\nYou may assume nums1 and nums2 cannot be both empty.\n\n分别有大小为m和n的两个排序数组nums1和nums2。\n\n求两个排序数组的中值。总的运行时复杂性应该是O(log (m+n))。\n\n您可以假设nums1和nums2不能同时为空。\n\nExample 1:\nnums1 = [1, 3]\nnums2 = [2]\nThe median is 2.0\n\nExample 2:\nnums1 = [1, 2]\nnums2 = [3, 4]\nThe median is (2 + 3)/2 = 2.5\n\n# # 【思路】\n\n首先理解什么是中间值，在统计学里面就是用于把一个数集分为两个等长的子集，一个子集总是比另一个大。当我们理解了中间值的使用，我们就和答案非常接近了。\n\n1、首先把A从一个随机的位置i分成两个部分：\n           left_A             |        right_A\n\t A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]\nA有m个元素，因此有m-1种切割的方式， len(left_A) = i, len(right_A) = m - i\n（i=0时，left_A为空；i=m，right_A为空）\n\n2、同样的，把B从一个随机的位置j分成两个部分：\n           left_B             |        right_B\n\t B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]\n\n3、把A和B放在一起，则有：\n           left_part          |        right_part\n     A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]\n\t B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]\n\n4、按照中间值的含义，如果：\n1) len(left_part) == len(right_part)\n2) max(left_part) <= min(right_part)\n那么median = (max(left_part) + min(right_part))/2.\n具体表示就是：\n    (1) i + j == m - i + n - j\n         (or:如果m+n为奇数，i+j比m-i+n-j多1则\n              i + j == m - i + n - j + 1) \n            if n >= m, we just need to set: i = 0 ~ m, j = (m + n + 1)/2 - i\n         (为什么n>=m，因为i有可能取到m，若同时n<m则j将为负数，会得到无效解)\n    (2) B[j-1] <= A[i] and A[i-1] <= B[j]\n\n5、因此我们应该做的是：\n    Searching i in [0, m], to find an object i that:\n        B[j-1] <= A[i] and A[i-1] <= B[j], ( where j = (m + n + 1)/2 - i )\n\n这个搜索i的过程具体描述为：\n\n 1 设置imin = 0, imax = m, 在[imin, imax]里面展开搜索\n\n 2 i = (imin + imax)/2, j = (m + n + 1)/2 - i\n\n 3 现在我们有len(left_part)==len(right_part).有三种情况：\n\n​     a B[j-1] <= A[i] and A[i-1] <= B[j]\n​         找到了i，可以停止搜索了。\n​     b B[j-1] > A[i]\n​         B的左侧最大值比A的右侧最小值大了，说明A[i]太小，需要向右移动i，i增大同时j会减小。\n​         要增大i的话，要调整搜索范围变成[i+1, imax]，因此设置imin = i+1，回到2.\n​     c A[i-1] > B[j]\n​        A的左侧最大值比B的右侧最小值大了，说明A[i-1]太大，需要向左移动i，i减小同时j会增大。\n​        要减小i的话，要调整搜索范围变成[imin, i-1]，因此设置imax = i-1，回到2.\n\n```\n\n```\n\n6、i搜索到之后，中间值为：\n     m+n为奇数时：max(A[i-1], B[j-1])\n     m+n为偶数时：(max(A[i-1], B[j-1]) + min(A[i], B[j]))/2 \n\n7、接下来我们来考虑极限情况， i=0,i=m,j=0,j=n时，A[i-1],B[j-1],A[i],B[j]中的某些可能会不存在，因此我们就不用同时检查B[j-1] <= A[i]和 A[i-1] <= B[j].只检查其中一个就够了。\n\n所以我们应该做的是：\n\n​    Searching i in [0, m], to find an object `i` that:\n​        (j == 0 or i == m or B[j-1] <= A[i]) and\n​        (i == 0 or j == n or A[i-1] <= B[j])\n​        where j = (m + n + 1)/2 - i\n\n在一个搜索循环里，我们只会遇到三种情况：\n\n​     a (j == 0 or i == m or B[j-1] <= A[i]) and\n​         (i == 0 or j = n or A[i-1] <= B[j])\n​          找到了i可以停止了\n\n​    b i < m and B[j - 1] > A[i]\n​         i太小，需要增大\n\n​    c i > 0 and A[i - 1] > B[j]\n​         i太大，需要减小\n\n   （由于i < m ==> j > 0 和 i > 0 ==> j < n，因此b和c不用检查j）\n\n# 【解】\n\n```\ndef median(A, B):\n    m, n = len(A), len(B)\n    if m > n:\n        A, B, m, n = B, A, n, m\n    if n == 0:\n        raise ValueError\n    imin, imax, half_len = 0, m, (m + n + 1) / 2\n    while imin <= imax:\n        i = (imin + imax) / 2\n        j = half_len - i\n        if i < m and B[j-1] > A[i]:\n            # i is too small, must increase it\n            imin = i + 1\n        elif i > 0 and A[i-1] > B[j]:\n            # i is too big, must decrease it\n            imax = i - 1\n        else:\n            # i is perfect\n            if i == 0: max_of_left = B[j-1]\n            elif j == 0: max_of_left = A[i-1]\n            else: max_of_left = max(A[i-1], B[j-1])\n            if (m + n) % 2 == 1:\n                return max_of_left\n            if i == m: min_of_right = B[j]\n            elif j == n: min_of_right = A[i]\n            else: min_of_right = min(A[i], B[j])\n            return (max_of_left + min_of_right) / 2.0\n```\n【c++】\n```\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> A=nums1,B=nums2,p;\n        int m=nums1.size(), n=nums2.size(),pass=0;\n        if(m>n){\n            pass=m;\n            m=n;\n            n=pass;\n            p=A;\n            A=B;\n            B=p;\n        }\n        int imin=0,imax=m;\n        int max_of_left=0,min_of_right=0;\n        int i=0,j=0;\n        while (imin <= imax ){\n            i = (imin + imax) / 2;\n            j = (m + n + 1) / 2 - i;\n            if(i < m && B[j-1] > A[i]){\n                imin=i+1;\n            }\n            else if( i > 0 && A[i-1] > B[j]){\n                imax=i-1;\n            }\n            else{\n                if(i==0){\n                    max_of_left = B[j-1];\n                }\n                else if(j == 0){\n                    max_of_left = A[i-1];\n                }else{\n                    max_of_left = max(A[i-1], B[j-1]);\n                }\n                if ((m + n) % 2 == 1){\n                    return max_of_left;\n                } \n                if(i==m){\n                    min_of_right = B[j];\n                }\n                else if(j == n){\n                    min_of_right = A[i];\n                }else{\n                    min_of_right = min(A[i], B[j]);\n                }\n                return (max_of_left + min_of_right) / 2.0;\n            }\n        }\n        return 0;\n        \n    }\n};\n```","tags":["Arrays","leetcode"],"categories":["leetcode"]},{"title":"about","url":"/about/index.html","content":"\n随便搞搞罢了\n\n"},{"title":"gallery","url":"/gallery/index.html","content":"\n\n\n![点击查看源网页](https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1547986120&di=4983e496983f5e4accd976839327e159&src=http://wx3.sinaimg.cn/wap720/bf0a6d34ly1fhqqqijmp5j210c0kugnq.jpg)\n\n![点击查看源网页](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1547996301709&di=06d2d4b1b401dafcb2d69aac0c66b4ec&imgtype=0&src=http%3A%2F%2Fpic.rmb.bdstatic.com%2F05f9a8bce23cf396e99993f333d0fb9c.jpeg)\n\n![点击查看源网页](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1547996301709&di=b2d9e1f5ce1f30443ac8fe22296b7a3a&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20181209%2Fa35bbc986cd145828d003dcdcc315738.jpeg)\n\n![点击查看源网页](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1547996301709&di=db6e7fda8c4c1901262b114485943950&imgtype=0&src=http%3A%2F%2Fr.sinaimg.cn%2Flarge%2Ftc%2Fmmbiz_qpic_cn%2F94174cf13665e31bf0dcc36105c96755.jpg)\n\n![点击查看源网页](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1547996301708&di=125822c32cda3de7ba43f594b00009fa&imgtype=0&src=http%3A%2F%2Fn.sinaimg.cn%2Fent%2Ftransform%2F711%2Fw630h881%2F20190107%2FnpUV-hrfcctn4275093.jpg)"}]
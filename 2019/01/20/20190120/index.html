<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="教程">
  
  
    <meta name="description" content="张小姐的个人博客，主要内容是编程，个人学习记录">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    C++STL之哈希表||unordered_map |
    
    ZhangM</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  <article id="post-20190120" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++STL之哈希表||unordered_map
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/01/20/20190120/" class="article-date">
  <time datetime="2019-01-20T01:49:45.000Z" itemprop="datePublished">2019-01-20</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c++</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <p>C++ STL中，哈希表对应的容器是 <code>unordered_map</code>（since C++ 11）。根据 C++ 11 标准的推荐，用 <code>unordered_map</code> 代替 <code>hash_map</code>。</p>
<a id="more"></a>
<h2><span id="哈希表">哈希表</span></h2><p>先来回顾一下数据结构中哈希表相关的知识。</p>
<p>哈希表是根据关键码值(key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数。</p>
<p>哈希表的一个重要问题就是如何解决映射冲突的问题。常用的有两种：<strong>开放地址法</strong> 和 <strong>链地址法</strong>。</p>
<p>STL中，<code>map</code> 对应的数据结构是 <strong>红黑树</strong>。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 <strong>O(logN)</strong>。而 <code>unordered_map</code> 对应 <strong>哈希表</strong>，哈希表的特点就是查找效率高，时间复杂度为常数级别 <strong>O(1)</strong>， 而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 <code>unordered_map</code> 容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 <code>map</code> 容器。</p>
<h2><span id="说明">说明</span></h2><ul>
<li><p>unordered_map 是一种关联容器，用于存储由关键值 (Key Value，以下称为Key 值) 和映射值 (Mapped Value，以下称为映射值) 组成的元素，并且允许根据其 Key 值快速检索各个元素。 </p>
</li>
<li><p>在 unordered_map 容器中，Key 值通常用来唯一标识元素，映射值是与该 Key 值关联内容的对象。Key 值与映射值的类型可能不同。 </p>
</li>
<li><p>在 unordered_map 内部，元素没有按照其 Key 值与映射值的任何顺序进行排序 ，而是根据它们的 Hash 值组织成桶，允许它们通过其 Key 值直接快速访问单个元素（通常具有常数等级的平均时间复杂度）。 </p>
</li>
<li><p>unordered_map 容器与 map 容器相比，通过 Key 值访问各个元素的速度更快，然而通过其元素子集进行范围迭代的效率通常较低。 </p>
</li>
<li><p>unordered_map 实现了直接访问操作符 (operator[])，它允许使用 Key 值作为输入参数，直接访问映射值。 </p>
</li>
<li><p>容器中的迭代器至少是前向迭代器。</p>
<h2><span id="容器属性">容器属性</span></h2><p><strong>关联性</strong><br>关联容器中的元素的参考地址指的是其 Key 值，而不是他们在容器中的绝对地址；<br><strong>无序性</strong><br>无序容器使用 Hash 表来组织元素，这些 Hash 表允许无序容器通过 Key 值快速访问元素；<br><strong>映射</strong><br>每个元素将一个 Key 值与映射值关联起来，Key 值用于标识其主要内容是映射值的元素；<br><strong>唯一关键值</strong><br>容器中不存在同时拥有相同 Key 值的两个元素；<br><strong>分配器感知</strong> </p>
<p>map 容器使用分配器对象动态处理其存储需求。</p>
</li>
</ul>
<h2><span id="常用函数">常用函数</span></h2><h4><span id="bucket">bucket</span></h4><p>size_type bucket ( const key_type&amp; k ) const;</p>
<p>定位元素所在的桶，返回 Key 值为输入参数 k 的元素的所在桶号。<br>桶是容器内部 Hash 表中的一个槽，槽中的元素根据 Key 值分配元素。桶号的编号从 0 到 (bucket_count - 1)。 桶中单个元素可以通过 unordered_map::begin 和 unordered_map::end 返回的范围迭代器进行访问。</p>
<h4><span id="count">count</span></h4><p>size_type count ( const key_type&amp; k ) const;</p>
<p>搜索容器中 Key 值为输入参数 k 的元素，并返回找到元素的数量。由于 unordered_map 容器不允许存在重复的 Key 值，这说明如果容器中存在具有该 Key 值的元素，则该函数返回 1，否则返回 0。</p>
<h4><span id="clear">clear</span></h4><p> 清除 map 中所有元素；</p>
<h4><span id="erase">erase</span></h4><p> 删除 map 中指定位置的元素；</p>
<h4><span id="insert">insert</span></h4><p> 在 map 指定位置添加 pair 类型的元素；</p>
<h4><span id="find">find</span></h4><p> 获取 map 中元素的迭代器；</p>
<h4><span id="begin-end">begin, end</span></h4><p> map 的正向迭代器的起始位置与终点位置</p>
<h2><span id="例题">例题</span></h2><p>摘选自<a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener"> Leetcode 问题 Two Sum</a>：给出一个整数数组，返回两个数的下标值，令其和等于一个指定的目标值。</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>
<p>解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target)</span><br><span class="line">    &#123;</span><br><span class="line">        //Key is the number and value is its index in the vector.</span><br><span class="line">        unordered_map&lt;int, int&gt; hash;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        for (int i = 0; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">            int numberToFind = target - numbers[i];</span><br><span class="line"></span><br><span class="line">            //if numberToFind is found in map, return them</span><br><span class="line">            if (hash.find(numberToFind) != hash.end()) &#123;</span><br><span class="line">                result.push_back(hash[numberToFind]);</span><br><span class="line">                result.push_back(i);            </span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //number was not found. Put it in the map.</span><br><span class="line">            hash[numbers[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/20/20190120/" data-id="cjr78iz4f000dpstcyjb3wyl8" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li></ul>

    </footer>
  
  </div>
  
  
  
    
  <nav class="article-nav">
    
      <a href="/2019/01/21/2019012101/" class="article-nav-link">
        <strong class="article-nav-caption">前一篇</strong>
        <div class="article-nav-title">
          
            Letter Combinations of a Phone Number
          
        </div>
      </a>
    
    
      <a href="/2019/01/19/2019011901/" class="article-nav-link">
        <strong class="article-nav-caption">后一篇</strong>
        <div class="article-nav-title">Integer to Roman and roman to integer</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  
  <div class="outer">
    <ul class="list-inline">
      <li>&copy; 2019 ZhangM</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://zhwangart.github.io">zhwangart</a></li>
      <!--
      <li><a href="/">张萌</a></li>
      -->
    </ul>
  </div>
</footer>
</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="ZhangM"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/search.js"></script>


<script src="/js/ocean.js"></script>

</body>
</html>